RSA公钥加密在计算机产业中被广泛使用在认证和加密。可以从RSA Data Security Inc.获得的RSA公钥加密许可证。公钥加密是使用一对非对称的密码加密或解密的方法。每一对密码由公钥和私钥组成。公钥被广泛发布。私钥是隐密的，不公开。用公钥加密的数据只能够被私钥解密。反过来，使用私钥加密的数据只能用公钥解密。这个非对称的特性使得公钥加密很有用。
　　
　　使用公钥加密法认证
　　
　　认证是一个身份认证的过程。在下列例子中包括甲和乙，公钥加密会非常轻松地校验身份。符号{数据} key意味着"数据"已经使用密码加密或解密。假如甲想校验乙的身份。乙有一对密码，一个是公开的，另一个是私有的。乙透露给甲他的公钥。甲产生一个随机信息发送给乙。 甲——〉乙：random-message
　　
　　乙使用他的私钥加密消息，返回甲加密后的消息。 乙——〉甲：{random-message}乙的私钥
　　
　　甲收到这个消息然后使用乙的以前公开过的公钥解密。他比较解密后的消息与他原先发给乙的消息。如果它们完全一致，就会知道在与乙说话。任意一个中间人不会知道乙的私钥，也不能正确加密甲检查的随机消息。
　　
　　除非你清楚知道你加密的消息。用私钥加密消息，然后发送给其他人不是一个好主意。因为加密值可能被用来对付你，需要注意的是：因为只有你才有私钥，所以只有你才能加密消息。所以，代替加密甲发来的原始消息，乙创建了一个信息段并且加密。信息段取自随机消息（random-message）并具有以下有用的特性：
　　
　　1. 这个信息段难以还原。任何人即使伪装成乙，也不能从信息段中得到原始消息；
　　
　　2. 假冒者将发现不同的消息计算出相同的信息段值；
　　
　　3. 使用信息段，乙能够保护自己。他计算甲发出的随机信息段，并且加密结果，并发送加密信息段返回甲。甲能够计算出相同的信息段并且解密乙的消息认证乙。
　　
　　这个技术仅仅描绘了数字签名。通过加密甲产生的随机消息，乙已经在甲产生的消息签名。因此我们的认证协议还需要一次加密。一些消息由乙产生：
　　
　　甲——〉乙：你好，你是乙么?
　　
　　乙——〉甲：甲，我是乙
　　
　　{信息段[甲，我是乙] } 乙的私钥
　　
　　当你使用这个协议，乙知道他发送给乙的消息，他不介意在上面签名。他先发送不加密的信息，"甲，我是乙。"，然后发送信息段加密的消息版本。甲可以非常方便地校验乙就是乙，同时，乙还没有在他不想要的信息上签名。
　　
　　提交公钥
　　
　　那么，乙怎样以可信的方式提交他的公钥呢？看看认证协议如下所示：
　　
　　甲——〉乙：你好
　　
　　乙——〉甲：嗨，我是乙，乙的公钥
　　
　　甲——〉乙：prove it
　　
　　乙——〉甲：甲，我是乙 {信息段[甲，我是乙] } 乙的私钥
　　
　　在这个协议下，任何人都能够成为"乙"。所有你所要的只是公钥和私钥。你发送给甲说你就是乙，这样你的公钥就代替了乙的密码。然后，你发送用你的私钥加密的消息，证明你的身份。甲却不能发觉你并不是乙。 为了解决这个问题，标准组织已经发明了证书。一个证书有以下的内容：
　　
　　* 证书的发行者姓名
　　
　　* 发行证书的组织
　　
　　* 标题的公钥
　　
　　* 邮戳
　　
　　证书使用发行者的私钥加密。每一个人都知道证书发行者的公钥（这样，每个证书的发行者拥有一个证书）。证书是一个把公钥与姓名绑定的协议。通过使用证书技术，每一个人都可以检查乙的证书，判断是否被假冒。假设乙控制好他的私钥，并且他确实是得到证书的乙，就万事大吉了。
　　
　　这些是修订后的协议：
　　
　　甲——〉乙：你好
　　
　　乙——〉甲：嗨，我是乙，乙的校验
　　
　　甲——〉乙：prove it
　　
　　乙——〉甲：甲，我是乙 {信息段[甲， 我是乙] } 乙的私钥
　　
　　现在当甲收到乙的第一个消息，他能检查证书，签名（如上所述，使用信息段和公钥解密），然后检查标题（乙的姓名），确定是乙。他就能相信公钥就是乙的公钥和要求乙证明自己的身份。乙通过上面的过程，制作一个信息段，用一个签名版本答复甲。甲可以校验乙的信息段通过使用从证书上得到的公钥并检查结果。
　　
　　如果一个黑客，叫H
　　
　　甲——〉H：你好
　　
　　H——〉不能建立一个令甲相信的从乙的消息。
　　
　　交换密码（secret）
　　
　　一旦甲已经验证乙后，他可以发送给乙一个只有乙可以解密、阅读的消息：
　　
　　甲——〉乙：{secret}乙的公钥
　　
　　唯一找到密码的方法只有使用乙的私钥解码上述的信息。交换密码是另一个有效使用密码加密的方法。即使在甲和乙之间的通讯被侦听，只有乙才能得到密码。
　　
　　使用密码作为另一个secret-key增强了网络的安全性，但是这次这是一个对称的加密算法（例如DES、RC4、IDE甲）。因为甲在发送给乙之前产生了密码，所以甲知道密码。乙知道密码因为乙有私钥，能够解密甲的信息。但他们都知道密码，他们都能够初始化一个对称密码算法，而且开始发送加密后的信息。这儿是修定后的协议：
　　
　　甲——〉乙：你好
　　
　　乙——〉甲：嗨，我是乙，乙的校验
　　
　　甲——〉乙：prove it
　　
　　乙——〉甲：甲，我是乙 {信息段[甲，我是乙] }乙的私钥
　　
　　甲——〉乙：ok 乙，here is a secret {secret}乙的公钥
　　
　　乙——〉甲：{some message}secret-key
　　
　　黑客窃听
　　
　　那么如果有一个恶意的黑客H在甲和乙中间，虽然不能发现甲和乙已经交换的密码，但能干扰他们的交谈。他可以放过大部分信息，选择破坏一定的信息（这是非常简单的，因为他知道甲和乙通话采用的协议）。
　　
　　甲——〉H：你好
　　
　　H——〉乙：你好
　　
　　乙——〉H：嗨，我是乙，乙的校验
　　
　　H——〉甲：嗨，我是乙，乙的校验
　　
　　甲——〉H：prove it
　　
　　H——〉乙：prove it
　　
　　乙——〉H：甲，我是乙 {信息段[甲，我是乙] }乙的私钥
　　
　　H——〉甲：甲，我是乙 {信息段[甲，我是乙] }乙的私钥
　　
　　甲——〉H：ok 乙，here is a secret {secret} 乙的公钥
　　
　　H——〉乙：ok 乙，here is a secret {secret} 乙的公钥
　　
　　乙——〉H：{some message}secret-key
　　
　　H——〉甲：Garble[{some message}secret-key ]
　　
　　H忽略一些数据不修改，直到甲和乙交换密码。然后H干扰乙给甲的信息。在这一点上，甲相信乙，所以他可能相信已经被干扰的消息并且尽力解密。
　　
　　需要注意的是，H不知道密码，他所能做的就是毁坏使用秘钥加密后的数据。基于协议，H可能不能产生一个有效的消息。但下一次呢？
　　
　　为了阻止这种破坏，甲和乙在他们的协议中产生一个校验码消息（message authentication code）。一个校验码消息（MAC）是一部分由密码和一些传输消息产生的数据。信息段算法描述的上述特性正是它们抵御H的功能：
　　
　　MAC= Digest[some message，secret ]
　　
　　因为H不知道密码，他不能得出正确的值。即使H随机干扰消息，只要数据量大，他成功的机会微乎其微。例如，使用HD5（一个RSA发明的好的加密算法），甲和乙能够发送128位MAC值和他们的消息。H猜测正确的MAC的几率将近1/18，446，744，073，709，551，616约等于零。
　　
　　这是又一次修改后的协议：
　　
　　甲——〉乙：你好
　　
　　乙——〉甲：嗨，我是乙，乙的校验
　　
　　甲——〉乙：prove it
　　
　　乙——〉甲：嗨，我是乙，乙的校验
　　
　　甲，我是乙
　　
　　{信息段[甲，我是乙] } 乙的私钥
　　
　　ok 乙，here is a secret {secret} 乙的公钥
　　
　　{some message，MAC}secret-key
　　
　　现在H已经无技可施了。他干扰了得到的所有消息，但MAC计算机能够发现他。甲和乙能够发现伪造的MAC值并且停止交谈。H不再能与乙通讯。 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








谈到网络安全访问，相信大家首先想到的就是安全Shell，也就是Secure Shell，通常简写为SSH。这是因为SSH安装容易、使用简单，而且比较常见，一般的Unix系统、Linux系统、FreeBSD系统都附带有支持SSH的应用程序包。
　　
　　1、什么是SSH ？
　　
　　　　传统的网络服务程序，如FTP、Pop和Telnet在传输机制和实现原理上是没有考虑安全机制的，其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，别有用心的人通过窃听等网络攻击手段非常容易地就可以截获这些数据、用户帐号和用户口令。而且，这些网络服务程序的简单安全验证方式也有其弱点，那就是很容易受到"中间人"（man-in-the-middle）这种攻击方式的攻击。所谓"中间人"的攻击方式，就是"中间人 "冒充真正的服务器接收你的传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被"中间人"一转手做了手脚之后，就会出现很严重的问题。
　　　　SSH是英文Secure Shell的简写形式。通过使用SSH，你可以把所有传输的数据进行加密，这样"中间人"这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为 FTP、Pop、甚至为PPP提供一个安全的"通道"。
　　　　最初的SSH是由芬兰的一家公司开发的。但是因为受版权和加密算法的限制，现在很多人都转而使用OpenSSH。OpenSSH是SSH的替代软件包，而且是免费的，可以预计将来会有越来越多的人使用它而不是SSH。
　　最后，SSH在运行方式上也很有特色。不像其他的TCP/IP应用，SSH被设计为工作于自己的基础之上，而不是利用包装（wrappers）或通过 Internet守护进程inetd。但是许多人想通过TCP包装来运行SSH守护进程。虽然你可以通过tcpd（从inetd上运行启动）来运行SSH 进程，但这完全没有必要。
　　
　　
　　
　　2、SSH协议的内容
　　
　　　　SSH协议是建立在应用层和传输层基础上的安全协议，它主要由以下三部分组成，共同实现SSH的安全保密机制。
　　　　传输层协议，它提供诸如认证、信任和完整性检验等安全措施，此外它还可以任意地提供数据压缩功能。通常情况下，这些传输层协议都建立在面向连接的TCP数据流之上。
　　　　用户认证协议层，用来实现服务器的跟客户端用户之间的身份认证，它运行在传输层协议之上。
　　　　连接协议层，分配多个加密通道至一些逻辑通道上，它运行在用户认证层协议之上。
　　　　
　　　　当安全的传输层连接建立之后，客户端将发送一个服务请求。当用户认证层连接建立之后将发送第二个服务请求。这就允许新定义的协议可以和以前的协议共存。连接协议提供可用作多种目的通道，为设置安全交互Shell会话和传输任意的TCP/IP端口和X11连接提供标准方法。
　　
　　
　　
　　3、SSH的安全验证
　　
　　　　从客户端来看，SSH提供两种级别的安全验证。
　　　　
　　　　第一种级别（基于口令的安全验证），只要你知道自己的帐号和口令，就可以登录到远程主机，并且所有传输的数据都会被加密。但是，这种验证方式不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到"中间人"这种攻击方式的攻击。
　　　　
　　　　第二种级别（基于密匙的安全验证），需要依靠密匙，也就是你必须为自己创建一对密匙，并把公有密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在你在该服务器的用户根目录下寻找你的公有密匙，然后把它和你发送过来的公有密匙进行比较。如果两个密匙一致，服务器就用公有密匙加密"质询"（challenge）并把它发送给客户端软件。客户端软件收到"质询"之后就可以用你的私人密匙解密再把它发送给服务器。
　　　　与第一种级别相比，第二种级别不需要在网络上传送用户口令。另外，第二种级别不仅加密所有传送的数据，而"中间人"这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能慢一些。
　　
　　
　　
　　4、SSH的应用
　　
　　　　首先，SSH最常见的应用就是，用它来取代传统的Telnet、FTP等网络应用程序，通过SSH登录到远方机器执行你想进行的工作与命令。在不安全的网路通讯环境中，它提供了很强的验证（authentication）机制与非常安全的通讯环境。实际上，SSH开发者的原意是设计它来取代原 UNIX系统上的rcp、rlogin、rsh等指令程序的；但经过适当包装后，发现它在功能上完全可以取代传统的Telnet、FTP等应用程序。
　　　　传统 BSD 风格的 r 系列指令（如 rcp，rsh，rlogin）往往都被视为不安全的，很容易就被各种网络攻击手段所破解，几乎所有找得到有关UNIX安全的书或文件，都会一而再、再而三地警告系统管理者，留心r系列指令的设定，甚至要求系统管理者将r系列指令通通关闭。
　　　　而用来替代r系列指令的SSH，则在安全方面做了极大的强化，不但对通讯内容可以进行极为安全的加密保护，同时也强化了对身份验证的安全机制，它应用了在密码学（Cryptography）中已发展出来的数种安全加密机制，如 Symmetric Key Cryptography，Asymmetric Key Cryptography， One-way Hash Function，Random-number Generation等，来加强对于身份验证与通讯内容的安全保护。通讯时资料的加密有IDEA，three-key triple DES，DES，RC4-128，TSS，Blowfish 等数种多种安全加密算法可供选择，加密的key则是通过 RSA 进行交换的。资料的加密可以对抗IP spoofing，RSA这种非对称性的加密机制则可用来对抗DNS spoofing与IP routing spoofing，同时RSA也可以进行对主机身份的验证。
　　　　其次，通过使用用SSH可以在本地主机和远程服务器之间设置"加密通道"，并且这样设置的"加密通道"可以跟常见的Pop应用程序、X应用程序、Linuxconf应用程序相结合，提供安全保障。
　　　　SSH的"加密通道"是通过"端口转发"来实现的。你可以在本地端口（没有用到的）和在远程服务器上运行的某个服务的端口之间建立"加密通道"。然后只要连接到本地端口。所有对本地端口的请求都被SSH加密并且转发到远程服务器的端口。当然只有远程服务器上运行SSH服务器软件的时候"加密通道"才能工作。

／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／


第一部分：协议概览
　　
　　整个通讯过程中，经过下面几个阶段协商实现认证连接。
　　
　　第一阶段:
　　
　　由客户端向服务器发出 TCP 连接请求。TCP 连接建立后，客户端进入等待，服务器向客户端发送第一个报文，宣告自己的版本号，包括协议版本号和软件版本号。协议版本号由主版本号和次版本号两部分组成。它和软件版本号一起构成形如：
　　
　　"SSH-<主协议版本号>.<次协议版本号>-<软件版本号>\n"
　　
　　的字符串。其中软件版本号字符串的最大长度为40个字节，仅供调试使用。客户端接到报文后，回送一个报文，内容也是版本号。客户端响应报文里的协议版本号这样来决定：当与客户端相比服务器的版本号较低时，如果客户端有特定的代码来模拟，则它发送较低的版本号；如果它不能，则发送自己的版本号。当与客户端相比服务器的版本号较高时，客户端发送自己的较低的版本号。按约定，如果协议改变后与以前的相兼容，主协议版本号不变；如果不相兼容，则主主协议版本号升高。
　　
　　服务器接到客户端送来的协议版本号后，把它与自己的进行比较，决定能否与客户端一起工作。如果不能，则断开TCP 连接；如果能，则按照二进制数据包协议发送第一个二进制数据包，双方以较低的协议版本来一起工作。到此为止，这两个报文只是简单的字符串，你我等凡人直接可读。
　　
　　第二阶段:
　　
　　协商解决版本问题后，双方就开始采用二进制数据包进行通讯。由服务器向客户端发送第一个包，内容为自己的 RSA主机密钥(host key)的公钥部分、RSA服务密钥(server key)的公钥部分、支持的加密方法、支持的认证方法、次协议版本标志、以及一个 64 位的随机数(cookie)。这个包没有加密，是明文发送的。客户端接收包后，依据这两把密钥和被称为cookie的 64 位随机数计算出会话号(session id)和用于加密的会话密钥(session key)。随后客户端回送一个包给服务器，内容为选用的加密方法、cookie的拷贝、客户端次协议版本标志、以及用服务器的主机密钥的公钥部分和服务密钥的公钥部分进行加密的用于服务器计算会话密钥的32 字节随机字串。除这个用于服务器计算会话密钥的 32字节随机字串外，这个包的其他内容都没有加密。之后，双方的通讯就是加密的了，服务器向客户端发第二个包（双方通讯中的第一个加密的包）证实客户端的包已收到。
　　
　　第三阶段:
　　
　　双方随后进入认证阶段。可以选用的认证的方法有：
　　
　　(1) ~/.rhosts 或 /etc/hosts.equiv 认证（缺省配置时不容许使用它）;
　　(2) 用 RSA 改进的 ~/.rhosts 或 /etc/hosts.equiv 认证；
　　(3) RSA 认证；
　　(4) 口令认证。
　　
　　如果是使用 ~/.rhosts 或 /etc/hosts.equiv 进行认证，客户端使用的端口号必须小于1024。
　　
　　认证的第一步是客户端向服务器发 SSH_CMSG_USER 包声明用户名，服务器检查该用户是否存在，确定是否需要进行认证。如果用户存在，并且不需要认证，服务器回送一个SSH_SMSG_SUCCESS 包，认证完成。否则，服务器会送一个 SSH_SMSG_FAILURE 包，表示或是用户不存在，或是需要进行认证。注意，如果用户不存在，服务器仍然保持读取从客户端发来的任何包。除了对类型为 SSH_MSG_DISCONNECT、SSH_MSG_IGNORE 以及 SSH_MSG_DEBUG 的包外，对任何类型的包都以 SSH_SMSG_FAILURE 包。用这种方式，客户端无法确定用户究竟是否存在。
　　
　　如果用户存在但需要进行认证，进入认证的第二步。客户端接到服务器发来的 SSH_SMSG_FAILURE 包后，不停地向服务器发包申请用各种不同的方法进行认证，直到时限已到服务器关闭连接为止。时限一般设定为 5 分钟。对任何一个申请，如果服务器接受，就以 SSH_SMSG_SUCCESS 包回应；如果不接受，或者是无法识别，则以 SSH_SMSG_FAILURE 包回应。
　　
　　第四阶段:
　　
　　认证完成后，客户端向服务器提交会话请求。服务器则进行等待，处理客户端的请求。在这个阶段，无论什么请求只要成功处理了，服务器都向客户端回应 SSH_SMSG_SUCCESS包；否则回应 SSH_SMSG_FAILURE 包，这表示或者是服务器处理请求失败，或者是不能识别请求。会话请求分为这样几类：申请对数据传送进行压缩、申请伪终端、启动 X11、TCP/IP 端口转发、启动认证代理、运行 shell、执行命令。到此为止，前面所有的报文都要求 IP 的服务类型(TOS)使用选项 IPTOS_THROUGHPUT。
　　
　　第五阶段:
　　
　　会话申请成功后，连接进入交互会话模式。在这个模式下，数据在两个方向上双向传送。此时，要求 IP 的服务类型(TOS)使用 IPTOS_LOWDELAY 选项。当服务器告知客户端自己的退出状态时，交互会话模式结束。
　　
　　（注意：进入交互会话模式后，加密被关闭。在客户端向服务器发送新的会话密钥后，加密重新开始。用什么方法加密由客户端决定。）
　　
　　第二部分：数据包格式和加密类型
　　
　　二进制数据包协议：
　　
　　包 = 包长域(4字节:u_int32_t) + 填充垫(1-7字节)
　　+ 包类型域(1字节：u_char) + 数据域
　　+ 校验和域(4字节)
　　加密部分 = 填充垫 + 包类型 + 数据 + 校验和
　　包长 = 1(包类型) + 数据字节长度 + 4(校验和)
　　
　　数据包压缩：
　　
　　如果支持压缩，包类型域和数据域用 gzip 压缩算法进行压缩。压缩时在两个数据传送方向的任何一个上，包的压缩部分(类型域+数据域)被构造得象是它连在一起，形成一个连续的数据流。在两个数据传送方向上，压缩是独立进行的。
　　
　　数据包加密:
　　
　　现时支持的数据加密方法有这样几种：
　　
　　SSH_CIPHER_NONE 0 不进行加密
　　SSH_CIPHER_IDEA 1 IDEA 加密法（CFB模式）
　　SSH_CIPHER_DES 2 DES 加密法（CBC模式）
　　SSH_CIPHER_3DES 3 3DES 加密法（CBC模式）
　　SSH_CIPHER_ARCFOUR 5 Arcfour加密法)
　　SSH_CIPHER_BLOWFISH 6 Blowfish 加密法
　　
　　协议的所有具体实现都要求支持3DES。
　　
　　DES 加密：
　　
　　从会话密钥中取前8个字节，每个字只用高7位，忽略最低位，这样构成56位的密钥供加密使用。加密时使用CBC 模式，初使矢量被初始化为全零。
　　
　　3DES 加密：
　　
　　3DES 是 DES 的变体，它三次独立地使用 CBC 模式的DES 加密法，每一次的初始矢量都是独立的。第一次用DES 加密法对数据进行加密；第二次对第一次加密的结果用 DES 加密法进行解密；第三次再对第二次解密的
　　结用 DES 加密法进行加密。注意：第二次解密的结果并不就是被加密的数据，因为三次使用的密钥和初始矢量都是分别不同的。与上面的 DES 加密采用的方法类似，第一次从会话密钥中取起始的前8个字节生成加密密钥，第二次取下一个紧跟着的8个字节，第三次取再下一个紧跟着的8个字节。三次使用的初始矢量都初始化为零。
　　
　　IDEA 加密：
　　
　　加密密钥取自会话密钥的前16个字节，使用 CFB 模式。初始矢量初始化为全零。
　　
　　RC4 加密：
　　
　　会话密钥的前16个字节被服务器用作加密密钥，紧接着的下一个16字节被客户端用作加密密钥。结果是两个数据流方向上有两个独立的129位密钥。这种加密算法非常快。
　　
　　第二部分：密钥的交换和加密的启动
　　
　　在服务器端有一个主机密钥文件，它的内容构成是这样的：
　　
　　1. 私钥文件格式版本字符串；
　　2. 加密类型（1 个字节）；
　　3. 保留字（4 个字节）；
　　4. 4 个字节的无符号整数；
　　5. mp 型整数；
　　6. mp 型整数；
　　7. 注解字符串的长度；
　　8. 注解字符串；
　　9. 校验字（4 个字节）；
　　10. mp 型整数；
　　11. mp 型整数；
　　12. mp 型整数；
　　13. mp 型整数；
　　
　　其中 4、5、6 三个字段构成主机密钥的公钥部分；10、11、12、13 四个字段构成主机密钥的私钥部分。9、10、11、12、13 五个字段用字段 2 的加密类型标记的加密方法进行了加密。4 个字节的校验字交叉相等，即第一个字节与第三个字节相等，第二个字节与第四个字节相等。在服务器读取这个文件时进行这种交叉相等检查，如果不满足这个条件，则报错退出。
　　
　　服务器程序运行的第一步，就是按照上面的字段划分读取主机密钥文件。随后生成一个随机数，再调用函数
　　
　　void rsa_generate_key
　　(
　　RSAPrivateKey *prv,
　　RSAPublicKey *pub,
　　RandomState *state,
　　unsigned int bits
　　)；
　　
　　生成服务密钥，服务密钥也由公钥和私钥两部分组成。上面的这个函数第一个指针参数指向服务密钥的私钥部分，第二个指向公钥部分。然后把主机密钥的公钥部分和服务密钥的公钥部分发送给客户端。在等到客户端回应的包后，服务器用自己的主机密钥的私钥部分和服务密钥的私钥部分解密得到客户端发来的 32 字节随机字串。然后计算自己的会话号，并用会话号的前 16字节 xor 客户端发来的 32 字节随机字串的前 16 字节，把它作为自己的会话密钥。注意，服务器把8个字节的 cookie、主机密钥的公钥部分、和服务密钥的公钥部分作为参数来计算自己的会话号。
　　
　　再来看客户端。客户端启动后的第一步骤也是读取主机密钥。然后等待服务器主机密钥、服务密钥、和 8个字节的cookie。注意，服务器发送来的只是主机密钥和服务密钥的公钥部分。接到包后，客户端立即把从服务器端收到cookie、主机密钥、和服务密钥作为参数计算出会话号。从上面可以看出，服务器和客户端各自计算出的会话号实际是一样的。
　　
　　随后，客户端检查用户主机列表和系统主机列表，查看从服务器收到的主机密钥是否在列表中。如果不在列表


／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／／
需求：公司通过一托管服务器(www.example.com)向外发布信息，要求使用openssh来提高从公司本地管理工作站（admin.example.com）远程管理该服务器时的安全性。
　　
　　一、 运行环境：
　　
　　1．操作系统：
　　
　　本地管理工作站和远程服务器均使用RedHat7.0。
　　
　　2．openssh版本：
　　
　　采用RedHat7.0自带的openssh，主要有三个rpm包：
　　openssh-2.1.p4-1.rpm：包含openssh的核心文件
　　openssh-server-2.1.1p4-1.rpm：包含openssh的服务器程序
　　openssh-clients-2.1.1p4-1.rpm：包含openssh的客户端程序
　　
　　二、 安装openssh
　　
　　1．在本地管理工作站上安装openssh客户端
　　
　　首先查看是否已经安装了openssh
　　#rpm –qa |grep openssh
　　如果提示：
　　openssh-2.1.p4-1
　　openssh-clients-2.1.1p4-1
　　则说明已经安装了openssh的客户端软件，如果没有提示，则插入Redhat7.0的第一张安装盘，并执行：
　　#mount /mnt/cdrom
　　#cd /mnt/cdrom/RedHat/RPMS
　　#rpm –ivh openssh-2.1.p4-1.rpm
　　#rpm –ivh openssh-clients-2.1.1p4-1.rpm
　　
　　2．在远程服务器上安装openssh
　　方法同上，只不过服务器上需要安装的是以下两个包
　　openssh-2.1.p4-1
　　openssh-server-2.1.1p4-1
　　提示：可以通过ftp将openssh的rpm包下载到远程服务器上。
　　
　　三、 使用基于传统口令认证的openssh
　　
　　说明：缺省情况下，ssh仍然使用传统的口令验证，在使用这种认证方式时，我们不需
　　要进行任何配置。你可以使用自己帐号和口令登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。
　　使用以下语法登录服务器：
　　ssh –l [在远程服务器上的帐号] [远程服务器的主机名或ip地址]
　　假设我们在远程服务器上有管理员帐号admin，我们执行以下命令：
　　ssh –l admin www.example.com
　　一切正常的话，你可以看到以下信息：
　　The authenticity of host ‘www.example.com’ can't be established.
　　Key fingerprint is 1024 5f:a0:0b:65:d3:82:df:ab:44:62:6d:98:9c:fe:e9:52.
　　Are you sure you want to continue connecting (yes/no)?
　　因为你是第一次登录服务器，所以openssh不知道你的主机信息，以后再登录时，系统就不会再提示这样的信息了。输入yes并回车后系统会提示你输入密码，输入密码后，你就可以象平常使用telnet那样来使用ssh了。
　　
　　四、 配置并使用基于密匙认证的openssh
　　
　　说明：密匙认证需要依靠密匙，首先创建一对密匙（包括公匙和密匙,并且用公匙加密的数据只能用密匙解密），并把公匙放到需要远程服务器上。这样当登录远程服务器时，客户端软件就会向服务器发出请求，请求用你的密匙进行认证。服务器收到请求之后，先在你在该服务器的宿主目录下寻找你的公匙，然后检查该公匙是否是合法，如果合法就用公匙加密一随机数（即所谓的challenge）并发送给客户端软件。客户端软件收到“challenge”之后就用私匙解密再把它发送给服务器。因为用公匙加密的数据只能用密匙解密，服务器经过比较就可以知道该客户连接的合法性。
　　
　　下面我们就一步步的来配置基于密匙认证的oppenssh（基于ssh2）：
　　假定：我们在远程服务器和本地管理工作站上均有一个管理员帐号：admin
　　
　　1．配置远程服务器：
　　
　　安装完成后一般说来我们就没有必要修改服务端的配置文件了，但是如果你想要获得最
　　大化的安全性，可以修改www.example.com上/etc/ssh/sshd_conf中的
　　PasswordAuthentication yes 改为
　　PasswordAuthentication no
　　也即只能使用密匙认证的openssh，禁止使用口令认证。
　　
　　2． 配置客户端：
　　
　　对客户端配置文件/etc/ssh/ssh_conf不需要进行任何更改。
　　
　　3．在客户端生成密匙：
　　
　　先在管理工作站上用ssh-keygen生成密匙，因为我们使用的是ssh2，所以要加一个-d
　　的参数。用admin登录管理工作站，然后执行：
　　$ssh-keygen –d
　　系统将显示：
　　Generating DSA parameter and key.
　　Enter file in which to save the key (/home/admin/.ssh/id_dsa):
　　叫你输入密匙文件的保存路径，我们回车使用缺省路径。
　　如果还没有/home/admin/.ssh目录，系统将显示：
　　Created directory ‘/home/admin/.ssh’.
　　Enter passphrase (empty for no passphrase):
　　Enter same passphrase:
　　Your identification has been saved in /home/admin/.ssh/id_dsa.
　　Your public key has been saved in /home/admin/.ssh/id_dsa.pub.
　　The key fingerprint is:
　　D8:20:0f:01:5d:8f:6f:de:b9:d5:ce:28:d8:ca:45:59 admin@admin.example.com
　　这里的密码是对生成的私匙文件（/home/admin/.ssh/id_dsa）的保护口令。
　　公匙文件是/home/admin/.ssh/id_dsa.pub
　　
　　4． 发布公匙：
　　
　　通过ftp将公匙文件/home/admin/.ssh/id_dsa.pub复制到远程服务器上的以下目录：
　　/home/admin/.ssh，如果.ssh目录不存在，可以用mkdir命令先建立。
　　
　　然后，将id_dsa.pub重命名为authorized_keys2:
　　mv id_dsa.pub authorized_keys2
　　
　　再用chmod修改authorized_keys2的属性：
　　chmod 644 authorized_keys2
　　注意，如果authorized_keys2文件的权限不正确，会导致ssh连接失败。
　　
　　5． 启动sshd服务：
　　
　　在www.example.com上使用root权限执行：
　　/etc/rc.d/init.d/sshd start
　　
　　6． 连接远程服务器：
　　用admin帐号登录admin.example.com并使用ssh连接www.example.com：
　　ssh –l admin www.example.com
　　Enter passphrase for DSA key ‘/home/admin/.ssh/id_dsa’:
　　输入原先设置的密码后，就可以登录到www.example.com了。







建立主机A、B、C上同一用户之间的SSH相互信任关系：

1，在主机A用户hcwang（e.g.）上生成密钥对。
   $ ssh-keygen -t rsa
2，进入.ssh目录
   $ mv id_rsa.pub authorized_keys  // (更改为系统默认的公钥文件名)
3，将公钥id_rsa.pub，传输到主机目标主机B，C
   $ scp id_rsa.pub B:$HOME/.ssh
   $ cat id_rsa.pub >> authorized_keys //如果没有authorized_keys，则执行 mv id_rsa.pub authorized_keys
   同样对主机C
   $ scp id_rsa.pub C:$HOME/.ssh
   $ cat id_rsa.pub >> authorized_keys

   到此，可以从主机A直接 SSH 到主机B，C，无需密码。如果想从主机B或者C，SSH 到主机A，或者主机BC之间互相SSH，则需要密码。解决办法如下：

4，将主机A的私钥，id_rsa 拷到 主机B和C的 $HOME/.ssh 目录下
   $ scp id_rsa B:$HOME/.ssh         ??????
   $ scp id_rsa C:$HOME/.ssh

~OK 
