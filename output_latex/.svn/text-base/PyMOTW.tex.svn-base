% Generated by Sphinx.
\documentclass[a4paper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}


\title{PyMOTW Document}
\date{January 04, 2009}
\release{1.0}
\author{vbarter & liz}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex
\makemodindex
\newcommand\at{@}
\newcommand\lb{[}
\newcommand\rb{]}
\newcommand\PYGaz[1]{\textcolor[rgb]{0.00,0.63,0.00}{#1}}
\newcommand\PYGax[1]{\textcolor[rgb]{0.84,0.33,0.22}{\textbf{#1}}}
\newcommand\PYGay[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGar[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGas[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textit{#1}}}
\newcommand\PYGap[1]{\textcolor[rgb]{0.78,0.36,0.04}{#1}}
\newcommand\PYGaq[1]{\textcolor[rgb]{0.38,0.68,0.84}{#1}}
\newcommand\PYGav[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaw[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGat[1]{\textcolor[rgb]{0.32,0.47,0.09}{#1}}
\newcommand\PYGau[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaj[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGak[1]{\textcolor[rgb]{0.14,0.33,0.53}{#1}}
\newcommand\PYGah[1]{\textcolor[rgb]{0.00,0.13,0.44}{\textbf{#1}}}
\newcommand\PYGai[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGan[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGao[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textbf{#1}}}
\newcommand\PYGal[1]{\colorbox[rgb]{1.00,0.94,0.94}{\textcolor[rgb]{0.25,0.50,0.56}{#1}}}
\newcommand\PYGam[1]{\textbf{#1}}
\newcommand\PYGab[1]{\textit{#1}}
\newcommand\PYGac[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaa[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand\PYGaf[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGag[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGad[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGae[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaZ[1]{\textcolor[rgb]{0.02,0.16,0.45}{\textbf{#1}}}
\newcommand\PYGbf[1]{\textcolor[rgb]{0.44,0.63,0.82}{\textit{#1}}}
\newcommand\PYGaX[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaY[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbc[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGbb[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGba[1]{\textcolor[rgb]{0.00,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaR[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaS[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaP[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaQ[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaV[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaW[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaT[1]{\textcolor[rgb]{0.50,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaU[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaJ[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaK[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand\PYGaH[1]{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{#1}}
\newcommand\PYGaI[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand\PYGaN[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaO[1]{\textcolor[rgb]{0.78,0.36,0.04}{\textbf{#1}}}
\newcommand\PYGaL[1]{\textcolor[rgb]{0.73,0.73,0.73}{#1}}
\newcommand\PYGaM[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaB[1]{\textcolor[rgb]{0.00,0.25,0.82}{#1}}
\newcommand\PYGaC[1]{\textcolor[rgb]{0.33,0.33,0.33}{\textbf{#1}}}
\newcommand\PYGaA[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaF[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand\PYGaG[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaD[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaE[1]{\textcolor[rgb]{0.63,0.00,0.00}{#1}}
\newcommand\PYGbg[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGbe[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand\PYGbd[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGZat{@}
\newcommand\PYGZlb{[}
\newcommand\PYGZrb{]}

\begin{document}

\maketitle
\tableofcontents



\resetcurrentobjects


\chapter{介绍}

\resetcurrentobjects


\chapter{PyMOTW: ConfigParser}
\begin{itemize}
\item {} 
模块： ConfigParser

\item {} 
目的： 读取/写入配置文件,类似于Windows的INI文件

\item {} 
python版本： 1.5+

\end{itemize}


\section{描述}

ConfigParser模块可以为你的应用程序创建用户可编辑的配置文件. 这个配置文件由一个个节组成,每个节可以包含配置数据的名字-值对.支持通过使用Python的格式化字符串进行值的插入, 以此来构建那些依赖于其他值的数据值(这对路径或URL来说是尤其方便的).

在工作中,当我们把东西移动到svn和 \href{http://trac.edgewall.org/}{trac} 之前, 我们开发推出了自己的用于进行分布式代码复查的工具. 为了准备好需要复查的代码,一个开发者常常需要写完一个''approach''摘要文件,然后附上被修改后的代码(即和原代码有区别的地方).这个 approach文档支持通过Web页面添加注释, 因此开发者不在我们的主要办公室里也可以复查代码. 但是唯一的麻烦之处是, 发表代码的不同之处让人感到有点痛苦. 想要让部分处理过程变得简单些,我写了一个命令行工具, 运行他可以针对CVS沙盒,自动的寻找出并发表代码的不同之处.

为了能够让这个工具即时更新approach文档中的区别, 需要知道怎样到达存放approach文档的网络服务器. 由于我们开发者不总是在办公室, 从任意给定主机到达服务器的URL可能是通过SSH端口转发过来的. 为了不强迫每个开发者都使用同样的端口转发协议?这个工具应使用一个简单的配置文件来记住这个URL.

一个开发者的配置文件可能会是这个样子:

\begin{Verbatim}[commandchars=@\[\]]
@PYGZlb[]portal@PYGZrb[]
url = http://@%(host)s:@%(port)s/Portal
username = dhellmann
host = localhost
password = SECRET
port = 8080
\end{Verbatim}

portal小节表示approach文件的网址. 一旦代码的区别被发送到这个网址, 我们的工具应该下载这个配置文件,通过ConfigParser模块来访问URL.这可能看起来像这样:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[ConfigParser] @PYGay[import] ConfigParser
@PYGay[import] @PYGaV[os]

filename @PYGbe[=] os@PYGbe[.]path@PYGbe[.]join(os@PYGbe[.]environ@lb[]@PYGad[']@PYGad[HOME]@PYGad[']@rb[], @PYGad[']@PYGad[.approachrc]@PYGad['])

config @PYGbe[=] ConfigParser()
config@PYGbe[.]read(@lb[]filename@rb[])

url @PYGbe[=] config@PYGbe[.]get(@PYGad[']@PYGad[portal]@PYGad['], @PYGad[']@PYGad[url]@PYGad['])
\end{Verbatim}

上述的例子中, 变量url的值为''\href{http://localhost:8080/Portal}{http://localhost:8080/Portal}``.配置文件中的变量url中包含两个格式化字符串:''\%(host)s'' 和 ``\%(port)s''. 通过 \code{get()} 方法, 自动地将变量host和port的值替换到格式化字符串中.

当然, 这是基于Python2.1的旧代码. 在近来的版本中,ConfigParser模块已经被改进了很多.SafeConfigParser类是a drop?用来取代ConfigParser, 以改善插值处理.

对于这个工具,我只需要字符串选项. ConfigParser支持其他的选项类型:整型, 浮点型和布尔型. 由于可选文件格式不提供直接使用一个值来关联一种类型的方式,所以调用者需要知道何时需要使用一种不同的函数来查询那些其他类型的选项.例如,为了查找一个布尔选项, 使用 \code{getboolean()} 函数而不是 \code{get()} 函数.函数的参数是一样的,但是选项的值在返回之前被转换为一个布尔类型.类似地,还有独立的 \code{getint()} 和 \code{getfloat()} 函数.

ConfigParser类也支持增加和删除小节到指定文件并保存结果.这使得创建一个用于编辑程序的配置的用户界面,或是利用配置文件格式存放简单数据文件成为可能. 例如, 一个应用需要存储小量的类似于数据库格式的数据, 可以利用ConfigParser类,这样一来生成的文件也是人类可读的.

\resetcurrentobjects


\chapter{PyMOTW: Queue}
\begin{itemize}
\item {} 
模块：Queue

\item {} 
目的：提供一个线程安全的FIFO功能。

\item {} 
python版本：1.4+

\end{itemize}


\section{描述}

Queue提供了FIFO功能，一般常用于多线程编程，它可以在生产者和消费者线程中安全的传递消息或者其他数据。调用者会自动创建锁，当使用Queue对象，你可以根据需求创建多个线程。一个Queue的大小(元素的个数)受可用内存的限制。

本文假设你已经了解基本的Queue特点，如果你还不清楚，可以阅读参考后继续后面内容:
\begin{itemize}
\item {} 
\href{http://en.wikipedia.org/wiki/Queue\_\%28data\_structure}{Queue data structures}

\item {} 
\href{http://en.wikipedia.org/wiki/FIFO}{FIFO}

\end{itemize}


\section{示例}

举例说明如何在多线程中使用Queue对象，我们创建一个简单的 \href{http://en.wikipedia.org/wiki/Podcasting}{podcasting} 客户端，这个客户端读取一个或者多个RSS feeds，依次将需下载的内容置于队列中，然后采用多线程模式同时处理多个下载。这比较简单，也许没有多大实用价值，但这个框架代码很好的说明了如何来利用Queue模块。

开始，我们加载一些有用的模块：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[Queue] @PYGay[import] Queue

@PYGay[from] @PYGaV[threading] @PYGay[import] Thread
@PYGay[import] @PYGaV[time]

@PYGay[import] @PYGaV[feedparser]
\end{Verbatim}

首先，需要创建一些运行参数，通常这些来自用户输入(可以任何东西，比如参数，数据库)，在我们的例子中，我们硬编码几个值。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Set up some global variables]
num@_fetch@_threads @PYGbe[=] @PYGaw[2]
enclosure@_queue @PYGbe[=] Queue()

@PYGaD[@# A real app wouldn't use hard-coded data...]
feed@_urls @PYGbe[=] @lb[] @PYGad[']@PYGad[http://www.castsampler.com/cast/feed/rss/guest]@PYGad['],@rb[]
\end{Verbatim}

接下来，我们需要在工作线程中定义相应函数来处理下载。再次，这里为了便于说明模拟下载，实际下载可以参考 \href{http://docs.python.org/lib/module-urllib.html}{urllib} 模块(这再以后会介绍)。在这个示例中，我们只根据线程id，使其sleep一段时间。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[downloadEnclosures](i, q):
  @PYGas["""This is the worker thread function.]
@PYGas[  It processes items in the queue one after another.]
@PYGas[  These daemon threads go into an infinite loop,]
@PYGas[  and only exit when the main thread ends.]
@PYGas[  """]
  @PYGay[while] @PYGaA[True]:
    @PYGay[print] @PYGad[']@PYGbf[@%s]@PYGad[: Looking for the next enclosure]@PYGad['] @PYGbe[@%] i
    url @PYGbe[=] q@PYGbe[.]get()
    @PYGay[print] @PYGad[']@PYGbf[@%s]@PYGad[: Downloading:]@PYGad['] @PYGbe[@%] i, url
    time@PYGbe[.]sleep(i @PYGbe[+] @PYGaw[2]) @PYGaD[@# instead of really downloading the URL, we just pretend]

    q@PYGbe[.]task@_done()
\end{Verbatim}

一旦定义好目标函数，我们就可以启动工作线程。注意，函数downloadEnclosures()在“url = q.get()”会阻塞，直到队列有东西返回，因此，当队列中有东西时，启动线程总是安全的。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Set up some threads to fetch the enclosures]
@PYGay[for] i @PYGan[in] @PYGaX[range](num@_fetch@_threads):
  worker @PYGbe[=] Thread(target@PYGbe[=]downloadEnclosures, args@PYGbe[=](i, enclosure@_queue,))
  worker@PYGbe[.]setDaemon(@PYGaA[True])
  worker@PYGbe[.]start()
\end{Verbatim}

现在，我们开始检索feed的内容（使用Mark Pilgrim的 \href{http://www.feedparser.org/}{feedparser} 模块）和一个url集合。当第一个url添加到队列后，一个工作线程即可选择它并启动下载。循环将继续运行并添加相应的feed，直到全部加完，工作线程将轮流取出url去下载它们。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Download the feed(s) and put the enclosure URLs into the queue.]
@PYGay[for] url @PYGan[in] feed@_urls:
  response @PYGbe[=] feedparser@PYGbe[.]parse(url, agent@PYGbe[=]@PYGad[']@PYGad[fetch@_podcasts.py]@PYGad['])
  @PYGay[for] entry @PYGan[in] response@lb[]@PYGad[']@PYGad[entries]@PYGad[']@rb[]:
    @PYGay[for] enclosure @PYGan[in] entry@PYGbe[.]get(@PYGad[']@PYGad[enclosures]@PYGad['], @lb[]@rb[]):
      @PYGay[print] @PYGad[']@PYGad[Queuing:]@PYGad['], enclosure@lb[]@PYGad[']@PYGad[url]@PYGad[']@rb[]
      enclosure@_queue@PYGbe[.]put(enclosure@lb[]@PYGad[']@PYGad[url]@PYGad[']@rb[])
\end{Verbatim}

剩下就可以等待队列为空。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Now wait for the queue to be empty, indicating that we have]
@PYGaD[@# processed all of the downloads.]
@PYGay[print] @PYGad[']@PYGad[*** Main thread waiting]@PYGad[']
enclosure@_queue@PYGbe[.]join()
@PYGay[print] @PYGad[']@PYGad[*** Done]@PYGad[']
\end{Verbatim}

下载如下 \href{http://www.doughellmann.com/PyMOTW/fetch\_podcasts.py}{示例代码} ，运行即可看到如下输出：

\begin{Verbatim}[commandchars=@\[\]]
0: Looking for the next enclosure
1: Looking for the next enclosure
Queuing: http://http.earthcache.net/htc-01.media.globix.net/COMP009996MOD1/Danny@_Meyer.mp3
Queuing: http://feeds.feedburner.com/@textasciitilde[]r/drmoldawer/@textasciitilde[]5/104445110/moldawerinthemorning@_show34@_032607.mp3
Queuing: http://www.podtrac.com/pts/redirect.mp3/twit.cachefly.net/MBW-036.mp3
Queuing: http://media1.podtech.net/media/2007/04/PID@_010848/Podtech@_calacaniscast22@_ipod.mp4
Queuing: http://media1.podtech.net/media/2007/03/PID@_010592/Podtech@_SXSW@_KentBrewster@_ipod.mp4
Queuing: http://media1.podtech.net/media/2007/02/PID@_010171/Podtech@_IDM@_ChrisOBrien2.mp3
Queuing: http://feeds.feedburner.com/@textasciitilde[]r/drmoldawer/@textasciitilde[]5/96188661/moldawerinthemorning@_show30@_022607.mp3
*** Main thread waiting
0: Downloading: http://http.earthcache.net/htc-01.media.globix.net/COMP009996MOD1/Danny@_Meyer.mp3
1: Downloading: http://feeds.feedburner.com/@textasciitilde[]r/drmoldawer/@textasciitilde[]5/104445110/moldawerinthemorning@_show34@_032607.mp3
0: Looking for the next enclosure
0: Downloading: http://www.podtrac.com/pts/redirect.mp3/twit.cachefly.net/MBW-036.mp3
1: Looking for the next enclosure
1: Downloading: http://media1.podtech.net/media/2007/04/PID@_010848/Podtech@_calacaniscast22@_ipod.mp4
0: Looking for the next enclosure
0: Downloading: http://media1.podtech.net/media/2007/03/PID@_010592/Podtech@_SXSW@_KentBrewster@_ipod.mp4
0: Looking for the next enclosure
0: Downloading: http://media1.podtech.net/media/2007/02/PID@_010171/Podtech@_IDM@_ChrisOBrien2.mp3
1: Downloading: http://feeds.feedburner.com/@textasciitilde[]r/drmoldawer/@textasciitilde[]5/96188661/moldawerinthemorning@_show30@_022607.mp3
1: Looking for the next enclosure
*** Done
\end{Verbatim}

\resetcurrentobjects


\chapter{PyMOTW: StringIO and cStringIO}
\begin{itemize}
\item {} 
模块：StringIO 和 cStringIO

\item {} 
目的: 类似于file操作的文本缓冲区API

\item {} 
python版本：StringIO: 1.4+, cStringIO: 1.5+

\end{itemize}


\section{描述}

类StringIO提供了一个在内存中方便处理文本的类文件(读, 写等操作)API. 他有两个独立的实现, 一个是用c实现的cStringIP模块,速度较快, 另一个是StringIO模块,他用python实现的以增强其可移植性. 使用cStringIO来处理大字符串可以提高运行性能,优于其他字符串串联技术.


\section{例子}

这里是一个好的,标准的,简单的.使用StringIO缓冲的例子:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@#!/usr/bin/env python]

@PYGas["""]
@PYGas[Simple examples with StringIO module]
@PYGas["""]

@PYGaD[@# Find the best implementation available on this platform]

@PYGay[try]:
    @PYGay[from] @PYGaV[cStringIO] @PYGay[import] StringIO
@PYGay[except]:
    @PYGay[from] @PYGaV[StringIO] @PYGay[import] StringIO

@PYGaD[@# Writing to a buffer]
output @PYGbe[=] StringIO()
output@PYGbe[.]write(@PYGad[']@PYGad[This goes into the buffer. ]@PYGad['])

@PYGay[print] @PYGbe[@textgreater[]@textgreater[]]output, @PYGad[']@PYGad[And so does this.]@PYGad[']
@PYGaD[@# Retrieve the value written]
@PYGay[print] output@PYGbe[.]getvalue()

output@PYGbe[.]close() @PYGaD[@# discard buffer memory]

@PYGaD[@# Initialize a read buffer]
@PYGaX[input] @PYGbe[=] StringIO(@PYGad[']@PYGad[Inital value for read buffer]@PYGad['])

@PYGaD[@# Read from the buffer]
@PYGay[print] @PYGaX[input]@PYGbe[.]read()
\end{Verbatim}

这个例子中使用了 \code{read()} ,但当然,函数 \code{readline()} 和 \code{readlines()} 也都是可用的.类StringIO提供 \code{seek()} 函数,因此在读取数据时可以任意跳到某个点上, 这也当你使用某些前看解析算法可以回头读取.

现实世界中,StringIO的应用包括一个网络应用程序栈,栈的各个部分都可以增加文本到响应response对象中,或者测试由程序某段输出(典型是写入到文件)的数据.

我们想在创建的工程应用中包括一个shell脚本接口,他是以多个命令行程序的形式.这些程序中的某些是负责从数据库中取数据,然后将这些数据转储到控制台(可以是现实给用户,也可以是文本中,这样就可以作为另一个命令的输入). 这些命令他们共享了一组格式化插件以便产生一个对象的多种文本表示(XML, bash语法, 人可读的,等等).

因为格式化可以将输出数据标准化后写到标准输出,如果没有StringIO模块,所得的测试结果可能会有些奇怪. 而使用了StringIO来拦截格式化的输出,这样以便我们用一个简单的方式来收集内存中的输出数据,来对预期的结果做比较.


\section{参考}
\begin{itemize}
\item {} 
\href{http://effbot.org/librarybook/stringio.htm}{The StringIO module ::: www.effbot.org}

\item {} 
\href{http://www.skymind.com/\%7Eocrow/python\_string/}{Efficient String Concatenation in Python}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: textwrap}
\begin{itemize}
\item {} 
模块：textwrap

\item {} 
目的: 通过调整段落中的换行符位置来格式化文本

\item {} 
python版本：2.5

\end{itemize}


\section{描述}

textwrap模块可以用来格式化文本，使其在某些场合输出更美观。他提供了一些类似于在很多文本编辑器中都有的段落包装或填充特性的程序功能.


\section{例子}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[textwrap]

@PYGaD[@# Provide some sample text]
sample@_text @PYGbe[=] @PYGad[''']

@PYGad[ The textwrap module can be used to format text for output in situations]
@PYGad[ where pretty-printing is desired.  It offers programmatic functionality similar]
@PYGad[ to the paragraph wrapping or filling features found in many text editors.]

@PYGad[''']
\end{Verbatim}

fill()将文本作为输入，格式化文本作为输出。让我们看下面是如何对样本文本进行格式化的

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGad[No dedent:]@PYGao[\n]@PYGad[']
@PYGay[print] textwrap@PYGbe[.]fill(sample@_text)
\end{Verbatim}

结果比我们想要的结果要少：

\begin{Verbatim}[commandchars=@\[\]]
No dedent:

        The textwrap module can be used to format text for output in
        situations         where pretty-printing is desired.  It offers
        programmatic functionality similar         to the paragraph wrapping
        or filling features found in many text editors.
\end{Verbatim}

\begin{notice}{note}{Note:}
注意嵌入的tab符号和多余的空格被混合在输出文本中。这个看起来是很粗糙的。当然，我们可以做的更好。我们想在样本文本中的每一行的开始处删掉所有普通空格前缀。这个允许我们在去除代码本身的格式化时直接从Python代码中使用文档字符串或者嵌入式多行字符串。下面的样本字符串引入了一个人工的缩进层次以便更好的说明这个特征。
\end{notice}

删除样本行中的普通空格前缀

\begin{Verbatim}[commandchars=@\[\]]
dedented@_text @PYGbe[=] textwrap@PYGbe[.]dedent(sample@_text)@PYGbe[.]strip()
@PYGay[print] @PYGad[']@PYGad[Dedented:]@PYGao[\n]@PYGad[']
@PYGay[print] dedented@_text
\end{Verbatim}

结果看上去似乎好点：

\begin{Verbatim}[commandchars=@\[\]]
Dedented:

The textwrap module can be used to format text for output in situations
where pretty-printing is desired.  It offers programmatic functionality similar
to the paragraph wrapping or filling features found in many text editors.
\end{Verbatim}

由于“dedent”是“indent”的相反，结果就是将每行开始的普通空白符删除了。如果某行已经比另一行多了个缩进层次，那么对应的空格不会被去掉。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaO[@textgreater[]@textgreater[]@textgreater[] ]a@PYGbe[=]@PYGad["""]
@PYGaO[... ]@PYGad[    one tab]
@PYGaO[... ]@PYGad[            two tab]
@PYGaO[... ]@PYGad[    one tab]
@PYGaO[... ]@PYGad["""]
@PYGaO[@textgreater[]@textgreater[]@textgreater[] ]@PYGay[import] @PYGaV[textwrap]
@PYGaO[@textgreater[]@textgreater[]@textgreater[] ]dedented@_text @PYGbe[=] textwrap@PYGbe[.]dedent(a)@PYGbe[.]strip()
@PYGaO[@textgreater[]@textgreater[]@textgreater[] ]@PYGay[print] dedented@_text
@PYGaa[one tab]
@PYGaa[    two tab]
@PYGaa[one tab]
@PYGaO[@textgreater[]@textgreater[]@textgreater[] ]@PYGay[print] a
@PYGaa[    one tab]
@PYGaa[        two tab]
@PYGaa[    one tab]
@PYGaa[@textgreater[]@textgreater[]@textgreater[]]
\end{Verbatim}

接下来，让我们看下如果我们传递非缩进格式的文本给fill()，并使用一些不同的宽度值，会发生什么。

使用不同行宽值进行格式化输出:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Format the output with a few different max line width values]
@PYGay[for] width @PYGan[in] @lb[] @PYGaw[20], @PYGaw[60], @PYGaw[80] @rb[]:
    @PYGay[print]
    @PYGay[print] @PYGad[']@PYGbf[@%d]@PYGad[ Columns:]@PYGao[\n]@PYGad['] @PYGbe[@%] width
    @PYGay[print] textwrap@PYGbe[.]fill(dedented@_text, width@PYGbe[=]width)
\end{Verbatim}

在指定不同宽度时会有以下不同的输出结果：

20 Columns:

\begin{Verbatim}[commandchars=@\[\]]
The textwrap module
can be used to
format text for
output in situations
where pretty-
printing is desired.
It offers
programmatic
functionality
similar to the
paragraph wrapping
or filling features
found in many text
editors.
\end{Verbatim}

60 Columns:

\begin{Verbatim}[commandchars=@\[\]]
The textwrap module can be used to format text for output in
situations where pretty-printing is desired.  It offers
programmatic functionality similar to the paragraph wrapping
or filling features found in many text editors.
\end{Verbatim}

80 Columns:

\begin{Verbatim}[commandchars=@\[\]]
The textwrap module can be used to format text for output in situations where
pretty-printing is desired.  It offers programmatic functionality similar to the
paragraph wrapping or filling features found in many text editors.
\end{Verbatim}

除了制定输出中的宽度，你可以控制首行缩进，他独立于接下来的行。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Demonstrate how to produce a hanging indent]
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[Hanging indent:]@PYGao[\n]@PYGad[']
@PYGay[print] textwrap@PYGbe[.]fill(dedented@_text, initial@_indent@PYGbe[=]@PYGad[']@PYGad['], subsequent@_indent@PYGbe[=]@PYGad[']@PYGad[    ]@PYGad['])
\end{Verbatim}

这个看起来很容易就能实现文本的悬挂缩进，也就是首行要比后继行有少的缩进。

\begin{Verbatim}[commandchars=@\[\]]
Hanging indent:

The textwrap module can be used to format text for output in
   situations where pretty-printing is desired.  It offers
   programmatic functionality similar to the paragraph wrapping or
   filling features found in many text editors.
\end{Verbatim}

缩进值也可以是非空格字符，因此，可以用*作为前缀产生bullet点，等等。在我转换老的zwiki内容以便将其导入到trac中是很灵活的。我使用Zope中的StructuredText包来解析zwiki数据，然后创建一个格式化器产生一个trac的wiki标记作为输出。使用textwrap就可以格式化输出页，因此转换后就几乎不需要再进行手工操作整个转换过程几乎没有手工进行。


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.doughellmann.com/PyMOTW/textwrap\_example.py}{textwrap\_example.py}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: linecache}
\begin{itemize}
\item {} 
模块： linecache

\item {} 
目的： 从文件或者导入模块中检索文本行，对结果采用缓冲来提高读文件的效率。

\item {} 
python版本： 1.4+

\end{itemize}


\section{描述}

python标准库处理python源文件中linecache模块被广泛的使用。缓冲的实现是读取文件的内容，并解析成行，保存在内存的字典中。API 根据索引返回列表中的请求行。在读取文件和寻找需要的行信息上可以节省一定时间。这对于从同一个文件中查询多行内容是非常有用的，比如为一个error report产生trackback。


\section{示例}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[linecache]
@PYGay[import] @PYGaV[os]
@PYGay[import] @PYGaV[tempfile]
\end{Verbatim}

我们使用Lorem Ipsum generator产生的文本作为输入样例：

\begin{Verbatim}[commandchars=@\[\]]
lorem @PYGbe[=] @PYGad[''']@PYGad[Lorem ipsum dolor sit amet, consectetuer adipiscing elit.]
@PYGad[Vivamus eget elit. In posuere mi non risus. Mauris id quam posuere]

@PYGad[lectus sollicitudin varius. Praesent at mi. Nunc eu velit. Sed augue]
@PYGad[massa, fermentum id, nonummy a, nonummy sit amet, ligula. Curabitur]
@PYGad[eros pede, egestas at, ultricies ac, pellentesque eu, tellus.]

@PYGad[Sed sed odio sed mi luctus mollis. Integer et nulla ac augue convallis]
@PYGad[accumsan. Ut felis. Donec lectus sapien, elementum nec, condimentum ac,]
@PYGad[interdum non, tellus. Aenean viverra, mauris vehicula semper porttitor,]
@PYGad[ipsum odio consectetuer lorem, ac imperdiet eros odio a sapien. Nulla]
@PYGad[mauris tellus, aliquam non, egestas a, nonummy et, erat. Vivamus]

@PYGad[sagittis porttitor eros.]@PYGad[''']

@PYGaD[@# Create a temporary text file with some text in it]
fd, temp@_file@_name @PYGbe[=] tempfile@PYGbe[.]mkstemp()

os@PYGbe[.]close(fd)
f @PYGbe[=] @PYGaX[open](temp@_file@_name, @PYGad[']@PYGad[wt]@PYGad['])

@PYGay[try]:
    f@PYGbe[.]write(lorem)
@PYGay[finally]:
    f@PYGbe[.]close()
\end{Verbatim}

现在我们有了一个可用的临时文件，让我们更深入一步。从文件中读取的第5行是单一行。注意，在linecache中的行号是从1开始的。但是我们自己对字符串进行分割，那么索引号是从0开始。我们还需要从缓冲中返回的值进行过滤去除换行符。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Pick out the same line from source and cache.]
@PYGaD[@# (Notice that linecache counts from 1)]
@PYGay[print] @PYGad[']@PYGad[SOURCE: ]@PYGad['], lorem@PYGbe[.]split(@PYGad[']@PYGao[\n]@PYGad['])@lb[]@PYGaw[4]@rb[]
@PYGay[print] @PYGad[']@PYGad[CACHE : ]@PYGad['], linecache@PYGbe[.]getline(temp@_file@_name, @PYGaw[5])@PYGbe[.]rstrip()
\end{Verbatim}

下一步看下，如果我们需要的行为空将会发生什么。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Blank lines include the newline]
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[BLANK : ]@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad['] @PYGbe[@%] linecache@PYGbe[.]getline(temp@_file@_name, @PYGaw[6])
\end{Verbatim}

如果请求的行号超过了文件中有效行号的范围，那么linecache会返回一个空字符串。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# The cache always returns a string, and uses]
@PYGaD[@# an empty string to indicate a line which does]
@PYGaD[@# not exist.]
not@_there @PYGbe[=] linecache@PYGbe[.]getline(temp@_file@_name, @PYGaw[500])
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[NOT THERE: ]@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad[ includes ]@PYGbf[@%d]@PYGad[ characters]@PYGad['] @PYGbe[@%]  (not@_there, @PYGaX[len](not@_there))
\end{Verbatim}

即使这个文件不存在，模块也不会抛出任何异常。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Errors are even hidden if linecache cannot find the file]
no@_such@_file @PYGbe[=] linecache@PYGbe[.]getline(@PYGad[']@PYGad[this@_file@_does@_not@_exist.txt]@PYGad['], @PYGaw[1])
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[NO FILE: ]@PYGad['], no@_such@_file
\end{Verbatim}

虽然linecache模块经常用在输出tracebacks上，另一个重要特性是可以通过指定模块名在sys.path中寻找python模块源码。如果在当前路径中无法找到文件，那么linecache中的缓冲直接搜索sys.path中的模块。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Look for the linecache module, using]
@PYGaD[@# the built in sys.path search.]
module@_line @PYGbe[=] linecache@PYGbe[.]getline(@PYGad[']@PYGad[linecache.py]@PYGad['], @PYGaw[3])
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[MODULE : ]@PYGad['], module@_line
\end{Verbatim}


\section{示例输出}

\begin{Verbatim}[commandchars=@\[\]]
SOURCE:  eros pede, egestas at, ultricies ac, pellentesque eu, tellus.
CACHE :  eros pede, egestas at, ultricies ac, pellentesque eu, tellus.

BLANK : "
"

NOT THERE: "" includes 0 characters

NO FILE:

MODULE :  This is intended to read lines from modules imported -- hence if a filename
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://http://tc-nsop-test2.tc.baidu.com:3129/documents}{PyMOTW}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: bisect}
\begin{itemize}
\item {} 
模块： bisect

\item {} 
目的： 维持一个有序列表，当每次增加一个元素到列表时无需调用sort过程。

\item {} 
python版本： 1.4+

\end{itemize}


\section{描述}

bisect模块实现了一个算法，用于向一个有序列表中插入一个元素。这比重复排序一个列表, 或重构一个很大的有序列表要高效的多.


\section{示例}

使用 \code{bisect.insort()} 的简单示例，插入元素到一个有序列表中。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[bisect]
@PYGay[import] @PYGaV[random]

@PYGaD[@# Use a constant seed to ensure that we see]
@PYGaD[@# the same pseudo-random numbers each time]
@PYGaD[@# we run the loop.]
random@PYGbe[.]seed(@PYGaw[1])
@PYGaD[@# Generate 20 random numbers and]
@PYGaD[@# insert them into a list in sorted]
@PYGaD[@# order.]
l @PYGbe[=] @lb[]@rb[]
@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[1], @PYGaw[20]):
    r @PYGbe[=] random@PYGbe[.]randint(@PYGaw[1], @PYGaw[100])
    position @PYGbe[=] bisect@PYGbe[.]bisect(l, r)
    bisect@PYGbe[.]insort(l, r)
    @PYGay[print] @PYGad[']@PYGbf[@%2d]@PYGad[ ]@PYGbf[@%2d]@PYGad['] @PYGbe[@%] (r, position), l
\end{Verbatim}

上述脚本的输出如下：

\begin{Verbatim}[commandchars=@\[\]]
14 0 @PYGZlb[]14@PYGZrb[]
85 1 @PYGZlb[]14, 85@PYGZrb[]
77 1 @PYGZlb[]14, 77, 85@PYGZrb[]
26 1 @PYGZlb[]14, 26, 77, 85@PYGZrb[]
50 2 @PYGZlb[]14, 26, 50, 77, 85@PYGZrb[]
45 2 @PYGZlb[]14, 26, 45, 50, 77, 85@PYGZrb[]
66 4 @PYGZlb[]14, 26, 45, 50, 66, 77, 85@PYGZrb[]
79 6 @PYGZlb[]14, 26, 45, 50, 66, 77, 79, 85@PYGZrb[]
10 0 @PYGZlb[]10, 14, 26, 45, 50, 66, 77, 79, 85@PYGZrb[]
3 0 @PYGZlb[]3, 10, 14, 26, 45, 50, 66, 77, 79, 85@PYGZrb[]
84 9 @PYGZlb[]3, 10, 14, 26, 45, 50, 66, 77, 79, 84, 85@PYGZrb[]
44 4 @PYGZlb[]3, 10, 14, 26, 44, 45, 50, 66, 77, 79, 84, 85@PYGZrb[]
77 9 @PYGZlb[]3, 10, 14, 26, 44, 45, 50, 66, 77, 77, 79, 84, 85@PYGZrb[]
1 0 @PYGZlb[]1, 3, 10, 14, 26, 44, 45, 50, 66, 77, 77, 79, 84, 85@PYGZrb[]
45 7 @PYGZlb[]1, 3, 10, 14, 26, 44, 45, 45, 50, 66, 77, 77, 79, 84, 85@PYGZrb[]
73 10 @PYGZlb[]1, 3, 10, 14, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85@PYGZrb[]
23 4 @PYGZlb[]1, 3, 10, 14, 23, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85@PYGZrb[]
95 17 @PYGZlb[]1, 3, 10, 14, 23, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85, 95@PYGZrb[]
91 17 @PYGZlb[]1, 3, 10, 14, 23, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85, 91, 95@PYGZrb[]
\end{Verbatim}

第一列显示了新的随机数，第二列显示了数被插入到列表中的位置。最后是当前排序列表中的元素。

这是一个很简单的示例，我们处理的速度由于列表规模小以及每次只需排序一次, 变的非常快速。但对于一个很长的list，利用这种方法能得到时间和内存上的节省。

你可能会注意到上述结果中存在一些重复值（45和77）.bisect模块提供了2种方法来处理重复，新值可以插入到已经存在值的左边或者右边。对应的是 insort\_right()函数，可以将值插入已有值的后面（右边），insort\_left()函数可以插入到之前（左边）。

如果我们使用bisect\_left()和bisect\_right()来处理同样的数据，那么最后获得的list是相同的，只是中间插入的位置会有不同。

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Reset the seed]
random@PYGbe[.]seed(@PYGaw[1])

@PYGaD[@# Use bisect@_left and insort@_left.]
l @PYGbe[=] @lb[]@rb[]
@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[1], @PYGaw[20]):
    r @PYGbe[=] random@PYGbe[.]randint(@PYGaw[1], @PYGaw[100])
    position @PYGbe[=] bisect@PYGbe[.]bisect@_left(l, r)
    bisect@PYGbe[.]insort@_left(l, r)
    @PYGay[print] @PYGad[']@PYGbf[@%2d]@PYGad[ ]@PYGbf[@%2d]@PYGad['] @PYGbe[@%] (r, position), l
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
14 0 @PYGZlb[]14@PYGZrb[]
85 1 @PYGZlb[]14, 85@PYGZrb[]
77 1 @PYGZlb[]14, 77, 85@PYGZrb[]
26 1 @PYGZlb[]14, 26, 77, 85@PYGZrb[]
50 2 @PYGZlb[]14, 26, 50, 77, 85@PYGZrb[]
45 2 @PYGZlb[]14, 26, 45, 50, 77, 85@PYGZrb[]
66 4 @PYGZlb[]14, 26, 45, 50, 66, 77, 85@PYGZrb[]
79 6 @PYGZlb[]14, 26, 45, 50, 66, 77, 79, 85@PYGZrb[]
10 0 @PYGZlb[]10, 14, 26, 45, 50, 66, 77, 79, 85@PYGZrb[]
3 0 @PYGZlb[]3, 10, 14, 26, 45, 50, 66, 77, 79, 85@PYGZrb[]
84 9 @PYGZlb[]3, 10, 14, 26, 45, 50, 66, 77, 79, 84, 85@PYGZrb[]
44 4 @PYGZlb[]3, 10, 14, 26, 44, 45, 50, 66, 77, 79, 84, 85@PYGZrb[]
77 8 @PYGZlb[]3, 10, 14, 26, 44, 45, 50, 66, 77, 77, 79, 84, 85@PYGZrb[]
1 0 @PYGZlb[]1, 3, 10, 14, 26, 44, 45, 50, 66, 77, 77, 79, 84, 85@PYGZrb[]
45 6 @PYGZlb[]1, 3, 10, 14, 26, 44, 45, 45, 50, 66, 77, 77, 79, 84, 85@PYGZrb[]
73 10 @PYGZlb[]1, 3, 10, 14, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85@PYGZrb[]
23 4 @PYGZlb[]1, 3, 10, 14, 23, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85@PYGZrb[]
95 17 @PYGZlb[]1, 3, 10, 14, 23, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85, 95@PYGZrb[]
91 17 @PYGZlb[]1, 3, 10, 14, 23, 26, 44, 45, 45, 50, 66, 73, 77, 77, 79, 84, 85, 91, 95@PYGZrb[]
\end{Verbatim}

除了python实现外，还有一个更快的c实现，如果c版本存在，那么 \code{import bisect} 模块时会自动调用c版本而不是调用python版本。


\section{参考}
\begin{itemize}
\item {} 
\href{http://en.wikipedia.org/wiki/Insertion\_sort}{Insertion Sort}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: logging}
\begin{itemize}
\item {} 
模块：logging

\item {} 
目的：为python模块提供状态、错误、信息输出的标准接口

\item {} 
python版本：2.3

\end{itemize}


\section{描述}

logging模块定义了一个标准API, 用于报告所有你使用的模块的错误和状态信息.标准库模块中提供logging API的最重要意义是所有python模块可以参与到日志记录中, 因此你的应用程序日志可以包含来自第三方模块的信息.

当然, 在不同层次上或因不同目的来记录日志信息是有必要的. 将日志信息写入到文件, 如，HTTP GET/POST的地理信息, 通过SMTP发送的邮件, 一般的sockets, 或者特定OS的日志机制都是被标准模块支持的. 如果你有特殊需求, 任何内置模块都不能满足的话, 你也可以创建你自己的日志目标类.


\section{例子}

大多数应用程序可能会将日志写入到文件中, 所以让我从这个例子开始讲述. 我们使用basicConfig()函数来设置默认的处理用于将调试信息写入到文件.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[logging]
LOG@_FILENAME @PYGbe[=] @PYGad[']@PYGad[/tmp/logging@_example.out]@PYGad[']
logging@PYGbe[.]basicConfig(filename@PYGbe[=]LOG@_FILENAME,level@PYGbe[=]logging@PYGbe[.]DEBUG,)

logging@PYGbe[.]debug(@PYGad[']@PYGad[This message should go to the log file]@PYGad['])
\end{Verbatim}

现在如果我们打开这个文件, 看看里面是什么, 我们应该可以找到以下的日志信息:

\begin{Verbatim}[commandchars=@\[\]]
f @PYGbe[=] @PYGaX[open](LOG@_FILENAME, @PYGad[']@PYGad[rt]@PYGad['])
@PYGay[try]:
    body @PYGbe[=] f@PYGbe[.]read()
@PYGay[finally]:
    f@PYGbe[.]close()
    @PYGay[print] @PYGad[']@PYGad[FILE:]@PYGad[']
    @PYGay[print] body
    @PYGay[print]
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
FILE:
DEBUG:root:This message should go to the log file
\end{Verbatim}

如果我们重复运行之前的脚本, 那么另外的日志信息会附加到文件末尾. 为了每次能够创建一个新的文件, 你可以传递一个filemode参数值为 \code{'w'} 给basicConfig().尽管你自己不能控制这个日志文件大小, 但, 可以使用RotatingFileHandler, 这更方便:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[glob]
@PYGay[import] @PYGaV[logging]
@PYGay[import] @PYGaV[logging.handlers]

LOG@_FILENAME @PYGbe[=] @PYGad[']@PYGad[/tmp/logging@_rotatingfile@_example.out]@PYGad[']

@PYGaD[@# Set up a specific logger with our desired output level]
my@_logger @PYGbe[=] logging@PYGbe[.]getLogger(@PYGad[']@PYGad[MyLogger]@PYGad['])
my@_logger@PYGbe[.]setLevel(logging@PYGbe[.]DEBUG)

@PYGaD[@# Add the log message handler to the logger]
handler @PYGbe[=] logging@PYGbe[.]handlers@PYGbe[.]RotatingFileHandler(LOG@_FILENAME, maxBytes@PYGbe[=]@PYGaw[20], backupCount@PYGbe[=]@PYGaw[5])
my@_logger@PYGbe[.]addHandler(handler)

@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[20]):
    my@_logger@PYGbe[.]debug(@PYGad[']@PYGad[i = ]@PYGbf[@%d]@PYGad['] @PYGbe[@%] i)

@PYGaD[@# See what files are created]
logfiles @PYGbe[=] glob@PYGbe[.]glob(@PYGad[']@PYGbf[@%s]@PYGad[*]@PYGad['] @PYGbe[@%] LOG@_FILENAME)

@PYGay[for] filename @PYGan[in] logfiles:
    @PYGay[print] filename
\end{Verbatim}

结果应该是6个独立的文件, 每个都含有应用程序的日志历史:

\begin{Verbatim}[commandchars=@\[\]]
/tmp/logging@_rotatingfile@_example.out
/tmp/logging@_rotatingfile@_example.out.1
/tmp/logging@_rotatingfile@_example.out.2
/tmp/logging@_rotatingfile@_example.out.3
/tmp/logging@_rotatingfile@_example.out.4
/tmp/logging@_rotatingfile@_example.out.5 @#@#生成5个备份是由于之前设置了backupCount=5
\end{Verbatim}

当前日志文件总是为/tmp/logging\_rotatingfile\_example.out, 每次当文件大小达到限制时, 就以后缀.1来重命名. 每个已存的备份文件也依次重命名为原先后缀增一(如, .1成为.2), .5文件会被擦除.

显然的, 这个例子中设置了日志的长度太太太小了. 所以在实际程序下, 你可以为maxBytes设置一个合适的值.

使用日志API的另外一个有用的地方是能够在不同日志层次上产生不同的信息. 这能够让你书写的代码中带有调试信息, 例如, 降低日志层次以便这些调试信息不输出到你的生产系统中.

\begin{Verbatim}[commandchars=@\[\]]
CRITICAL 50
ERROR 40
WARNING 30
INFO 20
DEBUG 10
UNSET 0
\end{Verbatim}

日志记录器, handler, 日志信息可以分别调用不同的层次 . 一条日志信息, 只有当处理和日志记录器被设置为和它一样的层次或比它低层次时, 才被输出. 例如, 如果一个信息是CRITICAL, 记录器被设置为ERROR, 那么这个消息会输出来. 如果一个信息是WARNING, 记录器被设置为ERROR, 那么这个信息不被输出.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[logging]
@PYGay[import] @PYGaV[sys]

LEVELS @PYGbe[=] { @PYGad[']@PYGad[debug]@PYGad[']:logging@PYGbe[.]DEBUG,
           @PYGad[']@PYGad[info]@PYGad[']:logging@PYGbe[.]INFO,
           @PYGad[']@PYGad[warning]@PYGad[']:logging@PYGbe[.]WARNING,
           @PYGad[']@PYGad[error]@PYGad[']:logging@PYGbe[.]ERROR,
           @PYGad[']@PYGad[critical]@PYGad[']:logging@PYGbe[.]CRITICAL,
}

@PYGay[if] @PYGaX[len](sys@PYGbe[.]argv) @PYGbe[@textgreater[]] @PYGaw[1]:
    level@_name @PYGbe[=] sys@PYGbe[.]argv@lb[]@PYGaw[1]@rb[]
    level @PYGbe[=] LEVELS@PYGbe[.]get(level@_name, logging@PYGbe[.]NOTSET)
    logging@PYGbe[.]basicConfig(level@PYGbe[=]level)

logging@PYGbe[.]debug(@PYGad[']@PYGad[This is a debug message]@PYGad['])
logging@PYGbe[.]info(@PYGad[']@PYGad[This is an info message]@PYGad['])
logging@PYGbe[.]warning(@PYGad[']@PYGad[This is a warning message]@PYGad['])
logging@PYGbe[.]error(@PYGad[']@PYGad[This is an error message]@PYGad['])
logging@PYGbe[.]critical(@PYGad[']@PYGad[This is a critical error message]@PYGad['])
\end{Verbatim}

运行这个脚本时指定参数, 如 \code{'debug'} 或 \code{'warning'}, 看看在不同层次上, 哪些信息会显示出来:

\begin{Verbatim}[commandchars=@\[\]]
@$ python logging@_level@_example.py debug
DEBUG:root:This is a debug message
INFO:root:This is an info message
WARNING:root:This is a warning message
ERROR:root:This is an error message
CRITICAL:root:This is a critical error message

@$ python logging@_level@_example.py info
INFO:root:This is an info message
WARNING:root:This is a warning message
ERROR:root:This is an error message
CRITICAL:root:This is a critical error message
\end{Verbatim}

你可能不会注意到这些日志信息中都含有 \code{'root'}. 这个日志模块支持一个不同名字日志记录器的层次结构. 一个告知某条日志信息来自于哪个日志器的简单方式是对每个模块使用独立的日志器对象. 每个新的日志器从它的父亲中''继承''一些配置, 日志信息发送到一个包含父日志器名字的日志器. 可选的, 每个日志器可以配置不同, 以便让来自不同模块的信息按不同的方式处理. 让我们看个简单的例子看怎样记录来自不同模块的信息, 这也便于追踪信息的对应源代码:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[logging]

logging@PYGbe[.]basicConfig(level@PYGbe[=]logging@PYGbe[.]WARNING)

logger1 @PYGbe[=] logging@PYGbe[.]getLogger(@PYGad[']@PYGad[package1.module1]@PYGad['])
logger2 @PYGbe[=] logging@PYGbe[.]getLogger(@PYGad[']@PYGad[package2.module2]@PYGad['])

logger1@PYGbe[.]warning(@PYGad[']@PYGad[This message comes from one module]@PYGad['])
logger2@PYGbe[.]warning(@PYGad[']@PYGad[And this message comes from another module]@PYGad['])
\end{Verbatim}

输出为:

\begin{Verbatim}[commandchars=@\[\]]
@$ python logging@_modules@_example.py
WARNING:package1.module1:This message comes from one module
WARNING:package2.module2:And this message comes from another module
\end{Verbatim}

还有许多许多许多配置日志记录的选项, 包括不同日志信息格式化选项, 将信息发送到多个记录器, 使用socket接口改变一个正在运行的长时间程序的配置. 所有这些选项进一步在 \href{http://docs.python.org/lib/module-logging.html}{库模块文档} 中深入.


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.python.org/dev/peps/pep-0282/}{PEP 282}

\item {} 
\href{http://www.onlamp.com/pub/a/python/2005/06/02/}{Python Standard Logging}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: locale}
\begin{itemize}
\item {} 
模块： locale

\item {} 
目的： POSIX标准的本地化API

\item {} 
python版本： 1.5,在2.5版本中有所扩展

\end{itemize}


\section{描述}

locale模块是Python国际化和本地化支持库的一部分. 他提供一种用于处理那些可能依赖于你用户语言或位置的操作的标准方式. 例如, 货币格式化, 比较字符串以便排序, 处理时间日期. 他没有包含翻译(可参见gettext模块)或Unicode编码.

由于可以在应用程序范围内改变本地化设置, 所以推荐用户避免在库中改变值而是让应用程序一次性设置. 在下面的例子中, 我会改变本地的一些时间以便说明目的.这更像是一旦你的应用程序启动就去设置本地化参数.


\section{例子}

让用户改变一个应用程序的本地设置的最一般的方式是通过一个环境变量（LC\_\_ALL, LC\_\_CTYPE, LANG, 或LANGUAGE, 这依赖于你的平台). 然后程序会调用locale.setlocale(), 没有使用硬编码值, 而是使用环境变量.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[locale]
@PYGay[import] @PYGaV[os]
@PYGay[import] @PYGaV[pprint]

@PYGay[print] @PYGad[']@PYGad[Environment settings:]@PYGad[']
@PYGay[for] env@_name @PYGan[in] @lb[] @PYGad[']@PYGad[LC@_ALL]@PYGad['], @PYGad[']@PYGad[LC@_CTYPE]@PYGad['], @PYGad[']@PYGad[LANG]@PYGad['], @PYGad[']@PYGad[LANGUAGE]@PYGad['] @rb[]:
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGbf[@%s]@PYGad[ = ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] (env@_name, os@PYGbe[.]environ@PYGbe[.]get(env@_name, @PYGad[']@PYGad[']))

@PYGaD[@# What is the default locale?]
@PYGay[print]
@PYGay[print] @PYGad[']@PYGad[Default locale:]@PYGad['], locale@PYGbe[.]getdefaultlocale()

@PYGaD[@# Default settings based on the user's environment.]
locale@PYGbe[.]setlocale(locale@PYGbe[.]LC@_ALL, @PYGad[']@PYGad['])

@PYGaD[@# If we do not have a locale, assume US English.]
@PYGay[print] @PYGad[']@PYGad[From environment:]@PYGad['], locale@PYGbe[.]getlocale()

pprint@PYGbe[.]pprint(locale@PYGbe[.]localeconv())
\end{Verbatim}

在我的Mac上, 这个程序输出类似如下:

\begin{Verbatim}[commandchars=@\[\]]
@$ python locale@_env@_example.py
Environment settings:
 LC@_ALL =
 LC@_CTYPE =
 LANG =
 LANGUAGE =

Default locale: (None, 'mac-roman')
From environment: (None, None)
{'currency@_symbol': '',
 'decimal@_point': '.',
 'frac@_digits': 127,
 'grouping': @PYGZlb[]127@PYGZrb[],
 'int@_curr@_symbol': '',
 'int@_frac@_digits': 127,
 'mon@_decimal@_point': '',
 'mon@_grouping': @PYGZlb[]127@PYGZrb[],
 'mon@_thousands@_sep': '',
 'n@_cs@_precedes': 127,
 'n@_sep@_by@_space': 127,
 'n@_sign@_posn': 127,
 'negative@_sign': '',
 'p@_cs@_precedes': 127,
 'p@_sep@_by@_space': 127,
 'p@_sign@_posn': 127,
 'positive@_sign': '',
 'thousands@_sep': ''}
\end{Verbatim}

现在如果我们设置好LANG值后再运行同样的脚本, 可以看到本地设置和默认编码因此改变:

法国:

\begin{Verbatim}[commandchars=@\[\]]
@$ LANG=fr@_FR python locale@_env@_example.py
Environment settings:
 LC@_ALL =
 LC@_CTYPE =
 LANG = fr@_FR
 LANGUAGE =

Default locale: (None, 'mac-roman')
From environment: ('fr@_FR', 'ISO8859-1')
{'currency@_symbol': 'Eu',
 'decimal@_point': ',',
 'frac@_digits': 2,
 'grouping': @PYGZlb[]127@PYGZrb[],
 'int@_curr@_symbol': 'EUR ',
 'int@_frac@_digits': 2,
 'mon@_decimal@_point': ',',
 'mon@_grouping': @PYGZlb[]3, 3, 0@PYGZrb[],
 'mon@_thousands@_sep': ' ',
 'n@_cs@_precedes': 0,
 'n@_sep@_by@_space': 1,
 'n@_sign@_posn': 2,
 'negative@_sign': '-',
 'p@_cs@_precedes': 0,
 'p@_sep@_by@_space': 1,
 'p@_sign@_posn': 1,
 'positive@_sign': '',
 'thousands@_sep': ''}
\end{Verbatim}

西班牙:

\begin{Verbatim}[commandchars=@\[\]]
@$ LANG=es@_ES python locale@_env@_example.py
Environment settings:
 LC@_ALL =
 LC@_CTYPE =
 LANG = es@_ES
 LANGUAGE =

Default locale: (None, 'mac-roman')
From environment: ('es@_ES', 'ISO8859-1')
{'currency@_symbol': 'Eu',
 'decimal@_point': ',',
 'frac@_digits': 2,
 'grouping': @PYGZlb[]127@PYGZrb[],
 'int@_curr@_symbol': 'EUR ',
 'int@_frac@_digits': 2,
 'mon@_decimal@_point': ',',
 'mon@_grouping': @PYGZlb[]3, 3, 0@PYGZrb[],
 'mon@_thousands@_sep': '.',
 'n@_cs@_precedes': 1,
 'n@_sep@_by@_space': 1,
 'n@_sign@_posn': 1,
 'negative@_sign': '-',
 'p@_cs@_precedes': 1,
 'p@_sep@_by@_space': 1,
 'p@_sign@_posn': 1,
 'positive@_sign': '',
 'thousands@_sep': ''}
\end{Verbatim}

葡萄牙:

\begin{Verbatim}[commandchars=@\[\]]
@$ LANG=pt@_PT python locale@_env@_example.py
Environment settings:
 LC@_ALL =
 LC@_CTYPE =
 LANG = pt@_PT
 LANGUAGE =

Default locale: (None, 'mac-roman')
From environment: ('pt@_PT', 'ISO8859-1')
{'currency@_symbol': 'Eu',
 'decimal@_point': ',',
 'frac@_digits': 2,
 'grouping': @PYGZlb[]127@PYGZrb[],
 'int@_curr@_symbol': 'EUR ',
 'int@_frac@_digits': 2,
 'mon@_decimal@_point': '.',
 'mon@_grouping': @PYGZlb[]3, 3, 0@PYGZrb[],
 'mon@_thousands@_sep': '.',
 'n@_cs@_precedes': 0,
 'n@_sep@_by@_space': 1,
 'n@_sign@_posn': 1,
 'negative@_sign': '-',
 'p@_cs@_precedes': 0,
 'p@_sep@_by@_space': 1,
 'p@_sign@_posn': 1,
 'positive@_sign': '',
 'thousands@_sep': ' '}
\end{Verbatim}

波兰:

\begin{Verbatim}[commandchars=@\[\]]
@$ LANG=pl@_PL python locale@_env@_example.py
Environment settings:
 LC@_ALL =
 LC@_CTYPE =
 LANG = pl@_PL
 LANGUAGE =

Default locale: (None, 'mac-roman')
From environment: ('pl@_PL', 'ISO8859-2')
{'currency@_symbol': 'z?\x82',
 'decimal@_point': ',',
 'frac@_digits': 2,
 'grouping': @PYGZlb[]3, 3, 0@PYGZrb[],
 'int@_curr@_symbol': 'PLN ',
 'int@_frac@_digits': 2,
 'mon@_decimal@_point': ',',
 'mon@_grouping': @PYGZlb[]3, 3, 0@PYGZrb[],
 'mon@_thousands@_sep': ' ',
 'n@_cs@_precedes': 1,
 'n@_sep@_by@_space': 2,
 'n@_sign@_posn': 4,
 'negative@_sign': '-',
 'p@_cs@_precedes': 1,
 'p@_sep@_by@_space': 2,
 'p@_sign@_posn': 4,
 'positive@_sign': '',
 'thousands@_sep': ' '}
\end{Verbatim}

所以你可以看到货币符号(currency\_symbol)设置改变了, 从小数中分离出整个数字的分割字符(decimal\_point)也改变了, 等等. 现在以不同的地区设置(US 美元, 欧元, 和Polish złoty)格式输出同样的信息:

\begin{Verbatim}[commandchars=@\[\]]
sample@_locales @PYGbe[=] @lb[] (@PYGad[']@PYGad[USA]@PYGad['], @PYGad[']@PYGad[en@_US]@PYGad[']),
                   (@PYGad[']@PYGad[France]@PYGad['], @PYGad[']@PYGad[fr@_FR]@PYGad[']),
                   (@PYGad[']@PYGad[Spain]@PYGad['], @PYGad[']@PYGad[es@_ES]@PYGad[']),
                   (@PYGad[']@PYGad[Portugal]@PYGad['], @PYGad[']@PYGad[pt@_PT]@PYGad[']),
                   (@PYGad[']@PYGad[Poland]@PYGad['], @PYGad[']@PYGad[pl@_PL]@PYGad[']),
                 @rb[]

@PYGay[for] name, loc @PYGan[in] sample@_locales:
    locale@PYGbe[.]setlocale(locale@PYGbe[.]LC@_ALL, loc)
    @PYGay[print] @PYGad[']@PYGbf[@%20s]@PYGad[: ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] (name, locale@PYGbe[.]currency(@PYGaw[1234.56]))
\end{Verbatim}

输出一个小的表格:

\begin{Verbatim}[commandchars=@\[\]]
@$ python locale@_currency@_example.py
USA: @$1234.56
France: 1234,56 Eu
Spain: Eu 1234,56
Portugal: 1234.56 Eu
Poland: zł 1234,56
\end{Verbatim}

除了以不同的格式输出外, 本地化模块还可以帮助解析输入. 不同的文化对数字格式化使用不同的转换(上面已列出). 本地化模块提供atoi()和atof()函数分别用来进行字符串与整数和浮点数之间的转换.

\begin{Verbatim}[commandchars=@\[\]]
sample@_data @PYGbe[=] @lb[] (@PYGad[']@PYGad[USA]@PYGad['], @PYGad[']@PYGad[en@_US]@PYGad['], @PYGad[']@PYGad[1234.56]@PYGad[']),
                (@PYGad[']@PYGad[France]@PYGad['], @PYGad[']@PYGad[fr@_FR]@PYGad['], @PYGad[']@PYGad[1234,56]@PYGad[']),
                (@PYGad[']@PYGad[Spain]@PYGad['], @PYGad[']@PYGad[es@_ES]@PYGad['], @PYGad[']@PYGad[1234,56]@PYGad[']),
                (@PYGad[']@PYGad[Portugal]@PYGad['], @PYGad[']@PYGad[pt@_PT]@PYGad['], @PYGad[']@PYGad[1234.56]@PYGad[']),
                (@PYGad[']@PYGad[Poland]@PYGad['], @PYGad[']@PYGad[pl@_PL]@PYGad['], @PYGad[']@PYGad[1234,56]@PYGad[']),
              @rb[]

@PYGay[for] name, loc, a @PYGan[in] sample@_data:
    locale@PYGbe[.]setlocale(locale@PYGbe[.]LC@_ALL, loc)
    f @PYGbe[=] locale@PYGbe[.]atof(a)
    locale@PYGbe[.]setlocale(locale@PYGbe[.]LC@_ALL, @PYGad[']@PYGad[en@_US]@PYGad['])
    @PYGay[print] @PYGad[']@PYGbf[@%20s]@PYGad[: ]@PYGbf[@%7s]@PYGad[ =@textgreater[] ]@PYGbf[@%f]@PYGad['] @PYGbe[@%] (name, a, f)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python locale@_atof@_example.py
USA: 1234.56 =@textgreater[] 1234.560000
France: 1234,56 =@textgreater[] 1234.560000
Spain: 1234,56 =@textgreater[] 1234.560000
Portugal: 1234.56 =@textgreater[] 1234.560000
Poland: 1234,56 =@textgreater[] 1234.560000
\end{Verbatim}

另一个本地化的重要方面是时间和日期的格式化:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[locale]
@PYGay[import] @PYGaV[time]

sample@_locales @PYGbe[=] @lb[] (@PYGad[']@PYGad[USA]@PYGad['], @PYGad[']@PYGad[en@_US]@PYGad[']),
                   (@PYGad[']@PYGad[France]@PYGad['], @PYGad[']@PYGad[fr@_FR]@PYGad[']),
                   (@PYGad[']@PYGad[Spain]@PYGad['], @PYGad[']@PYGad[es@_ES]@PYGad[']),
                   (@PYGad[']@PYGad[Portugal]@PYGad['], @PYGad[']@PYGad[pt@_PT]@PYGad[']),
                   (@PYGad[']@PYGad[Poland]@PYGad['], @PYGad[']@PYGad[pl@_PL]@PYGad[']),
                 @rb[]

@PYGay[for] name, loc @PYGan[in] sample@_locales:
    locale@PYGbe[.]setlocale(locale@PYGbe[.]LC@_ALL, loc)
    @PYGay[print] @PYGad[']@PYGbf[@%20s]@PYGad[: ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] (name, time@PYGbe[.]strftime(locale@PYGbe[.]nl@_langinfo(locale@PYGbe[.]D@_T@_FMT)))
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python locale@_date@_example.py

USA: Sun May 20 10:19:54 2007
France: Dim 20 mai 10:19:54 2007
Spain: dom 20 may 10:19:54 2007
Portugal: Dom 20 Mai 10:19:54 2007
Poland: ndz 20 maj 10:19:54 2007
\end{Verbatim}

这个星期我只阐述了本地化模块中的一些高层函数. 还有其他低层(格式化字符串)或那些管理你应用程序本地化的函数(resetlocale). 和往常一样, 你可以参考Python库文档来查看些细节.


\section{参考}
\begin{itemize}
\item {} 
\href{http://en.wikipedia.org/wiki/Locale}{Locale - Wikipedia}

\item {} 
\href{http://en.wikipedia.org/wiki/Internationalization\_and\_localization}{Internationalization and localization - Wikipedia}

\item {} 
\href{http://www.openi18n.org/}{OpenI18N.org - The Free standards Group Open Internationalisation Initiative}

\item {} 
\href{http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/nls\_238z.asp}{MSDN - National Language Support Constants}

\item {} 
\href{http://www.python.org/workshops/1997-10/proceedings/loewis.html}{Internationalizing Python}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: os}
\begin{itemize}
\item {} 
模块：os

\item {} 
目的：为访问操作系统的特定属性提供方便。

\item {} 
python版本：1.4+

\end{itemize}


\section{描述}

os模块提供了对特定平台模块(如posix，nt，mac)的封装，函数提供的api在很多平台上都可以相同使用，所以使用os模块会变得很方便。但不是所有函数在所有平台上都可用，比如在本文中到的一些管理函数在windows上无法使用。

在Python文档中os模块的副标题是“操作系统混合接口”，模块包含的大部分函数用于创建和管理活动进程和文件系统（文件和目录），当然除此之外还有其它一些函数。本文中，我们对如何获取和设置进程参数来进行讨论。

\begin{notice}{note}{Note:}
以下示例代码有的只能在linux平台上工作。
\end{notice}


\section{属主处理}

首先讨论用来检查和改变进程属主id的函数。在守护进程和特殊的系统程序需要改变执行权限而不使用root情况下这往往是非常有用的。这里我不会太过详细的解释linux的安全，进程属主等具体含义，这些可以见参考中的文章来获得更详细的介绍。

我们给出一段脚本来获取一个进程的有效用户和组信息，然后改变这些有效值。这类似于一个守护进程在系统启动时以root身份启动加载，然后降低权限并作为一个普通用户运行。如果你下载示例并试运行，你可以设置user相应的值为TEST\_GID和TEST\_UID。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]

TEST@_GID@PYGbe[=]@PYGaw[501]
TEST@_UID@PYGbe[=]@PYGaw[527]

@PYGay[def] @PYGaK[show@_user@_info]():
     @PYGay[print] @PYGad[']@PYGad[Effective User  :]@PYGad['], os@PYGbe[.]geteuid()
     @PYGay[print] @PYGad[']@PYGad[Effective Group :]@PYGad['], os@PYGbe[.]getegid()
     @PYGay[print] @PYGad[']@PYGad[Actual User    :]@PYGad['], os@PYGbe[.]getuid(), os@PYGbe[.]getlogin()
     @PYGay[print] @PYGad[']@PYGad[Actual Group  :]@PYGad['], os@PYGbe[.]getgid()
     @PYGay[print] @PYGad[']@PYGad[Actual Groups   :]@PYGad['], os@PYGbe[.]getgroups()
     @PYGay[return]

@PYGay[print] @PYGad[']@PYGad[BEFORE CHANGE:]@PYGad[']
show@_user@_info()
@PYGay[print]
@PYGay[try]:
     os@PYGbe[.]setegid(TEST@_GID)
@PYGay[except] @PYGaU[OSError]:
     @PYGay[print] @PYGad[']@PYGad[ERROR: Could not change effective group.  Re-run as root.]@PYGad[']
@PYGay[else]:
     @PYGay[print] @PYGad[']@PYGad[CHANGED GROUP:]@PYGad[']
     show@_user@_info()
     @PYGay[print]

@PYGay[try]:
     os@PYGbe[.]seteuid(TEST@_UID)
@PYGay[except] @PYGaU[OSError]:
     @PYGay[print] @PYGad[']@PYGad[ERROR: Could not change effective user.  Re-run as root.]@PYGad[']
@PYGay[else]:
     @PYGay[print] @PYGad[']@PYGad[CHANGE USER:]@PYGad[']
     show@_user@_info()
     @PYGay[print]
\end{Verbatim}

当我运行在DELL D630 Ubuntu上时，得到的结果如下：

\begin{Verbatim}[commandchars=@\[\]]
@textasciitilde[] 16:51:33@textgreater[] ./a.py
BEFORE CHANGE:
Effective User  : 1000
Effective Group : 1000
Actual User    : 1000 cjj
Actual Group  : 1000
Actual Groups   : @PYGZlb[]4, 20, 24, 25, 29, 30, 44, 46, 104, 108, 110, 115, 117, 1000@PYGZrb[]

ERROR: Could not change effective group.  Re-run as root.
ERROR: Could not change effective user.  Re-run as root.
\end{Verbatim}

注意，当我使用非root运行时，值未被改变，我所启动的进程不可以改变他们自身有效的属性。如果我试图设置其他的用户名和组id，那么会抛出OSError异常。

下面，我们以root权限来运行这段脚本:

\begin{Verbatim}[commandchars=@\[\]]
@textasciitilde[] 16:51:10@textgreater[] sudo ./a.py
@PYGZlb[]sudo@PYGZrb[] password for cjj:
BEFORE CHANGE:
Effective User  : 0
Effective Group : 0
Actual User    : 0 cjj
Actual Group  : 0
Actual Groups   : @PYGZlb[]0@PYGZrb[]

CHANGED GROUP:
Effective User  : 0
Effective Group : 501
Actual User    : 0 cjj
Actual Group  : 0
Actual Groups   : @PYGZlb[]0@PYGZrb[]

CHANGE USER:
Effective User  : 527
Effective Group : 501
Actual User    : 0 cjj
Actual Group  : 0
Actual Groups   : @PYGZlb[]0@PYGZrb[]
\end{Verbatim}

在这个例子中，如果我们以root权限运行，那么我们可以改变这个进程的用户和组属性。一旦我们改变了UID，那么进程将受这个用户的权限限制，非root用户是无法改变有效用户组，所以首先我们需要改变用户组，然后再改变用户名。

除了查找和改变进程属主，还有其他函数可以获取当前进程和父进程的id，查找和改变其进程用户组和会话id，与控制终端id是一样的。在你编写复杂程序（如自己的终端命令行程序）中使用这些函数可以帮助你在进程之间传递信号。


\section{环境处理}

通过os模块，你的程序可以访问的另一个操作系统特性是系统环境。通过os.environ和os.getenv()可以访问在环境中设置的变量字符串。环境变量常用来作为配置像搜索路径，文件路径、调试标志的值。下面的示例检索了一个环境变量，并且通过子进程改变了这个值。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGad[Initial value:]@PYGad['], os@PYGbe[.]environ@PYGbe[.]get(@PYGad[']@PYGad[TESTVAR]@PYGad['], @PYGaA[None])
@PYGay[print] @PYGad[']@PYGad[Child process:]@PYGad[']
os@PYGbe[.]system(@PYGad[']@PYGad[echo @$TESTVAR]@PYGad['])

os@PYGbe[.]environ@lb[]@PYGad[']@PYGad[TESTVAR]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[THIS VALUE WAS CHANGED]@PYGad[']

@PYGay[print]
@PYGay[print] @PYGad[']@PYGad[Changed value:]@PYGad['], os@PYGbe[.]environ@lb[]@PYGad[']@PYGad[TESTVAR]@PYGad[']@rb[]
@PYGay[print] @PYGad[']@PYGad[Child process:]@PYGad[']
os@PYGbe[.]system(@PYGad[']@PYGad[echo @$TESTVAR]@PYGad['])

@PYGay[del] os@PYGbe[.]environ@lb[]@PYGad[']@PYGad[TESTVAR]@PYGad[']@rb[]

@PYGay[print]
@PYGay[print] @PYGad[']@PYGad[Removed value:]@PYGad['], os@PYGbe[.]environ@PYGbe[.]get(@PYGad[']@PYGad[TESTVAR]@PYGad['], @PYGaA[None])
@PYGay[print] @PYGad[']@PYGad[Child process:]@PYGad[']
os@PYGbe[.]system(@PYGad[']@PYGad[echo @$TESTVAR]@PYGad['])
\end{Verbatim}

os.environ对象遵循标准的Python映射API以便检索和设置值。 os.environ值的改变将被输出到子进程中。

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_environ@_example.py
Initial value: None
Child process:


Changed value: THIS VALUE WAS CHANGED
Child process:
THIS VALUE WAS CHANGED

Removed value: None
Child process:
\end{Verbatim}


\section{工作目录处理}

在操作系统的文件系统结构中有一个概念是“当前工作目录”。在文件系统中，当前进程在访问用相对路径表示的文件时，就把这个目录当作默认目录位置。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGad[Starting:]@PYGad['], os@PYGbe[.]getcwd()
@PYGay[print] os@PYGbe[.]listdir(os@PYGbe[.]curdir)

@PYGay[print] @PYGad[']@PYGad[Moving up one:]@PYGad['], os@PYGbe[.]pardir
os@PYGbe[.]chdir(os@PYGbe[.]pardir)

@PYGay[print] @PYGad[']@PYGad[After move:]@PYGad['], os@PYGbe[.]getcwd()
@PYGay[print] os@PYGbe[.]listdir(os@PYGbe[.]curdir)
\end{Verbatim}

注意os.curdir()和os.pardir()是指向当前目录和父目录的一种快捷方式。结果很显然：

\begin{Verbatim}[commandchars=@\[\]]
Starting: /Users/dhellmann/Documents/PyMOTW/PyMOTW/os
@PYGZlb[]'.svn', '@_@_init@_@_.py', 'os@_cwd@_example.py', 'os@_environ@_example.py',
'os@_process@_id@_example.py', 'os@_process@_user@_example.py'@PYGZrb[]
Moving up one: ..
After move: /Users/dhellmann/Documents/PyMOTW/PyMOTW
@PYGZlb[]'.svn', '@_@_init@_@_.py', 'bisect', 'ConfigParser', 'fileinput', 'linecache',
'locale', 'logging', 'os', 'Queue', 'StringIO', 'textwrap'@PYGZrb[]
\end{Verbatim}


\section{后续...}

这里我们仅介绍了os模块中查找和设置进程参数的一些函数。下一次，我们将介绍os模块来管理文件系统对象。


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/lib/os-procinfo.html}{Python Reference Manual, Process Parameters}

\item {} 
\href{http://www.ibm.com/developerworks/aix/library/au-speakingunix8/index.html}{Speaking UNIX, Part 8: UNIX processes}

\item {} 
\href{http://www.opengroup.org/onlinepubs/009695399/functions/geteuid.html}{geteuid}

\item {} 
\href{http://opengroup.org/onlinepubs/007908799/xsh/getsid.html}{getsid}

\item {} 
\href{http://linux.about.com/library/cmd/blcmdl2\_setpgrp.htm}{setpgrp}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: os(2)}


\section{描述}

上一部分，我们讨论了进程参数，现在我们讨论一下os模块提供的输入/输出特性。


\section{管道}

os模块提供了一些函数，这些函数利用管道来管理子进程的IO操作。这些函数的工作方式基本相同，但根据输入/输出的需求类型返回不同的文件句柄。相对于2.4版本中的 \href{http://docs.python.org/lib/module-subprocess.html}{subprocess} 模块这些函数是过时了，但这是一个很好的机会，你可以在已有的代码中看到它们。

管道中经常使用的是popen()函数，它创建一个新的进程用于运行给定的命令并且根据模式选项附加给这个进程一个单一的输入输出数据流 。虽然在Windows中可以使用popen()，但以下例子假设以Unix shell方式运行，其中流的概念也是unix技术。

stdin：进程（文件描述符0）的标准输入流，对于这个进程来说是可读的，通常指终端输入。

stdout：进程（文件描述符1）的标准输出流，对于这个进程来说是可写的，通常用于给用户显示非错误信息。

stderr：进程（文件描述符2）的标准错误流，对于这个进程来说是可写的，通常用于传递错误信息。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]

@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[popen, read:]@PYGad[']
pipe@_stdout @PYGbe[=] os@PYGbe[.]popen(@PYGad[']@PYGad[echo ]@PYGad["]@PYGad[to stdout]@PYGad["]@PYGad['], @PYGad[']@PYGad[r]@PYGad['])
@PYGay[try]:
    stdout@_value @PYGbe[=] pipe@_stdout@PYGbe[.]read()
@PYGay[finally]:
    pipe@_stdout@PYGbe[.]close()
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[stdout:]@PYGad['], @PYGaX[repr](stdout@_value)

@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[popen, write:]@PYGad[']
pipe@_stdin @PYGbe[=] os@PYGbe[.]popen(@PYGad[']@PYGad[cat -]@PYGad['], @PYGad[']@PYGad[w]@PYGad['])
@PYGay[try]:
    pipe@_stdin@PYGbe[.]write(@PYGad[']@PYGao[\t]@PYGad[stdin: to stdin]@PYGao[\n]@PYGad['])
@PYGay[finally]:
    pipe@_stdin@PYGbe[.]close()
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
popen, read:
     stdout: 'to stdout\n'

popen, write:
     stdin: to stdin
\end{Verbatim}

从子进程的流中读取或者写入的方法是比较受限的，popen提供了额外的流，如stdin、stdout、stderr来以便使用。

比如，popen2()函数返回一个与子进程标准输入绑定的只写流和一个与子进程标准输出绑定的只读流。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[popen2:]@PYGad[']
pipe@_stdin, pipe@_stdout @PYGbe[=] os@PYGbe[.]popen2(@PYGad[']@PYGad[cat -]@PYGad['])
@PYGay[try]:
    pipe@_stdin@PYGbe[.]write(@PYGad[']@PYGad[through stdin to stdout]@PYGad['])
@PYGay[finally]:
    pipe@_stdin@PYGbe[.]close()

@PYGay[try]:
    stdout@_value @PYGbe[=] pipe@_stdout@PYGbe[.]read()
@PYGay[finally]:
    pipe@_stdout@PYGbe[.]close()
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[pass through:]@PYGad['], @PYGaX[repr](stdout@_value)
\end{Verbatim}

这个简单例子解释了双向通信方式，从stdin写入的值被cat命令读取（'-`参数的作用），然后由stdout输出。显然，一个复杂的进程通过管道可以来回传递其它类型的信息，甚至是序列化对象。

\begin{Verbatim}[commandchars=@\[\]]
popen2:
     pass through: 'through stdin to stdout'
\end{Verbatim}

有些情况下，希望同时访问stdout和stderr，stdout常用于输出信息，stderr常用于抛出错误。因此分别读取他们可以减少解析错误消息的复杂度，而popen3函数返回一个新进程的3个流stdin、stdout、stderr。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[popen3:]@PYGad[']
pipe@_stdin, pipe@_stdout, pipe@_stderr @PYGbe[=] os@PYGbe[.]popen3(@PYGad[']@PYGad[cat -; echo ]@PYGad["]@PYGad[;to stderr]@PYGad["]@PYGad[ 1@textgreater[]@&2]@PYGad['])
@PYGay[try]:
    pipe@_stdin@PYGbe[.]write(@PYGad[']@PYGad[through stdin to stdout]@PYGad['])
@PYGay[finally]:
    pipe@_stdin@PYGbe[.]close()
@PYGay[try]:
    stdout@_value @PYGbe[=] pipe@_stdout@PYGbe[.]read()
@PYGay[finally]:
    pipe@_stdout@PYGbe[.]close()
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[pass through:]@PYGad['], @PYGaX[repr](stdout@_value)
@PYGay[try]:
    stderr@_value @PYGbe[=] pipe@_stderr@PYGbe[.]read()
@PYGay[finally]:
    pipe@_stderr@PYGbe[.]close()
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[stderr:]@PYGad['], @PYGaX[repr](stderr@_value)
\end{Verbatim}

注意，我们需要分别读取和关闭这些流，在处理多进程的IO中，还涉及到流程控制和排序，I/O即为缓冲器，如果想读取流中的所有数据，那么子进程必须关闭这个流来表示文件的结束 ，更多信息可以参考Python库文档 \href{http://docs.python.org/lib/popen2-flow-control.html}{Flow Control Issues}

\begin{Verbatim}[commandchars=@\[\]]
popen3:
     pass through: 'through stdin to stdout'
     stderr: ';to stderr\n'
\end{Verbatim}

最后，popen4()返回两个流，stdin和stdout/stderr的组合，这对于命令的结果需要被记录，但不需要解析是很有用的。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[popen4:]@PYGad[']
pipe@_stdin, pipe@_stdout@_and@_stderr @PYGbe[=] os@PYGbe[.]popen4(@PYGad[']@PYGad[cat -; echo ]@PYGad["]@PYGad[;to stderr]@PYGad["]@PYGad[ 1@textgreater[]@&2]@PYGad['])
@PYGay[try]:
    pipe@_stdin@PYGbe[.]write(@PYGad[']@PYGad[through stdin to stdout]@PYGad['])
@PYGay[finally]:
    pipe@_stdin@PYGbe[.]close()
@PYGay[try]:
    stdout@_value @PYGbe[=] pipe@_stdout@_and@_stderr@PYGbe[.]read()
@PYGay[finally]:
    pipe@_stdout@PYGbe[.]close()
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[combined output:]@PYGad['], @PYGaX[repr](stdout@_value)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
popen4:
     combined output: 'through stdin to stdout;to stderr\n'
\end{Verbatim}

另外，除了接收简单的字符串命令来传递给shell解析，popen2()、popen3()、popen4()函数同样接收字符串序列（命令，加参数），这种情况中，参数不是传递给shell的。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGao[\n]@PYGad[popen2, cmd as sequence:]@PYGad[']
pipe@_stdin, pipe@_stdout @PYGbe[=] os@PYGbe[.]popen2(@lb[]@PYGad[']@PYGad[cat]@PYGad['], @PYGad[']@PYGad[-]@PYGad[']@rb[])
@PYGay[try]:
    pipe@_stdin@PYGbe[.]write(@PYGad[']@PYGad[through stdin to stdout]@PYGad['])
@PYGay[finally]:
    pipe@_stdin@PYGbe[.]close()
@PYGay[try]:
    stdout@_value @PYGbe[=] pipe@_stdout@PYGbe[.]read()
@PYGay[finally]:
    pipe@_stdout@PYGbe[.]close()
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[pass through:]@PYGad['], @PYGaX[repr](stdout@_value)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
popen2, cmd as sequence:
     pass through: 'through stdin to stdout'
\end{Verbatim}


\section{后续}

下次，我们将讨论如何来控制文件描述符。


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.linuxhq.com/guides/LUG/node67.html}{Unix Concepts} for more discussion of stdin, stdout, and stderr

\item {} 
\href{http://docs.python.org/lib/os-newstreams.html}{File Object Creation} with the os module

\item {} 
\href{http://docs.python.org/lib/module-subprocess.html}{subprocess}

\item {} 
\href{http://docs.python.org/lib/popen2-flow-control.html}{Flow Control Issues}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: os(3)}


\section{描述}

前面讲述了如何来处理进程参数和输入/输出，本周我将探讨一些操作文件和目录的函数。


\section{文件描述符}

os模块中包含了一些函数集用于处理底层的文件描述符（当前进程打开属主文件所使用的整型），相比file()对象来说这些是更底层的API，在本文中将不会解释什么是文件描述符，它通常可以很好的和file()对象协同工作，更多细节可以参考 \href{http://docs.python.org/lib/os-fd-ops.html}{这里} 来了解如何使用文件描述符。


\section{文件系统权限}

os.access()可以测试一个进程对一个文件是否有可访问权限。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]

@PYGay[print] @PYGad[']@PYGad[Testing:]@PYGad['], @_@_file@_@_
@PYGay[print] @PYGad[']@PYGad[Exists:]@PYGad['], os@PYGbe[.]access(@_@_file@_@_, os@PYGbe[.]F@_OK)
@PYGay[print] @PYGad[']@PYGad[Readable:]@PYGad['], os@PYGbe[.]access(@_@_file@_@_, os@PYGbe[.]R@_OK)
@PYGay[print] @PYGad[']@PYGad[Writable:]@PYGad['], os@PYGbe[.]access(@_@_file@_@_, os@PYGbe[.]W@_OK)
@PYGay[print] @PYGad[']@PYGad[Executable:]@PYGad['], os@PYGbe[.]access(@_@_file@_@_, os@PYGbe[.]X@_OK)
\end{Verbatim}

这个结果将取决于你如何来运行这个示例程序，可能会显示如下：

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_access.py
Testing: os@_access.py
Exists: True
Readable: True
Writable: True
Executable: False
\end{Verbatim}

os.access()模块包含了2个特殊的含义，首先，在实际使用open()函数之前使用os.access()函数来判断一个文件是否可访问是没有意义的。这里有个小事实，在函数的两次调用之间可能会改变文件的权限。另外一个含义是该函数适合于大部分扩展的POSIX许可语义的网络文件系统。文件系统对于一个进程对文件有访问权限的POSIX调用会做出响应，在调用open()时，因为某些原因没有通过POSIX的调用测试，那么会报告失败。总之，最好时在特定的模式中使用open()，如果出现错误还可以捕获IOError异常。

如果想获得更多关于文件的信息，可以查阅stat()或者os.lstat（如果你查看的文件一个动态链接的话）。

\begin{Verbatim}[commandchars=@\[\]]
import os
import sys
import time

if len(sys.argv) == 1:
  filename = @_@_file@_@_
  else:
    filename = sys.argv@PYGZlb[]1@PYGZrb[]

stat@_info = os.stat(filename)

print 'os.stat(@%s):' @% filename
print '\tSize:', stat@_info.st@_size
print '\tPermissions:', oct(stat@_info.st@_mode)
print '\tOwner:', stat@_info.st@_uid
print '\tDevice:', stat@_info.st@_dev
print '\tLast modified:', time.ctime(stat@_info.st@_mtime)
\end{Verbatim}

再次申明，你得到的结果将取决于你运行的方式，可以尝试向os\_stat.py传递不同的文件名看看。

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_stat.py
os.stat(os@_stat.py):
    Size: 1547
    Permissions: 0100644
    Owner: 527
    Device: 234881026
    Last modified: Sun Jun 10 08:13:26 2007
\end{Verbatim}

在Unix类型系统上，文件权限可以由chmod()来修改，以整形形式传递。形式值可以用stat模块的常量值来b表示。以下示例了如何来触发用户的可执行权限位。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[import] @PYGaV[stat]

@PYGaD[@# Determine what permissions are already set using stat]
existing@_permissions @PYGbe[=] stat@PYGbe[.]S@_IMODE(os@PYGbe[.]stat(@_@_file@_@_)@PYGbe[.]st@_mode)

@PYGay[if] @PYGan[not] os@PYGbe[.]access(@_@_file@_@_, os@PYGbe[.]X@_OK):
  @PYGay[print] @PYGad[']@PYGad[Adding execute permission]@PYGad[']
  new@_permissions @PYGbe[=] existing@_permissions @PYGbe[|] stat@PYGbe[.]S@_IXUSR
@PYGay[else]:
  @PYGay[print] @PYGad[']@PYGad[Removing execute permission]@PYGad[']
  @PYGaD[@# use xor to remove the user execute permission]
  new@_permissions @PYGbe[=] existing@_permissions @PYGbe[@textasciicircum[]] stat@PYGbe[.]S@_IXUSR

os@PYGbe[.]chmod(@_@_file@_@_, new@_permissions)
\end{Verbatim}

运行该脚本前假设你有修改文件模式的权限。

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_stat@_chmod.py
Adding execute permission
@$ python os@_stat@_chmod.py
Removing execute permission
\end{Verbatim}


\section{目录}

同样提供了一些处理文件系统中目录的函数，包括创建内容列表和删除它们。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]

dir@_name @PYGbe[=] @PYGad[']@PYGad[os@_directories@_example]@PYGad[']

@PYGay[print] @PYGad[']@PYGad[Creating]@PYGad['], dir@_name
os@PYGbe[.]makedirs(dir@_name)

file@_name @PYGbe[=] os@PYGbe[.]path@PYGbe[.]join(dir@_name, @PYGad[']@PYGad[example.txt]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[Creating]@PYGad['], file@_name
f @PYGbe[=] @PYGaX[open](file@_name, @PYGad[']@PYGad[wt]@PYGad['])
@PYGay[try]:
  f@PYGbe[.]write(@PYGad[']@PYGad[example file]@PYGad['])
@PYGay[finally]:
  f@PYGbe[.]close()

@PYGay[print] @PYGad[']@PYGad[Listing]@PYGad['], dir@_name
@PYGay[print] os@PYGbe[.]listdir(dir@_name)

@PYGay[print] @PYGad[']@PYGad[Cleaning up]@PYGad[']
os@PYGbe[.]unlink(file@_name)
os@PYGbe[.]rmdir(dir@_name)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_directories.py
Creating os@_directories@_example
Creating os@_directories@_example/example.txt
Listing os@_directories@_example
@PYGZlb[]'example.txt'@PYGZrb[]
Cleaning up
\end{Verbatim}

有2个函数集用来创建和删除目录，当使用os.mkdir()创建一个新的目录时，其父目录必须存在。当使用os.rmdir()来删除一个目录时候，那么只有目录树的叶子节点（目录的最后一级）可以被删除。相比下，os.makedirs()和os.removedirs()可以操作当前路径下的所有目录，os.makedirs()可以创建路径不存在的目录，os.removedirs()可以删除包含父目录的子目录（当然前提有这个权限）。


\section{符号链接}

很多文件系统和平台都支持它，同样有一些函数可以用来处理它们。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]@PYGbe[,] @PYGaV[tempfile]

link@_name @PYGbe[=] tempfile@PYGbe[.]mktemp()

@PYGay[print] @PYGad[']@PYGad[Creating link ]@PYGbf[@%s]@PYGad[-@textgreater[]]@PYGbf[@%s]@PYGad['] @PYGbe[@%] (link@_name, @_@_file@_@_)
os@PYGbe[.]symlink(@_@_file@_@_, link@_name)

stat@_info @PYGbe[=] os@PYGbe[.]lstat(link@_name)
@PYGay[print] @PYGad[']@PYGad[Permissions:]@PYGad['], @PYGaX[oct](stat@_info@PYGbe[.]st@_mode)

@PYGay[print] @PYGad[']@PYGad[Points to:]@PYGad['], os@PYGbe[.]readlink(link@_name)

@PYGaD[@# Cleanup]
os@PYGbe[.]unlink(link@_name)
\end{Verbatim}

虽然os中包含了os.temparm()来创建临时文件，当时相比tempfile模块还不够安全，在使用中可能会产生RuntimeWarning信息，更好的方法使用tempfile模块。

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_symlinks.py
Creating link /tmp/tmpRxRiHn-@textgreater[]os@_symlinks.py
Permissions: 0120755
Points to: os@_symlinks.py
\end{Verbatim}


\section{访问目录树}

os.walk()可以递归遍历一个目录,对于每一个目录，可以产生一个包含目录路径、当前路径的子目录列表，以及在子目录中的文件，以下示例展示了一个遍历目录的简单方法：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]@PYGbe[,] @PYGaV[sys]

@PYGaD[@# If we are not given a path to list, use /tmp]
@PYGay[if] @PYGaX[len](sys@PYGbe[.]argv) @PYGbe[==] @PYGaw[1]:
  root @PYGbe[=] @PYGad[']@PYGad[/tmp]@PYGad[']
@PYGay[else]:
  root @PYGbe[=] sys@PYGbe[.]argv@lb[]@PYGaw[1]@rb[]

@PYGay[for] dir@_name, sub@_dirs, files @PYGan[in] os@PYGbe[.]walk(root):
  @PYGay[print] @PYGad[']@PYGao[\n]@PYGad['], dir@_name
  @PYGaD[@# Make the subdirectory names stand out with /]
  sub@_dirs @PYGbe[=] @lb[] @PYGad[']@PYGbf[@%s]@PYGad[/]@PYGad['] @PYGbe[@%] n @PYGay[for] n @PYGan[in] sub@_dirs @rb[]
  @PYGaD[@# Mix the directory contents together]
  contents @PYGbe[=] sub@_dirs @PYGbe[+] files
  contents@PYGbe[.]sort()
  @PYGaD[@# Show the contents]
  @PYGay[for] c @PYGan[in] contents:
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGbf[@%s]@PYGad['] @PYGbe[@%] c
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_walk.py

/tmp
   .KerberosLogin-0--1074266944 (inited,root,local)/
   .KerberosLogin-527-4839472 (inited,gui,tty,local)/
   527/
   cs@_cache@_lock@_527
   cs@_cache@_lock@_92
   emacs527/
   fry.log
   hsperfdata@_dhellmann/
   objc@_sharing@_ppc@_4294967294
   objc@_sharing@_ppc@_527
   objc@_sharing@_ppc@_92
   svn.arg.1835l59
   var@_backups/

/tmp/.KerberosLogin-527-4839472 (inited,gui,tty,local)
   KLLCCache.lock

/tmp/527
   /tmp/emacs527
   server
   /tmp/hsperfdata@_dhellmann
   976

/tmp/var@_backups
   infodir.bak
   local.nidump
\end{Verbatim}


\section{后续}

下次，我们讨论os模块中创建和管理进程的函数。


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/lib/os-file-dir.html}{Working with Files and Directories}

\item {} 
\href{http://docs.python.org/lib/module-tempfile.html}{tempfile module}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: os(4)}


\section{描述}

这周,我总结整个os模块(但保留os.path的内容作为将来独立的一篇)并讨论一些有利于处理多进程的函数.我在part2中已经介绍了管道的使用, 这周我们来看下system(),fork(),exec()这3个函数和他们之间的关系.


\section{申明}

这里的许多函数都有可移植性限制.可以查看subprocess模块以获得一种更一致的平台独立的处理进程方式.


\section{运行外部命令}

最简单的运行一条单独命令,没有一点交互的方式是使用os.system(). 他获取一个字符串,这个字符串就是一将被命令行执行的命令,通过一个shell中的子进程来执行.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]

@PYGaD[@# Simple command]
os@PYGbe[.]system(@PYGad[']@PYGad[ls -l]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_system@_example.py
total 168
-rw-r--r-- 1 dhellman dhellman 0 May 27 06:58 @_@_init@_@_.py
-rw-r--r-- 1 dhellman dhellman 1391 Jun 10 09:36 os@_access.py
-rw-r--r-- 1 dhellman dhellman 1383 May 27 09:23 os@_cwd@_example.py
-rw-r--r-- 1 dhellman dhellman 1535 Jun 10 09:36 os@_directories.py
-rw-r--r-- 1 dhellman dhellman 1613 May 27 09:23 os@_environ@_example.py
-rw-r--r-- 1 dhellman dhellman 2816 Jun 3 08:34 os@_popen@_examples.py
-rw-r--r-- 1 dhellman dhellman 1438 May 27 09:23 os@_process@_id@_example.py
-rw-r--r-- 1 dhellman dhellman 1887 May 27 09:23 os@_process@_user@_example.py
-rw-r--r-- 1 dhellman dhellman 1545 Jun 10 09:36 os@_stat.py
-rw-r--r-- 1 dhellman dhellman 1638 Jun 10 09:36 os@_stat@_chmod.py
-rw-r--r-- 1 dhellman dhellman 1452 Jun 10 09:36 os@_symlinks.py
-rw-r--r-- 1 dhellman dhellman 1279 Jun 17 12:17 os@_system@_example.py
-rw-r--r-- 1 dhellman dhellman 1672 Jun 10 09:36 os@_walk.py
\end{Verbatim}

由于命令是直接被传递到处理shell中,所以它可以包含shell语法,比如通配符或环境变量:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[@# Command with shell expansion]
os@PYGbe[.]system(@PYGad[']@PYGad[ls -l @$HOME]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
total 40
-rwx------ 1 dhellman dhellman 1328 Dec 13 2005 @%backup@%@textasciitilde[]
drwx------ 11 dhellman dhellman 374 Jun 17 12:11 Desktop
drwxr-xr-x 15 dhellman dhellman 510 May 27 07:50 Devel
drwx------ 29 dhellman dhellman 986 May 31 17:01 Documents
drwxr-xr-x 45 dhellman dhellman 1530 Jun 17 12:12 DownloadedApps
drwx------ 55 dhellman dhellman 1870 May 22 14:53 Library
drwx------ 8 dhellman dhellman 272 Mar 4 2006 Movies
drwx------ 10 dhellman dhellman 340 Feb 14 10:54 Music
drwx------ 12 dhellman dhellman 408 Jun 17 01:00 Pictures
drwxr-xr-x 5 dhellman dhellman 170 Oct 1 2006 Public
drwxr-xr-x 15 dhellman dhellman 510 May 12 15:19 Sites
drwxr-xr-x 4 dhellman dhellman 136 Jan 23 2006 iPod
-rw-r--r-- 1 dhellman dhellman 105 Mar 7 11:48 pgadmin.log
drwxr-xr-x 3 dhellman dhellman 102 Apr 29 16:32 tmp
\end{Verbatim}

除非你是直接在后台中运行这命令, 不然的话,直到命令执行完毕,调用 \code{os.system()} 的程序都会处于阻断状态. 子进程中的标准输入,输出,和错误输出默认被绑定到调用者的合适的流中. 但是也可以通过shell语法重定向到其他地方.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[import] @PYGaV[time]

@PYGay[print] @PYGad[']@PYGad[Calling...]@PYGad[']
os@PYGbe[.]system(@PYGad[']@PYGad[date; (sleep 3; date) @&]@PYGad['])

@PYGay[print] @PYGad[']@PYGad[Sleeping...]@PYGad[']
time@PYGbe[.]sleep(@PYGaw[5])
\end{Verbatim}

这就是shell的魔力,尽管还有更好的实现方式.

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_system@_background.py
Calling...
Sun Jun 17 12:27:20 EDT 2007
Sleeping...
Sun Jun 17 12:27:23 EDT 2007
\end{Verbatim}


\section{使用os.fork()创建进程}

符合POSIX标准的函数 \code{fork()} 和 \code{exec*()} (在Mac OS X, Linux和其他类UNIX系统上可用)通过os模块都是可用的. 很多书已经很全面可靠的描述了这些函数的使用,所以检查你的库手册,或者去书店寻找进一步细节.

创建一个新进程作为当前进程的一个复本,可以使用 \code{os.fork()} :

\begin{Verbatim}[commandchars=@\[\]]
pid @PYGbe[=] os@PYGbe[.]fork()

@PYGay[if] pid:
    @PYGay[print] @PYGad[']@PYGad[Child process id:]@PYGad['], pid
@PYGay[else]:
    @PYGay[print] @PYGad[']@PYGad[I am the child]@PYGad[']
\end{Verbatim}

每次运行这个事例代码时,你的输出变化给予你系统的当前状态, 但是它应该看起来像如下:

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_fork@_example.py
Child process id: 5883
I am the child
\end{Verbatim}

当fork之后, 你结束这两个运行着相同代码的进程. 可以检查返回值来直到你在哪个进程中. 如果它是0, 表示你在子进程中,如果不是0, 则表示你在父进程中,它返回的值是其子进程的进程id.

对于父进程来说,发送给子进程信号是有必要的. 这个的设置有点复杂, 使用signal模块, 让我们通过具体代码来描述其使用吧. 首先我们定义一个信号处理句柄, 以便在收到相应信号时调用.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[import] @PYGaV[signal]
@PYGay[import] @PYGaV[time]

@PYGay[def] @PYGaK[signal@_usr1](signum, frame):
    pid @PYGbe[=] os@PYGbe[.]getpid()
    @PYGay[print] @PYGad[']@PYGad[Received USR1 in process ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] pid
\end{Verbatim}

然后我们创建子进程, 并在父进程中,通过 \code{os.kill()} 发送一个USR1信号之前暂停一段时间.这短的暂停让子进程有时间去设置信号处理句柄.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGad[Forking...]@PYGad[']
child@_pid @PYGbe[=] os@PYGbe[.]fork()
@PYGay[if] child@_pid: @PYGaD[@#@# 这个是父进程执行的代码]
    @PYGay[print] @PYGad[']@PYGad[PARENT: Pausing before sending signal...]@PYGad[']
    time@PYGbe[.]sleep(@PYGaw[1])
    @PYGay[print] @PYGad[']@PYGad[PARENT: Signaling ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] child@_pid
    os@PYGbe[.]kill(child@_pid, signal@PYGbe[.]SIGUSR1)
\end{Verbatim}

在子进程中,我们设置信号处理句柄后睡眠一段时间来让父进程有时间去发送信号给我们:

\begin{Verbatim}[commandchars=@\[\]]
else:
    print 'CHILD: Setting up signal handler'
    signal.signal(signal.SIGUSR1, signal@_usr1)
    print 'CHILD: Pausing to wait for signal'
    time.sleep(5)
\end{Verbatim}

当然，在实际的程序中,你也可能不需要(不想)调用sleep。

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_kill@_example.py
Forking...
PARENT: Pausing before sending signal...
CHILD: Setting up signal handler
CHILD: Pausing to wait for signal
PARENT: Signaling 6053
Received USR1 in process 6053
\end{Verbatim}

正如你所看到的, 一个简单的处理子进程各自行为的方式是简单 \code{fork()} 函数的返回值并使用if分支实现. 对于更复杂的行为, 就需要更多的分离(独立)的代码,而不是简单的分支. 在其他的例子中,你可以使用一个已经封装好的程序. 对于这两种情况,你可以使用 \code{os.exec*()} 系列函数来运行其他程序. 当你''exec''一个程序, 程序中的代码会代替你进程中已存在的那些代码.

\begin{Verbatim}[commandchars=@\[\]]
child@_pid @PYGbe[=] os@PYGbe[.]fork()
@PYGay[if] child@_pid:
    os@PYGbe[.]waitpid(child@_pid, @PYGaw[0])
@PYGay[else]:
    os@PYGbe[.]execlp(@PYGad[']@PYGad[ls]@PYGad['], @PYGad[']@PYGad[ls]@PYGad['], @PYGad[']@PYGad[-l]@PYGad['], @PYGad[']@PYGad[/tmp/]@PYGad[']) @PYGaD[@#@# 执行多个子进程]
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_exec@_example.py

total 40
drwxr-xr-x 2 dhellman wheel 68 Jun 17 14:35 527
prw------- 1 root wheel 0 Jun 15 19:24 afpserver@_PIPE
drwx------ 3 dhellman wheel 102 Jun 17 12:13 emacs527
drwxr-xr-x 2 dhellman wheel 68 Jun 16 05:01 hsperfdata@_dhellmann
-rw------- 1 nobody wheel 12 Jun 17 13:55 objc@_sharing@_ppc@_4294967294
-rw------- 1 dhellman wheel 144 Jun 17 14:32 objc@_sharing@_ppc@_527
-rw------- 1 security wheel 24 Jun 17 07:09 objc@_sharing@_ppc@_92
drwxr-xr-x 4 dhellman dhellman 136 Jun 8 03:16 var@_backups
\end{Verbatim}

有很多 \code{exec*()} 的变种, 它们依赖于你可能使用的参数, 如,你是否想要路径和父进程的环境变量都被复制到子进程中,等等. 细节可参见库文档.

对于所有变种, 它们的第一个参数是一个路径或者文件名, 剩下的参数控制如何运行相应程序. 它们要么作为命令行参数被传递, 要么覆盖进程''环境''(可查看 \code{os.environ} 和 \code{os.getenv} ).


\section{等待一个子进程}

假设说你使用了多个进程来突破Python的线程限制和 \code{GIL}.如果你开始了多个进程来运行各自的任务, 你希望在开始新的进程之前等待其中一个或多个的结束, 以此来避免服务器的超载. 这里有一些使用 \code{wait()} 和相关函数来实现它的不同方法.

如果你不关心, 或者你已经知道, 哪个可能会首先退出 \code{os.wait()} 的子进程,并且这个子进程会尽快的返回任何存在:

\begin{Verbatim}[commandchars=@\[\]]
import os
import sys
import time

for i in range(3):
    print 'PARENT: Forking @%s' @% i
    worker@_pid = os.fork()
    if not worker@_pid:
        print 'WORKER @%s: Starting' @% i
        time.sleep(2 + i)
        print 'WORKER @%s: Finishing' @% i
        sys.exit(i)

 for i in range(3):
     print 'PARENT: Waiting for @%s' @% i
     done = os.wait()
     print 'PARENT:', done
\end{Verbatim}

\begin{notice}{note}{Note:}
\code{os.wait()} 的返回值是包含进程号和退出状态(一个16位的数字, 它的低字节是一个杀死该进程的信号数字, 它的高字节是退出状态)的一个元组.
\end{notice}

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_wait@_example.py

PARENT: Forking 0
PARENT: Forking 1
PARENT: Forking 2
PARENT: Waiting for 0
WORKER 0: Starting
WORKER 1: Starting
WORKER 2: Starting
WORKER 0: Finishing
PARENT: (6501, 0)
PARENT: Waiting for 1
WORKER 1: Finishing
PARENT: (6502, 256)
PARENT: Waiting for 2
WORKER 2: Finishing
PARENT: (6503, 512)
\end{Verbatim}

如果你想等待一个特定的进程, 可以使用 \code{os.waitpid()} .

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[import] @PYGaV[sys]
@PYGay[import] @PYGaV[time]

workers @PYGbe[=] @lb[]@rb[]
@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[3]):
    @PYGay[print] @PYGad[']@PYGad[PARENT: Forking ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] i
    worker@_pid @PYGbe[=] os@PYGbe[.]fork()
    @PYGay[if] @PYGan[not] worker@_pid:
        @PYGay[print] @PYGad[']@PYGad[WORKER ]@PYGbf[@%s]@PYGad[: Starting]@PYGad['] @PYGbe[@%] i
        time@PYGbe[.]sleep(@PYGaw[2] @PYGbe[+] i)
        @PYGay[print] @PYGad[']@PYGad[WORKER ]@PYGbf[@%s]@PYGad[: Finishing]@PYGad['] @PYGbe[@%] i
        sys@PYGbe[.]exit(i)
    workers@PYGbe[.]append(worker@_pid)

@PYGay[for] pid @PYGan[in] workers:
    @PYGay[print] @PYGad[']@PYGad[PARENT: Waiting for ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] pid
    done @PYGbe[=] os@PYGbe[.]waitpid(pid, @PYGaw[0])
    @PYGay[print] @PYGad[']@PYGad[PARENT:]@PYGad['], done
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_waitpid@_example.py
PARENT: Forking 0
WORKER 0: Starting
PARENT: Forking 1
WORKER 1: Starting
PARENT: Forking 2
WORKER 2: Starting
PARENT: Waiting for 6547
WORKER 0: Finishing
PARENT: (6547, 0)
PARENT: Waiting for 6548
WORKER 1: Finishing
PARENT: (6548, 256)
PARENT: Waiting for 6549
WORKER 2: Finishing
PARENT: (6549, 512)
\end{Verbatim}

\code{wait3()} 和 \code{wait4()} 函数也是类似的方式, 但它们返回更多关于子进程的细节信息,如进程号, 退出状态, 资源使用情况等.


\section{Spawn（孵化）}

方便起见, \code{os.spawn*()} 系列函数将 \code{fork()} 和 \code{exec*()} 调用写在一条语句中:

\begin{Verbatim}[commandchars=@\[\]]
os@PYGbe[.]spawnlp(os@PYGbe[.]P@_WAIT, @PYGad[']@PYGad[ls]@PYGad['], @PYGad[']@PYGad[ls]@PYGad['], @PYGad[']@PYGad[-l]@PYGad['], @PYGad[']@PYGad[/tmp/]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python os@_exec@_example.py
total 40
drwxr-xr-x 2 dhellman wheel 68 Jun 17 14:35 527
prw------- 1 root wheel 0 Jun 15 19:24 afpserver@_PIPE
drwx------ 3 dhellman wheel 102 Jun 17 12:13 emacs527
drwxr-xr-x 2 dhellman wheel 68 Jun 16 05:01 hsperfdata@_dhellmann
-rw------- 1 nobody wheel 12 Jun 17 13:55 objc@_sharing@_ppc@_4294967294
-rw------- 1 dhellman wheel 144 Jun 17 14:32 objc@_sharing@_ppc@_527
-rw------- 1 security wheel 24 Jun 17 07:09 objc@_sharing@_ppc@_92
drwxr-xr-x 4 dhellman dhellman 136 Jun 8 03:16 var@_backups
\end{Verbatim}


\section{结论}

还有其他很多在处理多进程时需要考虑的东西,比如,信号处理, 多进程文件读写等.所有这些话题都在参考书目(如 \href{http://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0201433079/ref=pd\_bbs\_3/002-2842372-4768037?ie=UTF8\&s=books\&amp;qid=1182098757\&sr=8-3}{Advanced Programming in the UNIX(R) Environment} )中有讲述.


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.ibm.com/developerworks/aix/library/au-unixprocess.html}{Delve into UNIX process creation}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: pickle \& cPickle}

Python对象序列化
\begin{itemize}
\item {} 
模块：pickle 和 cPickle

\item {} 
目的: Python对象序列化

\item {} 
python版本：pickle至少1.4, cPickle 至少1.5

\end{itemize}


\section{描述}

pickle模块可以实现任意的Python对象转换为一系列字节(即序列化对象)的算法。这些字节流可以被传输或存储，接着也可以重构为一个和原先对象具有相同特征的新对象。

cPickle模块实现了同样的算法，但它是用c而不是python。因此，它比python实现的快上好几倍，但是不允许使用者去继承Pickle。如果继承对于你的使用不是很重要，那么你大可以使用cPickle。

\begin{notice}{note}{Note:}
pickle的文档清晰的表明它不提供安全保证。所以慎用pickle来作为内部进程通信或者数据存储，也不要相信那些你不能验证安全性的数据。
\end{notice}


\section{例子}

第一个pickle示例是将一个数据结构编码为一个字符串，然后将其输出到控制台。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[try]:
   @PYGay[import] @PYGaV[cPickle] @PYGay[as] @PYGaV[pickle]
@PYGay[except]:
   @PYGay[import] @PYGaV[pickle]
   @PYGay[import] @PYGaV[pprint]
\end{Verbatim}

我们首先尝试导入cPickle，并指定别名为''pickle''。如果因为某种原因导入pickle失败，我们则导入由Python实现的pickle模块。如果cPickle是可用的，会给我们带来更快的实现，但如果不可用，也会有正确的实现。

接下来，我们定义一个完全由基本类型组成的数据结构。任何类的实例都可被pickle，这会在下一个例子中表述。我选择基本数据类型以便更简单的示范。

\begin{Verbatim}[commandchars=@\[\]]
data @PYGbe[=] @lb[] { @PYGad[']@PYGad[a]@PYGad[']:@PYGad[']@PYGad[A]@PYGad['], @PYGad[']@PYGad[b]@PYGad[']:@PYGaw[2], @PYGad[']@PYGad[c]@PYGad[']:@PYGaw[3.0] } @rb[]
@PYGay[print] @PYGad[']@PYGad[DATA:]@PYGad['],
pprint@PYGbe[.]pprint(data)
\end{Verbatim}

现在我们就可以使用pickle.dumps()来创建数据值的字符串表示。

\begin{Verbatim}[commandchars=@\[\]]
data@_string @PYGbe[=] pickle@PYGbe[.]dumps(data)
@PYGay[print] @PYGad[']@PYGad[PICKLE:]@PYGad['], data@_string
\end{Verbatim}

默认情况下，pickle仅使用ASCII字符。也可以使用高效的二进制格式。但这些示例依然使用了ASCII格式 。

\begin{Verbatim}[commandchars=@\[\]]
@$ python pickle@_string.py
DATA:@PYGZlb[]{'a': 'A', 'b': 2, 'c': 3.0}@PYGZrb[]
PICKLE: (lp1
(dp2
S'a'
S'A'
sS'c'
F3
sS'b'
I2
sa.
\end{Verbatim}

一旦数据被序列化，你就可以把他写入到文件、socket、管道等等中。之后你可以读取这个文件，unpickle这些数据来构造具有相同值的新对象。

\begin{Verbatim}[commandchars=@\[\]]
data1 @PYGbe[=] @lb[] { @PYGad[']@PYGad[a]@PYGad[']:@PYGad[']@PYGad[A]@PYGad['], @PYGad[']@PYGad[b]@PYGad[']:@PYGaw[2], @PYGad[']@PYGad[c]@PYGad[']:@PYGaw[3.0] } @rb[]
@PYGay[print] @PYGad[']@PYGad[BEFORE:]@PYGad['],
pprint@PYGbe[.]pprint(data1)

data1@_string @PYGbe[=] pickle@PYGbe[.]dumps(data1)

data2 @PYGbe[=] pickle@PYGbe[.]loads(data1@_string)
@PYGay[print] @PYGad[']@PYGad[AFTER:]@PYGad['],
pprint@PYGbe[.]pprint(data2)

@PYGay[print] @PYGad[']@PYGad[SAME?:]@PYGad['], (data1 @PYGan[is] data2)
@PYGay[print] @PYGad[']@PYGad[EQUAL?:]@PYGad['], (data1 @PYGbe[==] data2)
\end{Verbatim}

正像你看到的那样，新构造的对象等于原来的对象，但他们又不是相同的对象。这里不足为奇。

\begin{Verbatim}[commandchars=@\[\]]
@$ python pickle@_unpickle.py
BEFORE:@PYGZlb[]{'a': 'A', 'b': 2, 'c': 3.0}@PYGZrb[]
AFTER:@PYGZlb[]{'a': 'A', 'b': 2, 'c': 3.0}@PYGZrb[]
SAME?: False
EQUAL?: True
\end{Verbatim}

pickle除了提供dumps()和loads()，还提供非常方便的函数用于操作类文件流。支持同时写多个对象到同一个流中，然后在不知道有多少个对象或不知道它们有多大时，能够从这个流中读取多个对象也是可能的，

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[try]:
   @PYGay[import] @PYGaV[cPickle] @PYGay[as] @PYGaV[pickle]
@PYGay[except]:
   @PYGay[import] @PYGaV[pickle]
@PYGay[import] @PYGaV[pprint]
@PYGay[from] @PYGaV[StringIO] @PYGay[import] StringIO

@PYGay[class] @PYGaN[SimpleObject](@PYGaX[object]):

   @PYGay[def] @PYGaK[@_@_init@_@_](@PYGaA[self], name):
      @PYGaA[self]@PYGbe[.]name @PYGbe[=] name
      l @PYGbe[=] @PYGaX[list](name)
      l@PYGbe[.]reverse()
      @PYGaA[self]@PYGbe[.]name@_backwards @PYGbe[=] @PYGad[']@PYGad[']@PYGbe[.]join(l)
      @PYGay[return]

data @PYGbe[=] @lb[]@rb[]
data@PYGbe[.]append(SimpleObject(@PYGad[']@PYGad[pickle]@PYGad[']))
data@PYGbe[.]append(SimpleObject(@PYGad[']@PYGad[cPickle]@PYGad[']))
data@PYGbe[.]append(SimpleObject(@PYGad[']@PYGad[last]@PYGad[']))

@PYGaD[@# Simulate a file with StringIO]
out@_s @PYGbe[=] StringIO()

@PYGaD[@# Write to the stream]
@PYGay[for] o @PYGan[in] data:
   @PYGay[print] @PYGad[']@PYGad[WRITING: ]@PYGbf[@%s]@PYGad[ (]@PYGbf[@%s]@PYGad[)]@PYGad['] @PYGbe[@%] (o@PYGbe[.]name, o@PYGbe[.]name@_backwards)
   pickle@PYGbe[.]dump(o, out@_s)
   out@_s@PYGbe[.]flush()

@PYGaD[@# Set up a read-able stream]
in@_s @PYGbe[=] StringIO(out@_s@PYGbe[.]getvalue())

@PYGaD[@# Read the data]
@PYGay[while] @PYGaA[True]:
   @PYGay[try]:
      o @PYGbe[=] pickle@PYGbe[.]load(in@_s)
   @PYGay[except] @PYGaU[EOFError]:
      @PYGay[break]
   @PYGay[else]:
      @PYGay[print] @PYGad[']@PYGad[READ: ]@PYGbf[@%s]@PYGad[ (]@PYGbf[@%s]@PYGad[)]@PYGad['] @PYGbe[@%] (o@PYGbe[.]name, o@PYGbe[.]name@_backwards)
\end{Verbatim}

这个例子使用StringIO缓冲区来模拟流，因此我们在建立可读流时得玩点小花样。一个简单数据库格式也可以使用pickle来存储对象，虽然使用shelve模块可能会更简单。

\begin{Verbatim}[commandchars=@\[\]]
@$ python pickle@_stream.py
WRITING: pickle (elkcip)
WRITING: cPickle (elkciPc)
WRITING: last (tsal)
READ: pickle (elkcip)
READ: cPickle (elkciPc)
READ: last (tsal)
\end{Verbatim}

除了用于存储数据，pickle在用于内部进程通信时是非常灵活的。比如，使用os.fork()和os.pipe()，可以建立一些工作进程，它们从一个管道中读取任务说明并把结果输出到另一个管道。操作这些工作池、发送任务和接受反应的核心代码可以重复利用，因为任务和反应对象不是一个特殊的类。如果你使用管道或者sockets，就不要忘记在dump每个对象后刷新它们并通过其间的连接将数据推送到另外一个进程。

在处理自定义类时，你应该保证这些被pickled的类会在进程名空间出现 。只有数据实例才能被pickle，而不能是定义的类。在unpickle时，类的名字被用于寻找构造器以便创建新对象。接下来这个例子，是将一个类实例写入到文件中：

\begin{Verbatim}[commandchars=@\[\]]
try:
   import cPickle as pickle
except:
   import pickle
   import sys

class SimpleObject(object):

   def @_@_init@_@_(self, name):
      self.name = name
      l = list(name)
      l.reverse()
      self.name@_backwards = ''.join(l)
      return

if @_@_name@_@_ == '@_@_main@_@_':
   data = @PYGZlb[]@PYGZrb[]
   data.append(SimpleObject('pickle'))
   data.append(SimpleObject('cPickle'))
   data.append(SimpleObject('last'))
   try:
      filename = sys.argv@PYGZlb[]1@PYGZrb[]
      except IndexError:
      raise RuntimeError('Please specify a filename as an argument to @%s' @% sys.argv@PYGZlb[]0@PYGZrb[])
   out@_s = open(filename, 'wb')
   try:
      @# Write to the stream
      for o in data:
         print 'WRITING: @%s (@%s)' @% (o.name, o.name@_backwards)
         pickle.dump(o, out@_s)
   finally:
      out@_s.close()
\end{Verbatim}

当我运行这个脚本时，它会创建名为我在命令行中输入的参数的文件：

\begin{Verbatim}[commandchars=@\[\]]
@$ python pickle@_dump@_to@_file@_1.py test.dat
WRITING: pickle (elkcip)
WRITING: cPickle (elkciPc)
WRITING: last (tsal)
\end{Verbatim}

一个简单的尝试将刚才的pickle结果对象装载进来可以是如下的样子：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[try]:
   @PYGay[import] @PYGaV[cPickle] @PYGay[as] @PYGaV[pickle]
@PYGay[except]:
   @PYGay[import] @PYGaV[pickle]
@PYGay[import] @PYGaV[pprint]
@PYGay[from] @PYGaV[StringIO] @PYGay[import] StringIO
@PYGay[import] @PYGaV[sys]

@PYGay[try]:
   filename @PYGbe[=] sys@PYGbe[.]argv@lb[]@PYGaw[1]@rb[]
@PYGay[except] @PYGaU[IndexError]:
   @PYGay[raise] @PYGaU[RuntimeError](@PYGad[']@PYGad[Please specify a filename as an argument to ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] sys@PYGbe[.]argv@lb[]@PYGaw[0]@rb[])

in@_s @PYGbe[=] @PYGaX[open](filename, @PYGad[']@PYGad[rb]@PYGad['])
@PYGay[try]:
   @PYGaD[@# Read the data]
   @PYGay[while] @PYGaA[True]:
      @PYGay[try]:
         o @PYGbe[=] pickle@PYGbe[.]load(in@_s)
      @PYGay[except] @PYGaU[EOFError]:
         @PYGay[break]
      @PYGay[else]:
         @PYGay[print] @PYGad[']@PYGad[READ: ]@PYGbf[@%s]@PYGad[ (]@PYGbf[@%s]@PYGad[)]@PYGad['] @PYGbe[@%] (o@PYGbe[.]name, o@PYGbe[.]name@_backwards)
@PYGay[finally]:
   in@_s@PYGbe[.]close()
\end{Verbatim}

这个版本失败了，因为这里没有可用的SimpleObject类

\begin{Verbatim}[commandchars=@\[\]]
@$ python pickle@_load@_from@_file@_1.py test.dat
Traceback (most recent call last):
File "pickle@_load@_from@_file@_1.py", line 52, in
   o = pickle.load(in@_s)
AttributeError: 'module' object has no attribute 'SimpleObject'
\end{Verbatim}

一个正确版本，它从pickle\_dump\_to\_file\_1导入了SimpleObject类，可以成功运行。
增加：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[pickle@_dump@_to@_file@_1] @PYGay[import] SimpleObject
\end{Verbatim}

到导入列表的最后，然后运行这个脚本：

\begin{Verbatim}[commandchars=@\[\]]
@$ python pickle@_load@_from@_file@_2.py test.dat
READ: pickle (elkcip)
READ: cPickle (elkciPc)
READ: last (tsal)
\end{Verbatim}

在pickle那些不能被pickle的数据(如sockets、文件句柄、数据库连接等等)时，需要考虑一些特殊之处。那些不能被pickle的类可以定义 \_\_getstate\_\_() 和 \_\_setstate\_\_() 来返回实例在被pickle时的状态。新风格的类也可以定义\_\_getnewargs\_\_()，它返回传递给类内存分配者 (C.\_\_new\_\_())的参数。关于这些特征的更详细的使用描述可以在标准库文档中找到。


\section{参考}
\begin{itemize}
\item {} 
\href{http://peadrop.com/blog/2007/06/18/pickle-an-interesting-stack-language/}{Pickle: An interesting stack language by Alexandre Vassalotti}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: glob}
\begin{itemize}
\item {} 
模块： glob

\item {} 
目的： 使用Unix Shell规则来寻找文件名匹配某一模式的文件。

\item {} 
python版本： 1.4+

\end{itemize}


\section{描述}

即使glob API非常简单，但这个模块具有强大的力量。在很多情况下，尤其是你的程序需要寻找出文件系统中，文件名匹配特定模式的文件时，是非常有用的。如果你需要包含一个特定扩展名，或前缀，或含有任何普通字符串的文件列表，可以直接使用glob代替手工编程扫描目录内容。

glob中模式规则不是正则表达式，而是，符合标准Uinx路径扩展规则。但是Shell变量名和符号(\textasciitilde{})是不被扩充的，只有一些特殊的字符：两个不同的通配符和字母范围被支持。模块规则适合于文件名的片段(以/为分隔)，但模式中的路径可以是相对或者绝对路径。


\section{示例数据}

假设当前工作目录下包含有以下一些文件。

\begin{Verbatim}[commandchars=@\[\]]
dir/
dir/file.txt
dir/file1.txt
dir/file2.txt
dir/filea.txt
dir/fileb.txt
dir/subdir/
dir/subdir/subfile.txt
\end{Verbatim}

使用glob\_maketestdata.py脚本可以创建这些文件。


\section{通配符}

\code{*} 匹配名字片段中的0个或多个字符，例如，dir/\code{*} 。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[glob]
@PYGay[print] glob@PYGbe[.]glob(@PYGad[']@PYGad[dir/*]@PYGad['])
\end{Verbatim}

这个模式匹配在目录dir中的任何文件或子目录，但没有进一步递归匹配子目录。

\begin{Verbatim}[commandchars=@\[\]]
@$ python glob@_asterisk.py
@PYGZlb[]'dir/file.txt', 'dir/file1.txt', 'dir/file2.txt',
'dir/filea.txt', 'dir/fileb.txt', 'dir/subdir'@PYGZrb[]
\end{Verbatim}

如果要列出子目录中的文件，你应该在模式中包含相应子目录：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGad[Named explicitly:]@PYGad[']
@PYGay[print] glob@PYGbe[.]glob(@PYGad[']@PYGad[dir/subdir/*]@PYGad['])

@PYGay[print] @PYGad[']@PYGad[Named with wildcard:]@PYGad[']
@PYGay[print] glob@PYGbe[.]glob(@PYGad[']@PYGad[dir/*/*]@PYGad['])
\end{Verbatim}

上面的第一个例子直接列出了指定子目录名的文件，而第二个例子则依赖于通配符来寻找子目录。

\begin{Verbatim}[commandchars=@\[\]]
@$ python glob@_subdir.py
Named explicitly:
@PYGZlb[]'dir/subdir/subfile.txt'@PYGZrb[]
Named with wildcard:
@PYGZlb[]'dir/subdir/subfile.txt'@PYGZrb[]
\end{Verbatim}

在这个例子中，结果是一样的。如果还有其他的子目录，那么，通配符匹配所有子目录及其他们中包含的文件。


\section{单一字符通配符}

其他的被支持的通配符是问号(?)。它匹配在对应位置的任一单个字符。例如：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] glob@PYGbe[.]glob(@PYGad[']@PYGad[dir/file?.txt]@PYGad['])
\end{Verbatim}

匹配所有以''file''开头，之后包含一个任何字符并以''.txt''结尾的文件。

\begin{Verbatim}[commandchars=@\[\]]
@$ python glob@_question.py
@PYGZlb[]'dir/file1.txt', 'dir/file2.txt',
'dir/filea.txt', 'dir/fileb.txt'@PYGZrb[]
\end{Verbatim}


\section{字符范围}

当你需要匹配一个特定字符时，可以使用一个字符范围来替代问号。例如，为了找到所有文件名中在扩展名之前包含数字的文件时：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] glob@PYGbe[.]glob(@PYGad[']@PYGad[dir/*@lb[]0-9@rb[].*]@PYGad['])
\end{Verbatim}

字符范围{[}0-9{]}匹配任何单一数字。这个范围是基于每个字符/数字的字符编码顺序，破折号(-)表示一个范围。上面的范围也可直接用{[}0123456789{]}来表示。

\begin{Verbatim}[commandchars=@\[\]]
@$ python glob@_charrange.py
@PYGZlb[]'dir/file1.txt', 'dir/file2.txt'@PYGZrb[]
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.opengroup.org/onlinepubs/000095399/utilities/xcu\_chap02.html\#tag\_02\_13}{Pattern Matching Notation}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: shelve}
\begin{itemize}
\item {} 
模块：shelve

\item {} 
目的：shelve模块实现了对任意可被pickle的Python对象进行持久性存储，也提供类字典API给我们使用。

\item {} 
python版本：1.4+

\end{itemize}


\section{描述}

当使用关系数据库是一种浪费的时候，shelve模块可以为Python对象提供一个简单的持久性存储选择。就像使用字典一样，通过关键字访问shelf对象。其值经过pickle，写入到由anydbm创建和管理的数据库。


\section{创建一Shelf对象}

最简单的使用shelve模块的方式是通过DbfilenameShelf类。 使用函数 \code{shelve.open()} （使用的是 \href{http://docs.python.org/lib/module-anydbm.html}{anydbm} ）来存储数据。你可以直接使用类，或者简单的调用：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[shelve]

s @PYGbe[=] shelve@PYGbe[.]open(@PYGad[']@PYGad[test@_shelf.db]@PYGad['])
@PYGay[try]:
    s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[] @PYGbe[=] { @PYGad[']@PYGad[int]@PYGad[']: @PYGaw[10], @PYGad[']@PYGad[float]@PYGad[']:@PYGaw[9.5], @PYGad[']@PYGad[string]@PYGad[']:@PYGad[']@PYGad[Sample data]@PYGad['] }
@PYGay[finally]:
    s@PYGbe[.]close()
\end{Verbatim}

为了再次访问数据，打开shelf并且像字典一样使用它。

\begin{Verbatim}[commandchars=@\[\]]
s @PYGbe[=] shelve@PYGbe[.]open(@PYGad[']@PYGad[test@_shelf.db]@PYGad['])
@PYGay[try]:
    existing @PYGbe[=] s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]
@PYGay[finally]:
    s@PYGbe[.]close()

@PYGay[print] existing
\end{Verbatim}

如果你运行了上面两个脚本，你应该看到：

\begin{Verbatim}[commandchars=@\[\]]
@$ python shelve@_create.py
@$ python shelve@_existing.py
{'int': 10, 'float': 9.5, 'string': 'Sample data'}
\end{Verbatim}

dbm模块不支持多个应用同时写入同一数据库。如果你确定客户端不会修改shelf， 请指定shelve以只读方式打开数据库。

\begin{Verbatim}[commandchars=@\[\]]
s @PYGbe[=] shelve@PYGbe[.]open(@PYGad[']@PYGad[test@_shelf.db]@PYGad['], flag@PYGbe[=]@PYGad[']@PYGad[r]@PYGad['])
@PYGay[try]:
    existing @PYGbe[=] s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]
@PYGay[finally]:
    s@PYGbe[.]close()

@PYGay[print] existing
\end{Verbatim}

当数据库以只读方式打开时，你又尝试着更改数据库，这将引起一个访问出错异常。这一异常类型依赖于在创建数据库时被anydbm选择的数据库模块。


\section{写回}

默认情况下，Shelves不去追踪可变对象的修改。意思就是，如果你改变了已存储在shelf中的一个项目的内容，就必须重新存储该项目来更新shelf。

\begin{Verbatim}[commandchars=@\[\]]
s @PYGbe[=] shelve@PYGbe[.]open(@PYGad[']@PYGad[test@_shelf.db]@PYGad['])
@PYGay[try]:
    @PYGay[print] s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]
    s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]@lb[]@PYGad[']@PYGad[new@_value]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[this was not here before]@PYGad[']
@PYGay[finally]:
    s@PYGbe[.]close()

s @PYGbe[=] shelve@PYGbe[.]open(@PYGad[']@PYGad[test@_shelf.db]@PYGad['], writeback@PYGbe[=]@PYGaA[True])
@PYGay[try]:
    @PYGay[print] s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]
@PYGay[finally]:
    s@PYGbe[.]close()
\end{Verbatim}

在这个例子中，没有对字典里的关键字''key1''的内容进行存储，因此，重新打开shelf的时候，还没保存所做的改变。

\begin{Verbatim}[commandchars=@\[\]]
@$ python shelve@_create.py
@$ python shelve@_withoutwriteback.py
{'int': 10, 'float': 9.5, 'string': 'Sample data'}
{'int': 10, 'float': 9.5, 'string': 'Sample data'}
\end{Verbatim}

为了自动捕捉储存在shelf中的可变对象所发生的改变，置writeback功能可用。writeback标志导致shelf使用一缓存来记住从数据库中调出的所有对象 。当shelf关闭的时候，每一个缓存中的对象也重新写入数据库。

\begin{Verbatim}[commandchars=@\[\]]
s @PYGbe[=] shelve@PYGbe[.]open(@PYGad[']@PYGad[test@_shelf.db]@PYGad['], writeback@PYGbe[=]@PYGaA[True])
@PYGay[try]:
    @PYGay[print] s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]
    s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]@lb[]@PYGad[']@PYGad[new@_value]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[this was not here before]@PYGad[']
    @PYGay[print] s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]
@PYGay[finally]:
    s@PYGbe[.]close()

s @PYGbe[=] shelve@PYGbe[.]open(@PYGad[']@PYGad[test@_shelf.db]@PYGad['], writeback@PYGbe[=]@PYGaA[True])
@PYGay[try]:
    @PYGay[print] s@lb[]@PYGad[']@PYGad[key1]@PYGad[']@rb[]
@PYGay[finally]:
    s@PYGbe[.]close()
\end{Verbatim}

虽然使用writeback模式可以减少程序员出错机率，也能更加透明化对象持久性，但是，不是每种情况都要使用writeback 模式的。当shelf打开的时候，缓存就要占据额外的空间，并且，当shelf关闭的时候，也会花费额外的时间去将所有缓存中的对象写入到数据库中。即使不知道缓存中的对象有没有改变，都要写回数据库。如果你的应用程序读取数据多于写入数据，那么writeback模式将增大开销。

\begin{Verbatim}[commandchars=@\[\]]
@$ python shelve@_create.py
@$ python shelve@_writeback.py
{'int': 10, 'float': 9.5, 'string': 'Sample data'}
{'int': 10, 'new@_value': 'this was not here before', 'float': 9.5, 'string': 'Sample data'}
{'int': 10, 'new@_value': 'this was not here before', 'float': 9.5, 'string': 'Sample data'}
\end{Verbatim}


\section{指定Shelf类型}

上面的例子全都使用了默认的shelf实现。使用 \code{shelve.open()} 直接代替一种shelf实现，是常见用法，尤其是在不关心用哪种数据库存储数据的时候。然而，有时常会关心它。如果是在这种情况下，通常就会直接使用DbfilenameShelf或者BsdDbShelf ，更或者是通过Shelf的子类来解决问题。


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.doughellmann.com/projects/feedcache/}{feedcache uses shelve as a default storage option}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: optparse}
\begin{itemize}
\item {} 
模块：optparse

\item {} 
目的：命令行参数解析，可以取代getopt

\item {} 
python版本：2.3

\end{itemize}


\section{描述}

optparse是一个当前可选的命令行解析模块，它提供了一些在getopt中不含有的特性，如type conversion(类型转换)，option callbacks(参数回调)以及automatice help generation(自动化帮助生成)。本文没有详细介绍optparse的很多特性，但它可以帮助你在写命令行程序时能够快速入门。


\section{创建一个OptionParser}

optparser解析参数需要经过2个阶段。首先，构建OptionParser实例并配置相关的选项，然后填入一个参数序列并处理。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[optparse]
parser @PYGbe[=] optparse@PYGbe[.]OptionParser()
\end{Verbatim}

通常，一旦分析器被建立，每一个选项需要明确的添加到parser中，并说明当命令行遇到相关的选项时需要如何处理。在构建OptionParser时也可以传入一个选项列表，但这种形式不经常使用。


\section{定义选项}

利用add\_option()方法可以每次增加一个选项。在参数列表的开始，任何未命名的字符串参数都将被视为选项名。如果要为一个选项创建别名，比如为同一个选项增加一个短的或长的命名，那么简单传递同名字符串即可。

不同于getopt，只能分析选项，optparse是一个完整的选项分析库，Option(选项)可以被不同的方法处理，通过在add\_option()方法中指定action(行为)参数。支持的行为包括存储参数(单独或作为列表的一部分)，当一个选项出现时(包括对布尔开关true/false的特殊处理)存储其常量值，计算一个选项出现的次数以及调用一个callback(回调函数)。

默认的行为是存储这个选项的参数。如果给定了type(类型)，那么在存储前，这个参数值将被转化成这个类型。如果给定了dest(目标参数)，那么当命令行参数被解析时，选项值被存储在该选项对象的dest中。


\section{分析一个命令行}

一旦所有的选项被定义好，命令行被作为一个参数字符串传递给parse\_args()方法。一般，参数可以从sys.argv{[}1:{]}中得到，当然你可以传递自己的列表。选项处理时使用GNU/POSIX语法，因此，选项和参数值可以在参数序列中混合使用。

从parse\_args()方法返回的是一个二维元组，包含一个optparse Values实例和在命令行中未被解析的参数列表。Values实例将选项值作为属性，如果你定义了一个选项的dest为“myoption”，可以通过 option.myoption访问该选项的值。


\section{简单示例}

如下一个简单例子有三个不同的选项，一个布尔选项(-a)，一个字符串选项(-b)和一个整型选项(-c)。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[optparse]
parser @PYGbe[=] optparse@PYGbe[.]OptionParser()
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[-a]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store@_true]@PYGad["], default@PYGbe[=]@PYGaA[False])
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[-b]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store]@PYGad["], dest@PYGbe[=]@PYGad["]@PYGad[b]@PYGad["])
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[-c]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store]@PYGad["], dest@PYGbe[=]@PYGad["]@PYGad[c]@PYGad["], @PYGaX[type]@PYGbe[=]@PYGad["]@PYGad[int]@PYGad["])
@PYGay[print] parser@PYGbe[.]parse@_args(@lb[]@PYGad[']@PYGad[-a]@PYGad['], @PYGad[']@PYGad[-bval]@PYGad['], @PYGad[']@PYGad[-c]@PYGad['], @PYGad[']@PYGad[3]@PYGad[']@rb[])
\end{Verbatim}

命令行中选项解析的规则和getopt.gnu\_getopt()一样，因此有两种方法传递单字符串选项的值，上述示例使用了两种方法-bval和-c val

\begin{Verbatim}[commandchars=@\[\]]
@$ python optparse@_short.py
(@textless[]Values at 0xe29b8: {'a': True, 'c': 3, 'b': 'val'}@textgreater[], @PYGZlb[]@PYGZrb[])
\end{Verbatim}

注意，c所关联的值的类型是整型，OptionParser在存储之前会转换成指定类型。不同于getopt，optparse处理长选项名时和短选项名是没有任何区别的。

\begin{Verbatim}[commandchars=@\[\]]
parser @PYGbe[=] optparse@PYGbe[.]OptionParser()
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--noarg]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store@_true]@PYGad["], default@PYGbe[=]@PYGaA[False])
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--witharg]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store]@PYGad["], dest@PYGbe[=]@PYGad["]@PYGad[witharg]@PYGad["])
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--witharg2]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store]@PYGad["], dest@PYGbe[=]@PYGad["]@PYGad[witharg2]@PYGad["], @PYGaX[type]@PYGbe[=]@PYGad["]@PYGad[int]@PYGad["])
@PYGay[print] parser@PYGbe[.]parse@_args(@lb[] @PYGad[']@PYGad[--noarg]@PYGad['], @PYGad[']@PYGad[--witharg]@PYGad['], @PYGad[']@PYGad[val]@PYGad['], @PYGad[']@PYGad[--witharg2=3]@PYGad['] @rb[])
\end{Verbatim}

结果相同的：

\begin{Verbatim}[commandchars=@\[\]]
@$ python optparse@_long.py
(@textless[]Values at 0xd3ad0: {'noarg': True, 'witharg': 'val', 'witharg2': 3}@textgreater[], @PYGZlb[]@PYGZrb[])
\end{Verbatim}


\section{与getopt的比较}

如下实现一个与getopt之前示例相同功能的optparse例子

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[optparse]
@PYGay[import] @PYGaV[sys]
@PYGay[print] @PYGad[']@PYGad[ARGV      :]@PYGad['], sys@PYGbe[.]argv@lb[]@PYGaw[1]:@rb[]
parser @PYGbe[=] optparse@PYGbe[.]OptionParser()
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[-o]@PYGad['], @PYGad[']@PYGad[--output]@PYGad['],
            dest@PYGbe[=]@PYGad["]@PYGad[output@_filename]@PYGad["],
            default@PYGbe[=]@PYGad["]@PYGad[default.out]@PYGad["],
            )
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[-v]@PYGad['], @PYGad[']@PYGad[--verbose]@PYGad['],
            dest@PYGbe[=]@PYGad["]@PYGad[verbose]@PYGad["],
            default@PYGbe[=]@PYGaA[False],
            action@PYGbe[=]@PYGad["]@PYGad[store@_true]@PYGad["],
            )
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--version]@PYGad['],
            dest@PYGbe[=]@PYGad["]@PYGad[version]@PYGad["],
            default@PYGbe[=]@PYGaw[1.0],
            @PYGaX[type]@PYGbe[=]@PYGad["]@PYGad[float]@PYGad["],
            )
options, remainder @PYGbe[=] parser@PYGbe[.]parse@_args()
@PYGay[print] @PYGad[']@PYGad[VERSION   :]@PYGad['], options@PYGbe[.]version
@PYGay[print] @PYGad[']@PYGad[VERBOSE   :]@PYGad['], options@PYGbe[.]verbose
@PYGay[print] @PYGad[']@PYGad[OUTPUT    :]@PYGad['], options@PYGbe[.]output@_filename
@PYGay[print] @PYGad[']@PYGad[REMAINING :]@PYGad['], remainder
\end{Verbatim}

注意，-o和--output选项是如何在同一时刻被定义的，命令行中可以使用任何一种选项。

\begin{Verbatim}[commandchars=@\[\]]
@$ python optparse@_getoptcomparison.py -o output.txt
ARGV      : @PYGZlb[]'-o', 'output.txt'@PYGZrb[]
VERSION   : 1.0
VERBOSE   : False
OUTPUT    : output.txt
REMAINING : @PYGZlb[]@PYGZrb[]
@$ python optparse@_getoptcomparison.py --output output.txt
ARGV      : @PYGZlb[]'--output', 'output.txt'@PYGZrb[]
VERSION   : 1.0
VERBOSE   : False
OUTPUT    : output.txt
REMAINING : @PYGZlb[]@PYGZrb[]
\end{Verbatim}

另外，长选项名的唯一前缀也可以被使用。

\begin{Verbatim}[commandchars=@\[\]]
@$ python optparse@_getoptcomparison.py --out output.txt
ARGV      : @PYGZlb[]'--out', 'output.txt'@PYGZrb[]
VERSION   : 1.0
VERBOSE   : False
OUTPUT    : output.txt
REMAINING : @PYGZlb[]@PYGZrb[]
\end{Verbatim}


\section{Option Callbacks(选项回调)}

除了直接为选项存储参数，另一种选择是定义callback function，当命令行中出现该选项时调用 ，选项的callbacks有4个参数，分别是引起callback的optparse.Option实例，命令行中的选项字符串，选项关联的参数值以及处理解析工作的optparse.OptionParser实例。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[optparse]

@PYGay[def] @PYGaK[flag@_callback](option, opt@_str, value, parser):
    @PYGay[print] @PYGad[']@PYGad[flag@_callback:]@PYGad[']
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[option:]@PYGad['], @PYGaX[repr](option)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[opt@_str:]@PYGad['], opt@_str
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[value:]@PYGad['], value
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[parser:]@PYGad['], parser
    @PYGay[return]

@PYGay[def] @PYGaK[with@_callback](option, opt@_str, value, parser):
    @PYGay[print] @PYGad[']@PYGad[with@_callback:]@PYGad[']
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[option:]@PYGad['], @PYGaX[repr](option)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[opt@_str:]@PYGad['], opt@_str
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[value:]@PYGad['], value
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[parser:]@PYGad['], parser
    @PYGay[return]

parser @PYGbe[=] optparse@PYGbe[.]OptionParser()
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--flag]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[callback]@PYGad["], callback@PYGbe[=]flag@_callback)
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--with]@PYGad['],
    action@PYGbe[=]@PYGad["]@PYGad[callback]@PYGad["],
    callback@PYGbe[=]with@_callback,
    @PYGaX[type]@PYGbe[=]@PYGad["]@PYGad[string]@PYGad["],
    help@PYGbe[=]@PYGad["]@PYGad[Include optional feature]@PYGad["])
parser@PYGbe[.]parse@_args(@lb[]@PYGad[']@PYGad[--with]@PYGad['], @PYGad[']@PYGad[foo]@PYGad['], @PYGad[']@PYGad[--flag]@PYGad[']@rb[])
\end{Verbatim}

在这个例子中，--with选项被配置成处理字符串参数(当然，其他类型也是同样支持的)。

\begin{Verbatim}[commandchars=@\[\]]
@$ python optparse@_callback.py
with@_callback:
     option: @textless[]Option at 0x78b98: --with@textgreater[]
     opt@_str: --with
     value: foo
     parser: @textless[]optparse.OptionParser instance at 0x78b48@textgreater[]
flag@_callback:
     option: @textless[]Option at 0x7c620: --flag@textgreater[]
     opt@_str: --flag
     value: None
     parser: @textless[]optparse.OptionParser instance at 0x78b48@textgreater[]
\end{Verbatim}


\section{帮助信息}

OptionParser自动为每个选项集合包含一个help选项，因此，用户在运行程序时在命令行输入--help来看介绍，帮助信息为所有选项指示它们是否需要传入一个参数，也可以通过在add\_option()中定义帮助文本来为一个选项定义更多的描述。

\begin{Verbatim}[commandchars=@\[\]]
parser @PYGbe[=] optparse@PYGbe[.]OptionParser()
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--no-foo]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store@_true]@PYGad["],
    default@PYGbe[=]@PYGaA[False],
    dest@PYGbe[=]@PYGad["]@PYGad[foo]@PYGad["],
    help@PYGbe[=]@PYGad["]@PYGad[Turn off foo]@PYGad["],
)
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--with]@PYGad['], action@PYGbe[=]@PYGad["]@PYGad[store]@PYGad["], help@PYGbe[=]@PYGad["]@PYGad[Include optional feature]@PYGad["])
parser@PYGbe[.]parse@_args()
\end{Verbatim}

选项按字母顺序显示，别名显示在同一行，当选项带有一个参数时，dest值将作为参数名字出现在help输出中，帮助信息将出现在这列中。

\begin{Verbatim}[commandchars=@\[\]]
@$ python optparse@_help.py --help
Usage: optparse@_help.py @PYGZlb[]options@PYGZrb[]

Options:
-h, --help   show this help message and exit
--no-foo     Turn off foo
--with=WITH  Include optional feature
\end{Verbatim}

利用nargs选项可以配置callbacks接收多个参数。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[with@_callback](option, opt@_str, value, parser):
    @PYGay[print] @PYGad[']@PYGad[with@_callback:]@PYGad[']
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[option:]@PYGad['], @PYGaX[repr](option)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[opt@_str:]@PYGad['], opt@_str
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[value:]@PYGad['], value
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[parser:]@PYGad['], parser
    @PYGay[return]

parser @PYGbe[=] optparse@PYGbe[.]OptionParser()
parser@PYGbe[.]add@_option(@PYGad[']@PYGad[--with]@PYGad['],
    action@PYGbe[=]@PYGad["]@PYGad[callback]@PYGad["],
    callback@PYGbe[=]with@_callback,
    @PYGaX[type]@PYGbe[=]@PYGad["]@PYGad[string]@PYGad["],
    nargs@PYGbe[=]@PYGaw[2],
    help@PYGbe[=]@PYGad["]@PYGad[Include optional feature]@PYGad["])
parser@PYGbe[.]parse@_args(@lb[]@PYGad[']@PYGad[--with]@PYGad['], @PYGad[']@PYGad[foo]@PYGad['], @PYGad[']@PYGad[bar]@PYGad[']@rb[])
\end{Verbatim}

在这个例子中，参数作为一个元组传递给callback function的value参数。

\begin{Verbatim}[commandchars=@\[\]]
@$ python optparse@_callback@_nargs.py
with@_callback:
     option: @textless[]Option at 0x7c4e0: --with@textgreater[]
     opt@_str: --with
     value: ('foo', 'bar')
     parser: @textless[]optparse.OptionParser instance at 0x78a08@textgreater[]
\end{Verbatim}

\resetcurrentobjects


\chapter{PyMOTW: shutil}
\begin{itemize}
\item {} 
模块：shutil

\item {} 
目的: 高层次的文件操作.

\item {} 
python版本：1.4+

\end{itemize}

shutil模块提供了一些高层次的文件操作,比如复制,设置权限等等.


\section{描述:}

shutil模块提供了一些用于复制和删除整个文件的函数.


\section{复制文件:}

copyfile() 将源文件内容完全复制给目标文件.如果没有写入目标文件的权限,会引起IOError.由于该函数是为了读取文件内容而打开此输入文件,而不管它的类型是什么,特殊类型的文件使用copyfile()是不能拷贝的，比如管道文件。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

@PYGay[print] @PYGad[']@PYGad[BEFORE:]@PYGad['], os@PYGbe[.]listdir(os@PYGbe[.]getcwd())
copyfile(@PYGad[']@PYGad[shutil@_copyfile.py]@PYGad['], @PYGad[']@PYGad[shutil@_copyfile.py.copy]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[AFTER:]@PYGad['], os@PYGbe[.]listdir(os@PYGbe[.]getcwd())
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_copyfile.py
BEFORE: @PYGZlb[]'@_@_init@_@_.py', 'shutil@_copyfile.py'@PYGZrb[]
AFTER: @PYGZlb[]'@_@_init@_@_.py', 'shutil@_copyfile.py', 'shutil@_copyfile.py.copy'@PYGZrb[]
\end{Verbatim}

copyfile()底层调用了copyfileobj()函数.文件名参数传递给copyfile()后,进而将此文件句柄传递给copyfileobj().第三个可选参数是一个缓冲区长度,以块读入(默认情况下,一次性读取整个文件).

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[from] @PYGaV[StringIO] @PYGay[import] StringIO
@PYGay[import] @PYGaV[sys]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

@PYGay[class] @PYGaN[VerboseStringIO](StringIO):
    @PYGay[def] @PYGaK[read](@PYGaA[self], n@PYGbe[=]@PYGbe[-]@PYGaw[1]):
       next @PYGbe[=] StringIO@PYGbe[.]read(@PYGaA[self], n)
       @PYGay[print] @PYGad[']@PYGad[read(]@PYGbf[@%d]@PYGad[) =@textgreater[]]@PYGad['] @PYGbe[@%] n, next
       @PYGay[return] next

lorem@_ipsum @PYGbe[=] @PYGad[''']@PYGad[Lorem ipsum dolor sit amet, consectetuer adipiscing elit.]
@PYGad[              Vestibulum aliquam mollis dolor. Donec vulputate nunc ut diam.]
@PYGad[              Ut rutrum mi vel sem. Vestibulum ante ipsum.]@PYGad[''']

@PYGay[print] @PYGad[']@PYGad[Default:]@PYGad[']
@PYGaX[input] @PYGbe[=] VerboseStringIO(lorem@_ipsum)
output @PYGbe[=] StringIO()
copyfileobj(@PYGaX[input], output)

@PYGay[print]

@PYGay[print] @PYGad[']@PYGad[All at once:]@PYGad[']
@PYGaX[input] @PYGbe[=] VerboseStringIO(lorem@_ipsum)
output @PYGbe[=] StringIO()
copyfileobj(@PYGaX[input], output, @PYGbe[-]@PYGaw[1])

@PYGay[print]

@PYGay[print] @PYGad[']@PYGad[Blocks of 20:]@PYGad[']
@PYGaX[input] @PYGbe[=] VerboseStringIO(lorem@_ipsum)
output @PYGbe[=] StringIO()
copyfileobj(@PYGaX[input], output, @PYGaw[20])
\end{Verbatim}

默认的行为是以大块读取:

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_copyfileobj.py
Default:
read(16384) =@textgreater[] Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Vestibulum aliquam mollis dolor. Donec vulputate nunc ut diam.
Ut rutrum mi vel sem. Vestibulum ante ipsum.
read(16384) =@textgreater[]
\end{Verbatim}

使用-1表示一次性读取所有输入:

\begin{Verbatim}[commandchars=@\[\]]
All at once:
read(-1) =@textgreater[] Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Vestibulum aliquam mollis dolor. Donec vulputate nunc ut diam.
Ut rutrum mi vel sem. Vestibulum ante ipsum.
read(-1) =@textgreater[]
\end{Verbatim}

使用一个正整数设置块大小:

\begin{Verbatim}[commandchars=@\[\]]
Blocks of 20:
read(20) =@textgreater[] Lorem ipsum dolor si
read(20) =@textgreater[] t amet, consectetuer
read(20) =@textgreater[]  adipiscing elit.
V
read(20) =@textgreater[] estibulum aliquam mo
read(20) =@textgreater[] llis dolor. Donec vu
read(20) =@textgreater[] lputate nunc ut diam
read(20) =@textgreater[] .
Ut rutrum mi vel
read(20) =@textgreater[] sem. Vestibulum ante
read(20) =@textgreater[]  ipsum.
read(20) =@textgreater[]
\end{Verbatim}

copy()函数类似于Unix命令cp.如果目标参数是一个目录而不是一个文件,那么在这个目录中复制一个源文件副本(它与源文件同名).文件的权限也随之复制.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

os@PYGbe[.]mkdir(@PYGad[']@PYGad[example]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[BEFORE:]@PYGad['], os@PYGbe[.]listdir(@PYGad[']@PYGad[example]@PYGad['])
copy(@PYGad[']@PYGad[shutil@_copy.py]@PYGad['], @PYGad[']@PYGad[example]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[AFTER:]@PYGad['], os@PYGbe[.]listdir(@PYGad[']@PYGad[example]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_copy.py
BEFORE: @PYGZlb[]@PYGZrb[]
AFTER: @PYGZlb[]'shutil@_copy.py'@PYGZrb[]
\end{Verbatim}

copy2()函数类似于copy(),但是它将一些元信息,如文件最后一次被读取时间和修改时间等,也复制至新文件中.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

@PYGay[def] @PYGaK[show@_file@_info](filename):
    stat@_info @PYGbe[=] os@PYGbe[.]stat(filename)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Mode    :]@PYGad['], stat@_info@PYGbe[.]st@_mode
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Created :]@PYGad['], time@PYGbe[.]ctime(stat@_info@PYGbe[.]st@_ctime)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Accessed:]@PYGad['], time@PYGbe[.]ctime(stat@_info@PYGbe[.]st@_atime)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Modified:]@PYGad['], time@PYGbe[.]ctime(stat@_info@PYGbe[.]st@_mtime)

os@PYGbe[.]mkdir(@PYGad[']@PYGad[example]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[SOURCE:]@PYGad[']
show@_file@_info(@PYGad[']@PYGad[shutil@_copy2.py]@PYGad['])
copy2(@PYGad[']@PYGad[shutil@_copy2.py]@PYGad['], @PYGad[']@PYGad[example]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[DEST:]@PYGad[']
show@_file@_info(@PYGad[']@PYGad[example/shutil@_copy2.py]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_copy2.py

SOURCE:
        Mode    : 33188
        Created : Sun Oct 21 15:16:07 2007
        Accessed: Sun Oct 21 15:16:11 2007
        Modified: Sun Oct 21 15:16:07 2007
        DEST:
        Mode    : 33188
        Created : Sun Oct 21 15:16:11 2007
        Accessed: Sun Oct 21 15:16:11 2007
        Modified: Sun Oct 21 15:16:07 2007
\end{Verbatim}


\section{复制文件元信息:}

默认情况下,在Unix下,一个新创建的文件的权限会根据当前用户的umask值来设置.把一个文件的权限复制给另一个文件，可以使用copymode()函数.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[commands] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

@PYGay[print] @PYGad[']@PYGad[BEFORE:]@PYGad['], getstatus(@PYGad[']@PYGad[file@_to@_change.txt]@PYGad['])
copymode(@PYGad[']@PYGad[shutil@_copymode.py]@PYGad['], @PYGad[']@PYGad[file@_to@_change.txt]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[AFTER :]@PYGad['], getstatus(@PYGad[']@PYGad[file@_to@_change.txt]@PYGad['])
\end{Verbatim}

首先,需要创建一个文件.然后对权限做些修改:

\begin{Verbatim}[commandchars=@\[\]]
@$ touch file@_to@_change.txt
@$ chmod ugo+w file@_to@_change.txt
\end{Verbatim}

然后,运行刚才的示例脚本会改变之前的权限:

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_copymode.py
BEFORE: -rw-rw-rw-   1 dhellman  dhellman  0 Oct 21 14:43 file@_to@_change.txt
AFTER : -rw-r--r--   1 dhellman  dhellman  0 Oct 21 14:43 file@_to@_change.txt
\end{Verbatim}

复制文件的其他元信息(权限,最后读取时间,最后修改时间)可以使用copystat().

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[time]

@PYGay[def] @PYGaK[show@_file@_info](filename):
    stat@_info @PYGbe[=] os@PYGbe[.]stat(filename)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Mode    :]@PYGad['], stat@_info@PYGbe[.]st@_mode
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Created :]@PYGad['], time@PYGbe[.]ctime(stat@_info@PYGbe[.]st@_ctime)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Accessed:]@PYGad['], time@PYGbe[.]ctime(stat@_info@PYGbe[.]st@_atime)
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Modified:]@PYGad['], time@PYGbe[.]ctime(stat@_info@PYGbe[.]st@_mtime)

@PYGay[print] @PYGad[']@PYGad[BEFORE:]@PYGad[']
show@_file@_info(@PYGad[']@PYGad[file@_to@_change.txt]@PYGad['])
copystat(@PYGad[']@PYGad[shutil@_copystat.py]@PYGad['], @PYGad[']@PYGad[file@_to@_change.txt]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[AFTER :]@PYGad[']
show@_file@_info(@PYGad[']@PYGad[file@_to@_change.txt]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_copystat.py
BEFORE:
        Mode    : 33206
        Created : Sun Oct 21 15:01:23 2007
        Accessed: Sun Oct 21 14:43:26 2007
        Modified: Sun Oct 21 14:43:26 2007
        AFTER :
        Mode    : 33188
        Created : Sun Oct 21 15:01:44 2007
        Accessed: Sun Oct 21 15:01:43 2007
        Modified: Sun Oct 21 15:01:39 2007
\end{Verbatim}


\section{目录树:}

shutil模块包含3个操作目录树的函数.使用copytree()来复制目录,它会递归复制整个目录结构.目标目录必须不存在.其中, symlinks参数控制符号链接是否作为链接或文件被复制,默认是将其内容复制成一个新文件.如果此选项为true,新的链接会在目标目录树中创建.

\begin{notice}{note}{Note:}
注意:copytree()文档中说,它一般作为一个样本实现,而不是一个工具.你可以修改其源码,让它变得更稳定,或者增加一些功能,比如说进度条.
\end{notice}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[commands] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

@PYGay[print] @PYGad[']@PYGad[BEFORE:]@PYGad[']
@PYGay[print] getoutput(@PYGad[']@PYGad[ls -rlast /tmp/example]@PYGad['])
copytree(@PYGad[']@PYGad[example]@PYGad['], @PYGad[']@PYGad[/tmp/example]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[AFTER:]@PYGad[']
@PYGay[print] getoutput(@PYGad[']@PYGad[ls -rlast /tmp/example]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_copytree.py
BEFORE:
ls: /tmp/example: No such file or directory
AFTER:
total 8
8 -rw-r--r--    1 dhellman  wheel  1627 Oct 21 15:16 shutil@_copy2.py
0 drwxr-xr-x    3 dhellman  wheel   102 Oct 21 15:16 .
0 drwxrwxrwt   18 root      wheel   612 Oct 21 15:26 ..
\end{Verbatim}

使用rmtree()可以删除整个目录树.里面若产生错误会作为异常抛出.但是如果它的第二个参数是目录树,那么错误会被忽略,第三个参数可以指定为一个特殊出错处理函数句柄.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[commands] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

@PYGay[print] @PYGad[']@PYGad[BEFORE:]@PYGad[']
@PYGay[print] getoutput(@PYGad[']@PYGad[ls -rlast /tmp/example]@PYGad['])
rmtree(@PYGad[']@PYGad[example]@PYGad['], @PYGad[']@PYGad[/tmp/example]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[AFTER:]@PYGad[']
@PYGay[print] getoutput(@PYGad[']@PYGad[ls -rlast /tmp/example]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_rmtree.py

BEFORE:
total 8
8 -rw-r--r--    1 dhellman  wheel  1627 Oct 21 15:16 shutil@_copy2.py
0 drwxr-xr-x    3 dhellman  wheel   102 Oct 21 15:16 .
0 drwxrwxrwt   18 root      wheel   612 Oct 21 15:26 ..
AFTER:
ls: /tmp/example: No such file or directory
\end{Verbatim}

移动文件或目录可以使用move(),这很类似于Unix命令mv.如果源文件或目录和目标文件或目录在同一个文件系统下,那么源文件或目录会直接重命名.否则源文件或目录会复制到目标文件或目录,接着删除源文件或目录.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]
@PYGay[from] @PYGaV[shutil] @PYGay[import] @PYGbe[*]

@PYGay[print] @PYGad[']@PYGad[BEFORE: example : ]@PYGad['], os@PYGbe[.]listdir(@PYGad[']@PYGad[example]@PYGad['])
move(@PYGad[']@PYGad[example]@PYGad['], @PYGad[']@PYGad[example2]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[AFTER : example2: ]@PYGad['], os@PYGbe[.]listdir(@PYGad[']@PYGad[example2]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python shutil@_move.py
BEFORE: example :  @PYGZlb[]'shutil@_copy.py'@PYGZrb[]
AFTER : example2:  @PYGZlb[]'shutil@_copy.py'@PYGZrb[]
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://tc-nsop-test2.tc.baidu.com:3129/documents}{PyMOTW}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: urlparse}

urlparse模块提供了切分统一资源定位符(URL)的接口。
\begin{itemize}
\item {} 
模块： urlparse

\item {} 
目的： 将URL切分为几个组成部分。

\item {} 
python版本： 1.4+

\end{itemize}


\section{描述}

urlparse模块提供了一些将URL切分成对应与RFC中定义的组成部分的函数。


\section{Parsing:分解}

urlparse函数返回的值是一个包含6个元素的类似于元组的对象。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urlparse
parsed @PYGbe[=] urlparse(@PYGad[']@PYGad[http://netloc/path;parameters?query=argument@#fragment]@PYGad['])
@PYGay[print] parsed
\end{Verbatim}

通过借口可以获得URL的各部分组成，网络位置，路径，参数，查询变量和剩余的部分。在下面的例子中，使用http语法来代替''scheme''。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_urlparse.py
('http', 'netloc', '/path', 'parameters', 'query=argument', 'fragment')
\end{Verbatim}

虽然返回的值是类似于元组，但它不是元组的子类，它支持通过属性名字而不是索引来获取URL对应的部分。这在当你不记得索引顺序时是非常有用的。除了让程序员更容易的使用外，这些属性API还可以获得一些在元组API中不可用的值。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urlparse
parsed @PYGbe[=] urlparse(@PYGad[']@PYGad[http://user:pass@at[]NetLoc:80/path;parameters?query=argument@#fragment]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[scheme :]@PYGad['], parsed@PYGbe[.]scheme
@PYGay[print] @PYGad[']@PYGad[netloc :]@PYGad['], parsed@PYGbe[.]netloc
@PYGay[print] @PYGad[']@PYGad[path :]@PYGad['], parsed@PYGbe[.]path
@PYGay[print] @PYGad[']@PYGad[params :]@PYGad['], parsed@PYGbe[.]params
@PYGay[print] @PYGad[']@PYGad[query :]@PYGad['], parsed@PYGbe[.]query
@PYGay[print] @PYGad[']@PYGad[fragment:]@PYGad['], parsed@PYGbe[.]fragment
@PYGay[print] @PYGad[']@PYGad[username:]@PYGad['], parsed@PYGbe[.]username
@PYGay[print] @PYGad[']@PYGad[password:]@PYGad['], parsed@PYGbe[.]password
@PYGay[print] @PYGad[']@PYGad[hostname:]@PYGad['], parsed@PYGbe[.]hostname, @PYGad[']@PYGad[(netloc in lower case)]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[port :]@PYGad['], parsed@PYGbe[.]port
\end{Verbatim}

当URL中有包含用户名和密码时username和password就会有对应值，如果没有出现则为空。hostname和netloc的值是一样的，但所有字符被强制转换为小写字母。如果出现端口的话，port值被转换成一个对应的整数值，如果没有出现则为None。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_urlparseattrs.py
scheme : http
netloc : user:pass@PYGZat[]NetLoc:80
path : /path
params : parameters
query : query=argument
fragment: fragment
username: user
password: pass
hostname: netloc (netloc in lower case)
port : 80
\end{Verbatim}

\code{urlsplit()} 函数是 \code{urlparse()} 的一种替代函数。它不将参数从URL中切分出来。这对于遵循RFC 2396标准的URL, 即支持每段路径中包含参数时，是很有用的。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urlsplit
parsed @PYGbe[=] urlsplit(@PYGad[']@PYGad[http://user:pass@at[]NetLoc:80/path;parameters/path2;parameters2?query=argument@#fragment]@PYGad['])
@PYGay[print] parsed
@PYGay[print] @PYGad[']@PYGad[scheme :]@PYGad['], parsed@PYGbe[.]scheme
@PYGay[print] @PYGad[']@PYGad[netloc :]@PYGad['], parsed@PYGbe[.]netloc
@PYGay[print] @PYGad[']@PYGad[path :]@PYGad['], parsed@PYGbe[.]path
@PYGay[print] @PYGad[']@PYGad[query :]@PYGad['], parsed@PYGbe[.]query
@PYGay[print] @PYGad[']@PYGad[fragment:]@PYGad['], parsed@PYGbe[.]fragment
@PYGay[print] @PYGad[']@PYGad[username:]@PYGad['], parsed@PYGbe[.]username
@PYGay[print] @PYGad[']@PYGad[password:]@PYGad['], parsed@PYGbe[.]password
@PYGay[print] @PYGad[']@PYGad[hostname:]@PYGad['], parsed@PYGbe[.]hostname, @PYGad[']@PYGad[(netloc in lower case)]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[port :]@PYGad['], parsed@PYGbe[.]port
\end{Verbatim}

因为参数没有被切分出来，所以返回的元组只有5个元素而不是6个，因此也没有params属性。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_urlsplit.py
('http', 'user:pass@PYGZat[]NetLoc:80', '/path;parameters/path2;parameters2', 'query=argument', 'fragment')
scheme : http
netloc : user:pass@PYGZat[]NetLoc:80
path : /path;parameters/path2;parameters2
query : query=argument
fragment: fragment
username: user
password: pass
hostname: netloc (netloc in lower case)
port : 80
\end{Verbatim}

为了简单的从URL中获得fragment标识符，因为你有可能需要寻找URL指向的页面中特定的位置名称，可以使用urldefrag。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urldefrag
original @PYGbe[=] @PYGad[']@PYGad[http://netloc/path;parameters?query=argument@#fragment]@PYGad[']
@PYGay[print] original
url, fragment @PYGbe[=] urldefrag(original)
@PYGay[print] url
@PYGay[print] fragment
\end{Verbatim}

返回的是包含基本URL和片段的元组。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_urldefrag.py
http://netloc/path;parameters?query=argument@#fragment
http://netloc/path;parameters?query=argument
fragment
\end{Verbatim}


\section{组装}

有很多方法可以将URL的各个部分组合回原来的单个字符串。被解析后的URL对象有一个叫做 \code{geturl()} 的方法。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urlparse
original @PYGbe[=] @PYGad[']@PYGad[http://netloc/path;parameters?query=argument@#fragment]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[ORIG :]@PYGad['], original
parsed @PYGbe[=] urlparse(original)
@PYGay[print] @PYGad[']@PYGad[PARSED:]@PYGad['], parsed@PYGbe[.]geturl()
\end{Verbatim}

当然，只有urlparse或者urlsplit返回的对象才起作用。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_geturl.py
ORIG : http://netloc/path;parameters?query=argument@#fragment
PARSED: http://netloc/path;parameters?query=argument@#fragment
\end{Verbatim}

如果你有一个元组，可以使用 \code{urlunparse()} 将它组装成URL。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urlparse, urlunparse
original @PYGbe[=] @PYGad[']@PYGad[http://netloc/path;parameters?query=argument@#fragment]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[ORIG :]@PYGad['], original
parsed @PYGbe[=] urlparse(original)
@PYGay[print] @PYGad[']@PYGad[PARSED:]@PYGad['], @PYGaX[type](parsed), parsed
t @PYGbe[=] parsed@lb[]:@rb[]
@PYGay[print] @PYGad[']@PYGad[TUPLE :]@PYGad['], @PYGaX[type](t), t
@PYGay[print] @PYGad[']@PYGad[NEW :]@PYGad['], urlunparse(t)
\end{Verbatim}

urlparse返回的ParseResult可以当元组用，如上面的例子中，创建了一个新的元组，并且urlunparse也可以处理一般的元组。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_urlunparse.py
ORIG : http://netloc/path;parameters?query=argument@#fragment
PARSED: @textless[]class 'urlparse.ParseResult'@textgreater[] ('http', 'netloc', '/path', 'parameters', 'query=argument', 'fragment')
TUPLE : @textless[]type 'tuple'@textgreater[] ('http', 'netloc', '/path', 'parameters', 'query=argument', 'fragment')
NEW : http://netloc/path;parameters?query=argument@#fragment
\end{Verbatim}

如果输入的URL包含多余的部分，那么，这些部分可能会被丢弃。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urlparse, urlunparse
original @PYGbe[=] @PYGad[']@PYGad[http://netloc/path;?@#]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[ORIG :]@PYGad['], original
parsed @PYGbe[=] urlparse(original)
@PYGay[print] @PYGad[']@PYGad[PARSED:]@PYGad['], @PYGaX[type](parsed), parsed
t @PYGbe[=] parsed@lb[]:@rb[]
@PYGay[print] @PYGad[']@PYGad[TUPLE :]@PYGad['], @PYGaX[type](t), t
@PYGay[print] @PYGad[']@PYGad[NEW :]@PYGad['], urlunparse(t)
\end{Verbatim}

在这个例子中，原始的URL中缺少参数，查询，片段。之后产生新的URL可能和原来的不一样，但是两者是等价的。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_urlunparseextra.py
ORIG : http://netloc/path;?@#
PARSED: @textless[]class 'urlparse.ParseResult'@textgreater[] ('http', 'netloc', '/path', '', '', '')
TUPLE : @textless[]type 'tuple'@textgreater[] ('http', 'netloc', '/path', '', '', '')
NEW : http://netloc/path
\end{Verbatim}


\section{连接}

除了解析URL之外，urlparse模块包含 \code{urljoin()} 函数。用来从关联片段中构造绝对URL。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[urlparse] @PYGay[import] urljoin
@PYGay[print] urljoin(@PYGad[']@PYGad[http://www.example.com/path/file.html]@PYGad['], @PYGad[']@PYGad[anotherfile.html]@PYGad['])
@PYGay[print] urljoin(@PYGad[']@PYGad[http://www.example.com/path/file.html]@PYGad['], @PYGad[']@PYGad[../anotherfile.html]@PYGad['])
\end{Verbatim}

\begin{notice}{note}{Note:}
相对路径(``../'')被作为第二URL来计算。
\end{notice}

\begin{Verbatim}[commandchars=@\[\]]
@$ python urlparse@_urljoin.py
http://www.example.com/path/anotherfile.html
http://www.example.com/anotherfile.html
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.faqs.org/rfcs/rfc1738.html}{RFC 1378}

\item {} 
\href{http://www.faqs.org/rfcs/rfc2396.html}{RFC 2396}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: os.path}
\begin{itemize}
\item {} 
模块：os.path

\item {} 
目的：对文件名和路径进行解析, 创建, 测试和其他操作.

\item {} 
python版本：1.4+

\end{itemize}


\section{描述}

我们可以利用os.path模块提供的函数更容易地在跨平台上处理文件。即使我们的程序不是用于夸平台，也应该使用os.path来让路径名字更加可靠。


\section{解析路径}

os.path中的第一个函数集可以用于解析文件名字符串为不同部分。要注意到这些函数的解析不依赖于被解析的路径是否真正存在，他们只处理字符串。

路径解析依赖于一些os实现定义好的变量，如：
\begin{itemize}
\item {} 
\code{os.sep} ：表示路径的分隔符(如, ``/'')。

\item {} 
\code{os.extsep} ：表示文件名和文件扩展名的分隔符(如, ``.'')。

\item {} 
\code{os.pardir} ：表示上一层目录, 即父目录(如, ``..'')。

\item {} 
\code{os.curdir} ：表示当前目录(如, ``.'')。

\end{itemize}

\code{split()} 函数将路径切分成两个两部分并返回一个元组，它的第二个元素是路径的最后一部份, 第一个元素是路径的前面部分。

\begin{Verbatim}[commandchars=@\[\]]
import os.path

for path in @PYGZlb[] '/one/two/three','/one/two/three/','/',.',''@PYGZrb[]:
    print '"@%s" : "@%s"' @% (path, os.path.split(path))
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_split.py
"/one/two/three" : "('/one/two', 'three')"
"/one/two/three/" : "('/one/two/three', '')"
"/" : "('/', '')"
"." : "('', '.')"
"" : "('', '')"
\end{Verbatim}

\textbf{basename()} 返回的值和 \code{split()} 返回的第二个值相同。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] path @PYGan[in] @lb[] @PYGad[']@PYGad[/one/two/three]@PYGad['],@PYGad[']@PYGad[/one/two/three/]@PYGad['],@PYGad[']@PYGad[/]@PYGad['],@PYGad[']@PYGad[.]@PYGad['],@PYGad[']@PYGad[']@rb[]:
    @PYGay[print] @PYGad[']@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad[ : ]@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad['] @PYGbe[@%] (path, os@PYGbe[.]path@PYGbe[.]basename(path))
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_basename.py
"/one/two/three" : "three"
"/one/two/three/" : ""
"/" : ""
"." : "."
"" : ""
\end{Verbatim}

\textbf{dirname()} 返回的值是和 \code{split()} 返回的第一个值相同。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] path @PYGan[in] @lb[] @PYGad[']@PYGad[/one/two/three]@PYGad['], @PYGad[']@PYGad[/one/two/three/]@PYGad['],@PYGad[']@PYGad[/]@PYGad['],@PYGad[']@PYGad[.]@PYGad['],@PYGad[']@PYGad[']@rb[]:
    @PYGay[print] @PYGad[']@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad[ : ]@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad['] @PYGbe[@%] (path, os@PYGbe[.]path@PYGbe[.]dirname(path))
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_dirname.py

"/one/two/three" : "/one/two"
"/one/two/three/" : "/one/two/three"
"/" : "/"
"." : ""
"" : ""
\end{Verbatim}

\textbf{splitext()} 和 \code{split()} 类似但是分隔路径的扩展名，而不是目录名。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] path @PYGan[in] @lb[] @PYGad[']@PYGad[filename.txt]@PYGad['], @PYGad[']@PYGad[filename]@PYGad['], @PYGad[']@PYGad[/path/to/filename.txt]@PYGad['], @PYGad[']@PYGad[/]@PYGad['], @PYGad[']@PYGad['] @rb[]:
    @PYGay[print] @PYGad[']@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad[ :]@PYGad['] @PYGbe[@%] path, os@PYGbe[.]path@PYGbe[.]splitext(path)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_splitext.py
"filename.txt" : ('filename', '.txt')
"filename" : ('filename', '')
"/path/to/filename.txt" : ('/path/to/filename', '.txt')
"/" : ('/', '')
"" : ('', '')
\end{Verbatim}

\textbf{commonprefix()} 取一个路径列表作为参数，返回一个单一的字符串表示这些路径公共的前缀。这个值可能是一个实际上不存在的路径。路径分割符是被忽略的，所以前缀可能在在分割处被截断。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

paths @PYGbe[=] @lb[]@PYGad[']@PYGad[/one/two/three/four]@PYGad['],@PYGad[']@PYGad[/one/two/threefold]@PYGad['],@PYGad[']@PYGad[/one/two/three/]@PYGad['],@rb[]
@PYGay[print] paths
@PYGay[print] os@PYGbe[.]path@PYGbe[.]commonprefix(paths)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_commonprefix.py
@PYGZlb[]'/one/two/three/four', '/one/two/threefold', '/one/two/three/'@PYGZrb[]
/one/two/three
\end{Verbatim}


\section{创建路径}

除了将现有的路径分隔外，你可能经常会将多个字符串组合成一个路径。

可以使用 \code{join()} 将多个路径部分组合成一个单个值：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] parts @PYGan[in] @lb[] (@PYGad[']@PYGad[one]@PYGad['], @PYGad[']@PYGad[two]@PYGad['], @PYGad[']@PYGad[three]@PYGad[']),(@PYGad[']@PYGad[/]@PYGad['], @PYGad[']@PYGad[one]@PYGad['], @PYGad[']@PYGad[two]@PYGad['], @PYGad[']@PYGad[three]@PYGad[']),(@PYGad[']@PYGad[/one]@PYGad['], @PYGad[']@PYGad[/two]@PYGad['], @PYGad[']@PYGad[/three]@PYGad[']),@rb[]:
    @PYGay[print] parts, @PYGad[']@PYGad[:]@PYGad['], os@PYGbe[.]path@PYGbe[.]join(@PYGbe[*]parts)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_join.py
('one', 'two', 'three') : one/two/three
('/', 'one', 'two', 'three') : /one/two/three
('/one', '/two', '/three') : /three
\end{Verbatim}

如果路径中包含变量部分，也能自动将她扩展出来. 例如， \code{expanduser()} 可以将波浪线(\textasciitilde{})扩展成用户的主目录。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] user @PYGan[in] @lb[] @PYGad[']@PYGad['], @PYGad[']@PYGad[dhellmann]@PYGad['], @PYGad[']@PYGad[postgres]@PYGad['] @rb[]:
    lookup @PYGbe[=] @PYGad[']@PYGad[@textasciitilde[]]@PYGad['] @PYGbe[+] user
    @PYGay[print] lookup, @PYGad[']@PYGad[:]@PYGad['], os@PYGbe[.]path@PYGbe[.]expanduser(lookup)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_expanduser.py
@textasciitilde[] : /Users/dhellmann
@textasciitilde[]dhellmann : /Users/dhellmann
@textasciitilde[]postgres : /var/empty
\end{Verbatim}

\textbf{expandvars()} 是能更一般的扩展出现在路径中的环境变量。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]
@PYGay[import] @PYGaV[os]

os@PYGbe[.]environ@lb[]@PYGad[']@PYGad[MYVAR]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[VALUE]@PYGad[']

@PYGay[print] os@PYGbe[.]path@PYGbe[.]expandvars(@PYGad[']@PYGad[/path/to/@$MYVAR]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_expandvars.py
/path/to/VALUE
\end{Verbatim}


\section{标准化路径}

使用 \code{join()} 组装成的，或嵌入了变量的Paths路径可能会以多余的分隔符结束或含有相对路径部份。使用 \code{normpath()} 将这些清除：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] path @PYGan[in] @lb[] @PYGad[']@PYGad[one//two//three]@PYGad['], @PYGad[']@PYGad[one/./two/./three]@PYGad['], @PYGad[']@PYGad[one/../one/two/three]@PYGad['],@rb[]:
    @PYGay[print] path, @PYGad[']@PYGad[:]@PYGad['], os@PYGbe[.]path@PYGbe[.]normpath(path)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_normpath.py
one//two//three : one/two/three
one/./two/./three : one/two/three
one/../one/two/three : one/two/three
\end{Verbatim}

使用 \textbf{abspath()} 将一个相对路径转换成绝对路径。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] path @PYGan[in] @lb[] @PYGad[']@PYGad[.]@PYGad['], @PYGad[']@PYGad[..]@PYGad['], @PYGad[']@PYGad[./one/two/three]@PYGad['], @PYGad[']@PYGad[../one/two/three]@PYGad[']@rb[]:
    @PYGay[print] @PYGad[']@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad[ : ]@PYGad["]@PYGbf[@%s]@PYGad["]@PYGad['] @PYGbe[@%] (path, os@PYGbe[.]path@PYGbe[.]abspath(path))
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_abspath.py
"." : "/Users/dhellmann/Documents/PyMOTW/in@_progress/ospath"
".." : "/Users/dhellmann/Documents/PyMOTW/in@_progress"
"./one/two/three" : "/Users/dhellmann/Documents/PyMOTW/in@_progress/ospath/one/two/three"
"../one/two/three" : "/Users/dhellmann/Documents/PyMOTW/in@_progress/one/two/three"
\end{Verbatim}


\section{文件时间}

除了处理路径外， \code{os.path} 还可以包含一些用于检索文件属性的函数，他们比 \code{os.stat()} 更方便：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]
@PYGay[import] @PYGaV[time]

@PYGay[print] @PYGad[']@PYGad[File :]@PYGad['], @_@_file@_@_
@PYGay[print] @PYGad[']@PYGad[Access time :]@PYGad['], time@PYGbe[.]ctime(os@PYGbe[.]path@PYGbe[.]getatime(@_@_file@_@_))
@PYGay[print] @PYGad[']@PYGad[Modified time:]@PYGad['], time@PYGbe[.]ctime(os@PYGbe[.]path@PYGbe[.]getmtime(@_@_file@_@_))
@PYGay[print] @PYGad[']@PYGad[Change time :]@PYGad['], time@PYGbe[.]ctime(os@PYGbe[.]path@PYGbe[.]getctime(@_@_file@_@_))
@PYGay[print] @PYGad[']@PYGad[Size :]@PYGad['], os@PYGbe[.]path@PYGbe[.]getsize(@_@_file@_@_)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_properties.py
File : /Users/dhellmann/Documents/PyMOTW/in@_progress/ospath/ospath@_properties.py
Access time : Sun Jan 27 15:40:20 2008
Modified time: Sun Jan 27 15:39:06 2008
Change time : Sun Jan 27 15:39:06 2008
Size : 478
\end{Verbatim}


\section{测试文件}

当你的程序含一个路径名时，他通常需要知道这个路径是否是文件还是目录。如果你的平台支持它，你需要知道这个路径是指向一个符号链接还是是一个挂载点。你也可能想测试路径是否存在。 \code{os.path} 提供测试这些条件的函数。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]

@PYGay[for] @PYGaX[file] @PYGan[in] @lb[] @_@_file@_@_, os@PYGbe[.]path@PYGbe[.]dirname(@_@_file@_@_), @PYGad[']@PYGad[/]@PYGad['], @PYGad[']@PYGad[./broken@_link]@PYGad[']@rb[]:
    @PYGay[print] @PYGad[']@PYGad[File :]@PYGad['], @PYGaX[file]
    @PYGay[print] @PYGad[']@PYGad[Absolute :]@PYGad['], os@PYGbe[.]path@PYGbe[.]isabs(@PYGaX[file])
    @PYGay[print] @PYGad[']@PYGad[Is File? :]@PYGad['], os@PYGbe[.]path@PYGbe[.]isfile(@PYGaX[file])
    @PYGay[print] @PYGad[']@PYGad[Is Dir? :]@PYGad['], os@PYGbe[.]path@PYGbe[.]isdir(@PYGaX[file])
    @PYGay[print] @PYGad[']@PYGad[Is Link? :]@PYGad['], os@PYGbe[.]path@PYGbe[.]islink(@PYGaX[file])
    @PYGay[print] @PYGad[']@PYGad[Mountpoint? :]@PYGad['], os@PYGbe[.]path@PYGbe[.]ismount(@PYGaX[file])
    @PYGay[print] @PYGad[']@PYGad[Exists? :]@PYGad['], os@PYGbe[.]path@PYGbe[.]exists(@PYGaX[file])
    @PYGay[print] @PYGad[']@PYGad[Link Exists?:]@PYGad['], os@PYGbe[.]path@PYGbe[.]lexists(@PYGaX[file])
    @PYGay[print]
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ ln -s /does/not/exist broken@_link
@$ python ospath@_tests.py
File : /Users/dhellmann/Documents/PyMOTW/in@_progress/ospath/ospath@_tests.py
Absolute : True
Is File? : True
Is Dir? : False
Is Link? : False
Mountpoint? : False
Exists? : True
Link Exists?: True

File : /Users/dhellmann/Documents/PyMOTW/in@_progress/ospath
Absolute : True
Is File? : False
Is Dir? : True
Is Link? : False
Mountpoint? : False
Exists? : True
Link Exists?: True

File : /
Absolute : True
Is File? : False
Is Dir? : True
Is Link? : False
Mountpoint? : True
Exists? : True
Link Exists?: True

File : ./broken@_link
Absolute : False
Is File? : False
Is Dir? : False
Is Link? : True
Mountpoint? : False
Exists? : False
Link Exists?: True
\end{Verbatim}


\section{遍历目录树}

\code{os.path.walk()} 遍历树中的所有目录，并调用一个你提供的函数，同时将目录名和目录中包含内容的名字传递给这个函数。下面的例子将递归的列出目录，但忽略.svn目录。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os.path]
@PYGay[import] @PYGaV[pprint]

@PYGay[def] @PYGaK[visit](arg, dirname, names):
    @PYGay[print] dirname, arg
    @PYGay[for] name @PYGan[in] names:
        subname @PYGbe[=] os@PYGbe[.]path@PYGbe[.]join(dirname, name)
        @PYGay[if] os@PYGbe[.]path@PYGbe[.]isdir(subname):
            @PYGay[print] @PYGad[']@PYGad[ ]@PYGbf[@%s]@PYGad[/]@PYGad['] @PYGbe[@%] name
        @PYGay[else]:
            @PYGay[print] @PYGad[']@PYGad[ ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] name
    @PYGaD[@# Do not recurse into .svn directory]
    @PYGay[if] @PYGad[']@PYGad[.svn]@PYGad['] @PYGan[in] names:
        names@PYGbe[.]remove(@PYGad[']@PYGad[.svn]@PYGad['])
    @PYGay[print]

os@PYGbe[.]path@PYGbe[.]walk(@PYGad[']@PYGad[..]@PYGad['], visit, @PYGad[']@PYGad[(User data)]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python ospath@_walk.py
.. (User data)
   .svn/
   ospath/

../ospath (User data)
   .svn/
   @_@_init@_@_.py
   ospath@_abspath.py
   ospath@_basename.py
   ospath@_commonprefix.py
   ospath@_dirname.py
   ospath@_expanduser.py
   ospath@_expandvars.py
   ospath@_join.py
   ospath@_normpath.py
   ospath@_properties.py
   ospath@_split.py
   ospath@_splitext.py
   ospath@_tests.py
   ospath@_walk.py
\end{Verbatim}

\resetcurrentobjects


\chapter{PyMOTW: time}

time模块提供了操作日期和时间的函数
\begin{itemize}
\item {} 
模块：time

\item {} 
目的：操作times的函数

\item {} 
python版本：1.4+

\end{itemize}


\section{描述}

time模块是利用了c函数来处理日期和时间 ，也就是说它绑定了c的实现，一些特定的细节（比如纪元的开始时间、日期的最大值）是和平台相关的，具体可以参考 \href{http://docs.python.org/lib/module-time.html}{这里} 。


\section{Wall Clock Time}

time模块的核心函数之一就是time.time()函数，它返回一个自公元开始的总秒数（浮点型）。

本工具包含三个文件：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[time]
@PYGay[print] @PYGad[']@PYGad[The time is:]@PYGad['], time@PYGbe[.]time()
\end{Verbatim}

虽然返回的值是浮点型，但精度是依赖于不同的系统平台的。

\begin{Verbatim}[commandchars=@\[\]]
@$ python time@_time.py
The time is: 1205079300.54
\end{Verbatim}

当存储和比较日期时，浮点型一般是很有用的，但这种方式不易阅读，为了更有用的记录和输出时间可以使用time.ctime()。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[time]
@PYGay[print] @PYGad[']@PYGad[The time is      :]@PYGad['], time@PYGbe[.]ctime()
later @PYGbe[=] time@PYGbe[.]time() @PYGbe[+] @PYGaw[15]
@PYGay[print] @PYGad[']@PYGad[15 secs from now :]@PYGad['], time@PYGbe[.]ctime(later)
\end{Verbatim}

上面第二行示范了如何来利用ctime()函数对当前时间进行格式化。

\begin{Verbatim}[commandchars=@\[\]]
@$ python time@_ctime.py
The time is      : Sun Mar  9 12:18:02 2008
15 secs from now : Sun Mar  9 12:18:17 2008
\end{Verbatim}


\section{处理器时钟}

time()函数返回的是现实世界的时间，而clock()函数返回的是cpu时钟。clock()函数返回值常用作性能测试，benchmarking等。它们常常反映了程序运行的真实时间，比time()函数返回的值要精确。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[hashlib]
@PYGay[import] @PYGaV[time]

@PYGaD[@# Data to use to calculate md5 checksums]
data @PYGbe[=] @PYGaX[open](@_@_file@_@_, @PYGad[']@PYGad[rt]@PYGad['])@PYGbe[.]read()

@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[5]):
    h @PYGbe[=] hashlib@PYGbe[.]sha1()
    @PYGay[print] time@PYGbe[.]ctime(), @PYGad[']@PYGad[: ]@PYGbf[@%0.3f]@PYGad[ ]@PYGbf[@%0.3f]@PYGad['] @PYGbe[@%] (time@PYGbe[.]time(), time@PYGbe[.]clock())
    @PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[100000]):
        h@PYGbe[.]update(data)
    cksum @PYGbe[=] h@PYGbe[.]digest()
\end{Verbatim}

在这个例子中，ctime()把time()函数返回的浮点型表示转化为标准时间，每个迭代循环使用了clock()。如果想在机器上测试这个例子，那么可以增加循环次数，或者处理大一点的数据，这样才能看到不同点。

\begin{Verbatim}[commandchars=@\[\]]
@$ python time@_clock.py
Sun Mar  9 12:41:53 2008 : 1205080913.260 0.030
Sun Mar  9 12:41:53 2008 : 1205080913.682 0.440
Sun Mar  9 12:41:54 2008 : 1205080914.103 0.860
Sun Mar  9 12:41:54 2008 : 1205080914.518 1.270
Sun Mar  9 12:41:54 2008 : 1205080914.932 1.680
\end{Verbatim}

一般，如果程序没有做任何事情，处理器时钟是不会计时。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[time]

@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[6], @PYGaw[1], @PYGbe[-]@PYGaw[1]):
    @PYGay[print] @PYGad[']@PYGbf[@%s]@PYGad[ ]@PYGbf[@%0.2f]@PYGad[ ]@PYGbf[@%0.2f]@PYGad['] @PYGbe[@%] (time@PYGbe[.]ctime(), time@PYGbe[.]time(), time@PYGbe[.]clock())
    @PYGay[print] @PYGad[']@PYGad[Sleeping]@PYGad['], i
    time@PYGbe[.]sleep(i)
\end{Verbatim}

在这个例子中，每次迭代，循环中处理了很少的任务就进入了sleep，当进程在睡眠中时，time.time()函数的返回值依然会增加。但是time.clock()是不会增加的。

\begin{Verbatim}[commandchars=@\[\]]
@$ python time@_clock@_sleep.py
Sun Mar  9 12:46:36 2008 1205081196.20 0.02
Sleeping 6
Sun Mar  9 12:46:42 2008 1205081202.20 0.02
Sleeping 5
Sun Mar  9 12:46:47 2008 1205081207.20 0.02
Sleeping 4
Sun Mar  9 12:46:51 2008 1205081211.20 0.02
Sleeping 3
Sun Mar  9 12:46:54 2008 1205081214.21 0.02
Sleeping 2
\end{Verbatim}

time.sleep函数控制当前的线程，让它等待直到系统重新唤醒它，如果应用中只有一个线程，那么它会阻塞当前进程，使其不做任何事情。


\section{struct\_time}

某些时候，使用逝去的秒数来表示时间是很有用的。有时候你需要获取日期的单独部分（如年、月等等），time模块定义了struct\_time来存储日期和时间值并作为其部分以便获取。提供了多种函数将struct\_time转化为float。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[time]

@PYGay[print] @PYGad[']@PYGad[gmtime   :]@PYGad['], time@PYGbe[.]gmtime()
@PYGay[print] @PYGad[']@PYGad[localtime:]@PYGad['], time@PYGbe[.]localtime()
@PYGay[print] @PYGad[']@PYGad[mktime   :]@PYGad['], time@PYGbe[.]mktime(time@PYGbe[.]localtime())

@PYGay[print]
t @PYGbe[=] time@PYGbe[.]localtime()
@PYGay[print] @PYGad[']@PYGad[Day of month:]@PYGad['], t@PYGbe[.]tm@_mday
@PYGay[print] @PYGad[']@PYGad[ Day of week:]@PYGad['], t@PYGbe[.]tm@_wday
@PYGay[print] @PYGad[']@PYGad[ Day of year:]@PYGad['], t@PYGbe[.]tm@_yday
\end{Verbatim}

gmtime()返回当前的UTC时间，localtime()返回当前时间域的当前时间，mktime()接收struct\_time参数并将其转化为浮点型来表示。

\begin{Verbatim}[commandchars=@\[\]]
@$ python time@_struct.py
gmtime   : (2008, 3, 9, 16, 58, 19, 6, 69, 0)
localtime: (2008, 3, 9, 12, 58, 19, 6, 69, 1)
mktime   : 1205081899.0

Day of month: 9
Day of week: 6
Day of year: 69
\end{Verbatim}


\section{解析和格式化时间}

函数strptime()和strftime()可以使struct\_time和时间值字符串相互转化。有一个很长的格式化说明列表可以用来支持输入和输出不同的风格。完整的列表在time模块的的库文档中有介绍。

下面示例把当前时间（字符串)转化为struct\_time实例，然后再转化为字符串。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[time]

now @PYGbe[=] time@PYGbe[.]ctime()
@PYGay[print] now
parsed @PYGbe[=] time@PYGbe[.]strptime(now)
@PYGay[print] parsed
@PYGay[print] time@PYGbe[.]strftime(@PYGad["]@PYGad[@%]@PYGad[a ]@PYGad[@%]@PYGad[b ]@PYGbf[@%d]@PYGad[ ]@PYGad[@%]@PYGad[H:]@PYGad[@%]@PYGad[M:]@PYGad[@%]@PYGad[S ]@PYGad[@%]@PYGad[Y]@PYGad["], parsed)
\end{Verbatim}

输出和输入字符串不是完全的一致，主要表现在月份前加了一个0前缀。

\begin{Verbatim}[commandchars=@\[\]]
@$ python time@_strptime.py
Sun Mar  9 13:01:19 2008
(2008, 3, 9, 13, 1, 19, 6, 69, -1)
Sun Mar 09 13:01:19 2008
\end{Verbatim}


\section{使用Time Zone(时区)}

无论是你的程序，还是为系统使用一个默认的时区，检测当前时间的函数依赖于当前Time Zone（时间域)的设置。改变时区设置是不会改变实际时间，只会改变表示时间的方法。

通过设置环境变量TZ可以改变时区，然后调用tzset()。环境变量TZ可以对时区来详细的设置，比如白天保存时间的起始点。通常使用时区名称是比较简单的，如果需要了解更多信息可以参考库。

下面这个示例改变了time zone中的一些值，展示了这种改变如何来影响time模块中的其它设置。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[time]
@PYGay[import] @PYGaV[os]

@PYGay[def] @PYGaK[show@_zone@_info]():
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[TZ    :]@PYGad['], os@PYGbe[.]environ@PYGbe[.]get(@PYGad[']@PYGad[TZ]@PYGad['], @PYGad[']@PYGad[(not set)]@PYGad['])
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[tzname:]@PYGad['], time@PYGbe[.]tzname
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Zone  : ]@PYGbf[@%d]@PYGad[ (]@PYGbf[@%d]@PYGad[)]@PYGad['] @PYGbe[@%] (time@PYGbe[.]timezone, (time@PYGbe[.]timezone @PYGbe[/] @PYGaw[3600]))
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[DST   :]@PYGad['], time@PYGbe[.]daylight
    @PYGay[print] @PYGad[']@PYGao[\t]@PYGad[Time  :]@PYGad['], time@PYGbe[.]ctime()
    @PYGay[print]

@PYGay[print] @PYGad[']@PYGad[Default :]@PYGad[']
show@_zone@_info()

@PYGay[for] zone @PYGan[in] @lb[] @PYGad[']@PYGad[US/Eastern]@PYGad['], @PYGad[']@PYGad[US/Pacific]@PYGad['], @PYGad[']@PYGad[GMT]@PYGad['], @PYGad[']@PYGad[Europe/Amsterdam]@PYGad['] @rb[]:
    os@PYGbe[.]environ@lb[]@PYGad[']@PYGad[TZ]@PYGad[']@rb[] @PYGbe[=] zone
    time@PYGbe[.]tzset()
    @PYGay[print] zone, @PYGad[']@PYGad[:]@PYGad[']
    show@_zone@_info()
\end{Verbatim}

我的时区是US/Eastern，所以设置TZ不会起作用。如果是其它时区，则会改变tzname、daylight flag以及 timezone偏移值。

\begin{Verbatim}[commandchars=@\[\]]
@$ python time@_timezone.py
Default :
  TZ    : (not set)
  tzname: ('EST', 'EDT')
  Zone  : 18000 (5)
  DST   : 1
  Time  : Sun Mar  9 13:06:53 2008

US/Eastern :
  TZ    : US/Eastern
  tzname: ('EST', 'EDT')
  Zone  : 18000 (5)
  DST   : 1
  Time  : Sun Mar  9 13:06:53 2008

US/Pacific :
  TZ    : US/Pacific
  tzname: ('PST', 'PDT')
  Zone  : 28800 (8)
  DST   : 1
  Time  : Sun Mar  9 10:06:53 2008

GMT :
  TZ    : GMT
  tzname: ('GMT', 'GMT')
  Zone  : 0 (0)
  DST   : 0
  Time  : Sun Mar  9 17:06:53 2008

Europe/Amsterdam :
  TZ    : Europe/Amsterdam
  tzname: ('CET', 'CEST')
  Zone  : -3600 (-1)
  DST   : 1
  Time  : Sun Mar  9 18:06:53 2008
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/lib/module-datetime.html}{datetime module}

\item {} 
\href{http://docs.python.org/lib/module-locale.html}{locale module}

\item {} 
\href{http://docs.python.org/lib/module-calendar.html}{calendar module}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: datetime}

datetime 模块包含了一些用于时间解析、格式化、计算的函数。
\begin{itemize}
\item {} 
模块： datetime

\item {} 
目的： 日期/时间处理

\item {} 
python版本： 2.3+

\end{itemize}


\section{时间}

时间值由time类来表示，Times有小时，分，秒和微秒属性，以及包含时区信息。初始化time实例的参数是可选的，但这样的话，你将获得初始值0（也许不是你所想要的）。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

t @PYGbe[=] datetime@PYGbe[.]time(@PYGaw[1], @PYGaw[2], @PYGaw[3])
@PYGay[print] t
@PYGay[print] @PYGad[']@PYGad[hour :]@PYGad['], t@PYGbe[.]hour
@PYGay[print] @PYGad[']@PYGad[minute:]@PYGad['], t@PYGbe[.]minute
@PYGay[print] @PYGad[']@PYGad[second:]@PYGad['], t@PYGbe[.]second
@PYGay[print] @PYGad[']@PYGad[microsecond:]@PYGad['], t@PYGbe[.]microsecond
@PYGay[print] @PYGad[']@PYGad[tzinfo:]@PYGad['], t@PYGbe[.]tzinfo
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_time.py
01:02:03
hour  : 1
minute: 2
second: 3
microsecond: 0
tzinfo: None
\end{Verbatim}

一个time实例只包含时间值，不包含日期值。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

@PYGay[print] @PYGad[']@PYGad[Earliest  :]@PYGad['], datetime@PYGbe[.]time@PYGbe[.]min
@PYGay[print] @PYGad[']@PYGad[Latest    :]@PYGad['], datetime@PYGbe[.]time@PYGbe[.]max
@PYGay[print] @PYGad[']@PYGad[Resolution:]@PYGad['], datetime@PYGbe[.]time@PYGbe[.]resolution
\end{Verbatim}

类属性中的最大最小值反应了一天中的时间范围。

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_time@_minmax.py
Earliest  : 00:00:00
Latest    : 23:59:59.999999
Resolution: 0:00:00.000001
\end{Verbatim}

时间的最小取值是微秒，更精确的位数就被截断了。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

@PYGay[for] m @PYGan[in] @lb[] @PYGaw[1], @PYGaw[0], @PYGaw[0.1], @PYGaw[0.6] @rb[]:
    @PYGay[print] @PYGad[']@PYGbf[@%02.1f]@PYGad[ :]@PYGad['] @PYGbe[@%] m, datetime@PYGbe[.]time(@PYGaw[0], @PYGaw[0], @PYGaw[0], microsecond@PYGbe[=]m)
\end{Verbatim}

实际中，如果使用浮点型作为微秒参数，那么将产生一些警告信息。

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_time@_resolution.py
/home/cjj/python/pymotw/datetime@_time@_resolution.py:14: DeprecationWarning: integer argument expected, got float
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGad[']@PYGbf[@%02.1f]@PYGad[ :]@PYGad['] @PYGbe[@%] m, datetime@PYGbe[.]time(@PYGaw[0], @PYGaw[0], @PYGaw[0], microsecond@PYGbe[=]m)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
1.0 : 00:00:00.000001
0.0 : 00:00:00
0.1 : 00:00:00
0.6 : 00:00:00
\end{Verbatim}


\section{日期}

日期值可以由date类来表示，实例有年、月、日属性，使用data类的 \code{today()} 方法可以方便的表示出今天的日期。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

today @PYGbe[=] datetime@PYGbe[.]date@PYGbe[.]today()
@PYGay[print] today
@PYGay[print] @PYGad[']@PYGad[ctime:]@PYGad['], today@PYGbe[.]ctime()
@PYGay[print] @PYGad[']@PYGad[tuple:]@PYGad['], today@PYGbe[.]timetuple()
@PYGay[print] @PYGad[']@PYGad[ordinal:]@PYGad['], today@PYGbe[.]toordinal()
@PYGay[print] @PYGad[']@PYGad[Year:]@PYGad['], today@PYGbe[.]year
@PYGay[print] @PYGad[']@PYGad[Mon :]@PYGad['], today@PYGbe[.]month
@PYGay[print] @PYGad[']@PYGad[Day :]@PYGad['], today@PYGbe[.]day
\end{Verbatim}

示例演示了今天日期的多种表示方法：

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_date.py
2008-03-13
ctime: Thu Mar 13 00:00:00 2008
tuple: (2008, 3, 13, 0, 0, 0, 3, 73, -1)
ordinal: 733114
Year: 2008
Mon : 3
Day : 13
\end{Verbatim}

使用整数（从阳历的第1年1月1号开始）或者POSIX标准时间戳可以类实例。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]
@PYGay[import] @PYGaV[time]

o @PYGbe[=] @PYGaw[733114]
@PYGay[print] @PYGad[']@PYGad[o:]@PYGad['], o
@PYGay[print] @PYGad[']@PYGad[fromordinal(o):]@PYGad['], datetime@PYGbe[.]date@PYGbe[.]fromordinal(o)
t @PYGbe[=] time@PYGbe[.]time()
@PYGay[print] @PYGad[']@PYGad[t:]@PYGad['], t
@PYGay[print] @PYGad[']@PYGad[fromtimestamp(t):]@PYGad['], datetime@PYGbe[.]date@PYGbe[.]fromtimestamp(t)
\end{Verbatim}

示例显示了函数 \code{fromordinal()} 和 \code{fromtimestamp()} 返回了不同的结果。

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_date@_fromordinal.py
o: 733114
fromordinal(o): 2008-03-13
t: 1205436039.53
fromtimestamp(t): 2008-03-13
\end{Verbatim}

日期的最大和最小范围可以使用属性max和min来表示。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

@PYGay[print] @PYGad[']@PYGad[Earliest :]@PYGad['], datetime@PYGbe[.]date@PYGbe[.]min
@PYGay[print] @PYGad[']@PYGad[Latest :]@PYGad['], datetime@PYGbe[.]date@PYGbe[.]max
@PYGay[print] @PYGad[']@PYGad[Resolution:]@PYGad['], datetime@PYGbe[.]date@PYGbe[.]resolution
\end{Verbatim}

一个日期的单位就是1天。

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_date@_minmax.py
Earliest  : 0001-01-01
Latest    : 9999-12-31
Resolution: 1 day, 0:00:00
\end{Verbatim}

对于一个存在的日期，可使用replace函数可以创建出一个新的日期实例。比如你可以改变年数，只保留月份和日。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

d1 @PYGbe[=] datetime@PYGbe[.]date(@PYGaw[2008], @PYGaw[3], @PYGaw[12])
@PYGay[print] @PYGad[']@PYGad[d1:]@PYGad['], d1

d2 @PYGbe[=] d1@PYGbe[.]replace(year@PYGbe[=]@PYGaw[2009])
@PYGay[print] @PYGad[']@PYGad[d2:]@PYGad['], d2
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_date@_replace.py
d1: 2008-03-12
d2: 2009-03-12
\end{Verbatim}


\section{timedelta}

除了 \code{replace()} 函数可以计算过去或者未来的时间，还可以使用timedelta类对日期值进行基本运算。通过timedelta可以加减一个日期来产生另外一个日期。timedelta中的内部值可以用天、秒和微秒来表示。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

@PYGay[print] @PYGad["]@PYGad[microseconds:]@PYGad["], datetime@PYGbe[.]timedelta(microseconds@PYGbe[=]@PYGaw[1])
@PYGay[print] @PYGad["]@PYGad[milliseconds:]@PYGad["], datetime@PYGbe[.]timedelta(milliseconds@PYGbe[=]@PYGaw[1])
@PYGay[print] @PYGad["]@PYGad[seconds :]@PYGad["], datetime@PYGbe[.]timedelta(seconds@PYGbe[=]@PYGaw[1])
@PYGay[print] @PYGad["]@PYGad[minutes :]@PYGad["], datetime@PYGbe[.]timedelta(minutes@PYGbe[=]@PYGaw[1])
@PYGay[print] @PYGad["]@PYGad[hours :]@PYGad["], datetime@PYGbe[.]timedelta(hours@PYGbe[=]@PYGaw[1])
@PYGay[print] @PYGad["]@PYGad[days :]@PYGad["], datetime@PYGbe[.]timedelta(days@PYGbe[=]@PYGaw[1])
@PYGay[print] @PYGad["]@PYGad[weeks :]@PYGad["], datetime@PYGbe[.]timedelta(weeks@PYGbe[=]@PYGaw[1])
\end{Verbatim}

传递给构造器的中间值被转换为天、秒和微秒。

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_timedelta.py

microseconds: 0:00:00.000001
milliseconds: 0:00:00.001000
seconds : 0:00:01
minutes : 0:01:00
hours : 1:00:00
days : 1 day, 0:00:00
weeks : 7 days, 0:00:00
\end{Verbatim}


\section{比较}

时间和日期值都可以通过标准的操作符来进行比较。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]
@PYGay[import] @PYGaV[time]

@PYGay[print] @PYGad[']@PYGad[Times:]@PYGad[']
t1 @PYGbe[=] datetime@PYGbe[.]time(@PYGaw[12], @PYGaw[55], @PYGaw[0])
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[t1:]@PYGad['], t1
t2 @PYGbe[=] datetime@PYGbe[.]time(@PYGaw[13], @PYGaw[5], @PYGaw[0])
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[t2:]@PYGad['], t2
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[t1 @textless[] t2:]@PYGad['], t1 @PYGbe[@textless[]] t2

@PYGay[print] @PYGad[']@PYGad[Dates:]@PYGad[']
d1 @PYGbe[=] datetime@PYGbe[.]date@PYGbe[.]today()
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[d1:]@PYGad['], d1
d2 @PYGbe[=] datetime@PYGbe[.]date@PYGbe[.]today() @PYGbe[+] datetime@PYGbe[.]timedelta(days@PYGbe[=]@PYGaw[1])
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[d2:]@PYGad['], d2
@PYGay[print] @PYGad[']@PYGao[\t]@PYGad[d1 @textgreater[] d2:]@PYGad['], d1 @PYGbe[@textgreater[]] d2
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_comparing.py
Times:
     t1: 12:55:00
     t2: 13:05:00
     t1 @textless[] t2: True

Dates:
     d1: 2008-03-13
     d2: 2008-03-14
     d1 @textgreater[] d2: False
\end{Verbatim}


\section{日期和时间组合}

使用datetime类可以存储日期和时间的组合部分，类似于使用date。有多种方法可以创建datetime。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

@PYGay[print] @PYGad[']@PYGad[Now :]@PYGad['], datetime@PYGbe[.]datetime@PYGbe[.]now()
@PYGay[print] @PYGad[']@PYGad[Today :]@PYGad['], datetime@PYGbe[.]datetime@PYGbe[.]today()
@PYGay[print] @PYGad[']@PYGad[UTC Now:]@PYGad['], datetime@PYGbe[.]datetime@PYGbe[.]utcnow()

d @PYGbe[=] datetime@PYGbe[.]datetime@PYGbe[.]now()
@PYGay[for] attr @PYGan[in] @lb[] @PYGad[']@PYGad[year]@PYGad['], @PYGad[']@PYGad[month]@PYGad['], @PYGad[']@PYGad[day]@PYGad['], @PYGad[']@PYGad[hour]@PYGad['], @PYGad[']@PYGad[minute]@PYGad['], @PYGad[']@PYGad[second]@PYGad['], @PYGad[']@PYGad[microsecond]@PYGad[']@rb[]:
    @PYGay[print] attr, @PYGad[']@PYGad[:]@PYGad['], @PYGaX[getattr](d, attr)
\end{Verbatim}

同时，datetime实例拥有date和time对象的所有属性。

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_datetime.py
Now : 2008-03-15 22:58:14.770074
Today : 2008-03-15 22:58:14.779804
UTC Now: 2008-03-16 03:58:14.779858
year : 2008
month : 3
day : 15
hour : 22
minute : 58
second : 14
microsecond : 780399
\end{Verbatim}

datetime类提供了一些类方法来创建新的实例，当然它也包含 \code{fromordinal()} 和 \code{fromtimestamp()} ，如果你已经有一个日期实例和时间实例，并需要创建datetime的话，combine()方法比较有用。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

t @PYGbe[=] datetime@PYGbe[.]time(@PYGaw[1], @PYGaw[2], @PYGaw[3])
@PYGay[print] @PYGad[']@PYGad[t :]@PYGad['], t
d @PYGbe[=] datetime@PYGbe[.]date@PYGbe[.]today()
@PYGay[print] @PYGad[']@PYGad[d :]@PYGad['], d
dt @PYGbe[=] datetime@PYGbe[.]datetime@PYGbe[.]combine(d, t)
@PYGay[print] @PYGad[']@PYGad[dt:]@PYGad['], dt
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_datetime@_combine.py
t : 01:02:03
d : 2008-03-16
dt: 2008-03-16 01:02:03
\end{Verbatim}


\section{格式化和解析}

datetime对象的字符串表示方法默认使用的是ISO 8601格式（YYYY-MM-DDTHH:MM:SS.mmmmmm），使用 \code{strftime()} 可以产生其他格式，同样，如果你的输入值是用 \code{time.strptime()} 解析的时间戳，那么 \code{strptime()} 是一个合适的方法来把它转换为datetime实例。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[datetime]

format @PYGbe[=] @PYGad["]@PYGad[@%]@PYGad[a ]@PYGad[@%]@PYGad[b ]@PYGbf[@%d]@PYGad[ ]@PYGad[@%]@PYGad[H:]@PYGad[@%]@PYGad[M:]@PYGad[@%]@PYGad[S ]@PYGad[@%]@PYGad[Y]@PYGad["]

today @PYGbe[=] datetime@PYGbe[.]datetime@PYGbe[.]today()
@PYGay[print] @PYGad[']@PYGad[ISO :]@PYGad['], today

s @PYGbe[=] today@PYGbe[.]strftime(format)
@PYGay[print] @PYGad[']@PYGad[strftime:]@PYGad['], s

d @PYGbe[=] datetime@PYGbe[.]datetime@PYGbe[.]strptime(s, format)
@PYGay[print] @PYGad[']@PYGad[strptime:]@PYGad['], d@PYGbe[.]strftime(format)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python datetime@_datetime@_strptime.py
ISO     : 2008-03-16 08:08:16.275134
strftime: Sun Mar 16 08:08:16 2008
strptime: Sun Mar 16 08:08:16 2008
\end{Verbatim}


\section{时区}

时区是由子类datetime.tzinfo来表示的，tzinfo是一个抽象的基类，你需要定义子类，并提供相应的方法去实现一些方法。很可惜，dateime不包含任何实际可用的实现，可以参考 \href{http://docs.python.org/lib/datetime-tzinfo.html}{文档} 来获取一些示例。


\section{参考}
\begin{itemize}
\item {} 
\href{http://pleac.sourceforge.net/pleac\_python/datesandtimes.html}{PLEAC - Dates and Times}

\item {} 
\href{http://en.wikipedia.org/wiki/Proleptic\_Gregorian\_calendar}{WikiPedia: Proleptic Gregorian calendar}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: urllib}

urllib模块提供了一个访问网络资源的简单接口。
\begin{itemize}
\item {} 
模块：urllib

\item {} 
目的：访问不需要认证的远程资源

\item {} 
python版本：1.4+

\end{itemize}

虽然urllib可以与gopher和ftp协议一起使用, 但下面的例子都是用了http协议。


\section{HTTP GET:}

这些例子的测试服务器是在BaseHTTPServer\_GET.py中, 这个脚本在PyMOTW例子的BaseHTTPServer模块中.在一个终端窗口中启动服务器, 然后在另一个窗口中运行以下这些例子.

HTTP GET 是urllib最简单的操作。简单把URL传递给urlopen()来获取一个用于操作远程数据的类文件句柄。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[urllib]

response @PYGbe[=] urllib@PYGbe[.]urlopen(@PYGad[']@PYGad[http://localhost:8080/]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[RESPONSE:]@PYGad['], response
@PYGay[print] @PYGad[']@PYGad[URL :]@PYGad['], response@PYGbe[.]geturl()

headers @PYGbe[=] response@PYGbe[.]info()
@PYGay[print] @PYGad[']@PYGad[DATE :]@PYGad['], headers@lb[]@PYGad[']@PYGad[date]@PYGad[']@rb[]
@PYGay[print] @PYGad[']@PYGad[HEADERS :]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[---------]@PYGad[']
@PYGay[print] headers

data @PYGbe[=] response@PYGbe[.]read()
@PYGay[print] @PYGad[']@PYGad[LENGTH :]@PYGad['], @PYGaX[len](data)
@PYGay[print] @PYGad[']@PYGad[DATA :]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[---------]@PYGad[']
@PYGay[print] data
\end{Verbatim}

该示例服务器取得传入的值，并且返回格式化的纯文本response。从urlopen()返回的值通过info()方法给出HTTP服务器的headers的入口，并且通过read()和readlines()等方法获得远程资源的数据。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_urlopen.py
RESPONSE: @textless[]addinfourl at 10180248 whose fp = @textless[]socket.@_fileobject object at 0x935c30@textgreater[]@textgreater[]
URL : http://localhost:8080/
DATE : Sun, 30 Mar 2008 16:27:10 GMT
HEADERS :
---------
Server: BaseHTTP/0.3 Python/2.5.1
Date: Sun, 30 Mar 2008 16:27:10 GMT

LENGTH : 221
DATA :
---------
CLIENT VALUES:
client@_address=('127.0.0.1', 54354) (localhost)
command=GET
path=/
real path=/
query=
request@_version=HTTP/1.0

SERVER VALUES:
server@_version=BaseHTTP/0.3
sys@_version=Python/2.5.1
protocol@_version=HTTP/1.0
\end{Verbatim}

类文件对象也是可以迭代的:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[urllib]

response @PYGbe[=] urllib@PYGbe[.]urlopen(@PYGad[']@PYGad[http://localhost:8080/]@PYGad['])
@PYGay[for] line @PYGan[in] response:
    @PYGay[print] line@PYGbe[.]rstrip()
\end{Verbatim}

因为返回的每一行都有换行符和完整的框架回车符 -艳 盛 11/21/08 1:31 PM ，所以在输出之前先去掉他们。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_urlopen@_iterator.py
CLIENT VALUES:
client@_address=('127.0.0.1', 54380) (localhost)
command=GET
path=/
real path=/
query=
request@_version=HTTP/1.0

SERVER VALUES:
server@_version=BaseHTTP/0.3
sys@_version=Python/2.5.1
protocol@_version=HTTP/1.0
\end{Verbatim}


\section{编码参数：}

将参数编码并且追加在URL之后，传给服务器。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[urllib]
query@_args @PYGbe[=] { @PYGad[']@PYGad[q]@PYGad[']:@PYGad[']@PYGad[query string]@PYGad['], @PYGad[']@PYGad[foo]@PYGad[']:@PYGad[']@PYGad[bar]@PYGad['] }
encoded@_args @PYGbe[=] urllib@PYGbe[.]urlencode(query@_args) @PYGaD[@#@#这个编码, 是将其转换为a=aa@&b=bb的形式]
@PYGay[print] @PYGad[']@PYGad[Encoded:]@PYGad['], encoded@_args

url @PYGbe[=] @PYGad[']@PYGad[http://localhost:8080/?]@PYGad['] @PYGbe[+] encoded@_args
@PYGay[print] urllib@PYGbe[.]urlopen(url)@PYGbe[.]read()
\end{Verbatim}

注意query，在客户端的值的列表中包含了已编码的参数query。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_urlencode.py
Encoded: q=query+string@&foo=bar
CLIENT VALUES:
client@_address=('127.0.0.1', 54415) (localhost)
command=GET
path=/?q=query+string@&foo=bar
real path=/
query=q=query+string@&foo=bar
request@_version=HTTP/1.0

SERVER VALUES:
server@_version=BaseHTTP/0.3
sys@_version=Python/2.5.1
protocol@_version=HTTP/1.0
\end{Verbatim}

在查询字符串中使用单独的变量来传递值序列时, 需传递doseq=True给urlencode()。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[urllib]
query@_args @PYGbe[=] { @PYGad[']@PYGad[foo]@PYGad[']:@lb[]@PYGad[']@PYGad[foo1]@PYGad['], @PYGad[']@PYGad[foo2]@PYGad[']@rb[] }
@PYGay[print] @PYGad[']@PYGad[Single :]@PYGad['], urllib@PYGbe[.]urlencode(query@_args)
@PYGay[print] @PYGad[']@PYGad[Sequence:]@PYGad['], urllib@PYGbe[.]urlencode(query@_args, doseq@PYGbe[=]@PYGaA[True])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_urlencode@_doseq.py
Single : foo=@%5B@%27foo1@%27@%2C+@%27foo2@%27@%5D
Sequence: foo=foo1@&foo=foo2
\end{Verbatim}

为了解码查询字符串，可查看cgi模块中的FieldStorage类。

在查询参数里的一些特别字符，在传递给urlencode()后，在服务器端可能和URL一起引起解析错误。可以直接使用quote()或者quote\_plus()函数在本地引用他们以生成安全的字符串。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[urllib]

url @PYGbe[=] @PYGad[']@PYGad[http://localhost:8080/@textasciitilde[]dhellmann/]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[urlencode() :]@PYGad['], urllib@PYGbe[.]urlencode({@PYGad[']@PYGad[url]@PYGad[']:url})
@PYGay[print] @PYGad[']@PYGad[quote() :]@PYGad['], urllib@PYGbe[.]quote(url)
@PYGay[print] @PYGad[']@PYGad[quote@_plus():]@PYGad['], urllib@PYGbe[.]quote@_plus(url)
\end{Verbatim}

\begin{notice}{note}{Note:}
quote\_plus()能够替换更多的特殊字符。
\end{notice}

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_quote.py
urlencode() : url=http@%3A@%2F@%2Flocalhost@%3A8080@%2F@%7Edhellmann@%2F
quote() : http@%3A//localhost@%3A8080/@%7Edhellmann/
quote@_plus(): http@%3A@%2F@%2Flocalhost@%3A8080@%2F@%7Edhellmann@%2F
\end{Verbatim}

视情况而定，用unquote()或者unquote\_plus()来还原quote操作。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[urllib]

@PYGay[print] urllib@PYGbe[.]unquote(@PYGad[']@PYGad[http]@PYGad[@%]@PYGad[3A//localhost]@PYGad[@%]@PYGad[3A8080/]@PYGbf[@%7E]@PYGad[dhellmann/]@PYGad['])
@PYGay[print] urllib@PYGbe[.]unquote@_plus(@PYGad[']@PYGad[http]@PYGad[@%]@PYGad[3A]@PYGbf[@%2F]@PYGbf[@%2F]@PYGad[localhost]@PYGad[@%]@PYGad[3A8080]@PYGbf[@%2F]@PYGbf[@%7E]@PYGad[dhellmann]@PYGbf[@%2F]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_unquote.py
http://localhost:8080/@textasciitilde[]dhellmann/
http://localhost:8080/@textasciitilde[]dhellmann/
\end{Verbatim}


\section{HTTP POST:}

这些例子的测试服务器是在BaseHTTPServer\_POST.py中, 这个脚本在PyMOTW例子的BaseHTTPServer模块中.在一个终端窗口中启动服务器, 然后在另一个窗口中运行以下这些例子.

通过POST代替GET方式传递数据给远程服务器，仅仅是把已编码的查询参数当作数据传递给urlopen().

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[urllib]
query@_args @PYGbe[=] { @PYGad[']@PYGad[q]@PYGad[']:@PYGad[']@PYGad[query string]@PYGad['], @PYGad[']@PYGad[foo]@PYGad[']:@PYGad[']@PYGad[bar]@PYGad['] }
encoded@_args @PYGbe[=] urllib@PYGbe[.]urlencode(query@_args)
url @PYGbe[=] @PYGad[']@PYGad[http://localhost:8080/]@PYGad[']
@PYGay[print] urllib@PYGbe[.]urlopen(url, encoded@_args)@PYGbe[.]read()
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_urlopen@_post.py
Client: ('127.0.0.1', 54545)
Path: /
Form data:
     q=query string
     foo=bar
\end{Verbatim}

如果服务器需要的不是已编码url形式的参数，你可以传递任一字节字符串作为发送的数据。


\section{Paths vs. URLs:}

一些操作系统使用不同的方法分离本地文件路径和URL。为了使代码简捷，你应该反复地使用函数pathname2url() 和 url2pathname()。因为我在Mac上工作，我必须明确引入Windows上的函数版本。使用由urllib导出的函数版本可以让你默认在正确平台下，因此就不用自己做了。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[os]

@PYGay[from] @PYGaV[urllib] @PYGay[import] pathname2url, url2pathname

@PYGay[print] @PYGad[']@PYGad[== Default ==]@PYGad[']
path @PYGbe[=] @PYGad[']@PYGad[/a/b/c]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Original:]@PYGad['], path
@PYGay[print] @PYGad[']@PYGad[URL :]@PYGad['], pathname2url(path)
@PYGay[print] @PYGad[']@PYGad[Path :]@PYGad['], url2pathname(@PYGad[']@PYGad[/d/e/f]@PYGad['])
@PYGay[print]

@PYGay[from] @PYGaV[nturl2path] @PYGay[import] pathname2url, url2pathname

@PYGay[print] @PYGad[']@PYGad[== Windows, without drive letter ==]@PYGad[']
path @PYGbe[=] path@PYGbe[.]replace(@PYGad[']@PYGad[/]@PYGad['], @PYGad[']@PYGao[\\]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[Original:]@PYGad['], path
@PYGay[print] @PYGad[']@PYGad[URL :]@PYGad['], pathname2url(path)
@PYGay[print] @PYGad[']@PYGad[Path :]@PYGad['], url2pathname(@PYGad[']@PYGad[/d/e/f]@PYGad['])
@PYGay[print]

@PYGay[print] @PYGad[']@PYGad[== Windows, with drive letter ==]@PYGad[']
path @PYGbe[=] @PYGad[']@PYGad[C:]@PYGao[\\]@PYGad['] @PYGbe[+] path@PYGbe[.]replace(@PYGad[']@PYGad[/]@PYGad['], @PYGad[']@PYGao[\\]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[Original:]@PYGad['], path
@PYGay[print] @PYGad[']@PYGad[URL :]@PYGad['], pathname2url(path)
@PYGay[print] @PYGad[']@PYGad[Path :]@PYGad['], url2pathname(@PYGad[']@PYGad[/d/e/f]@PYGad['])
\end{Verbatim}

有两个Windows例子，分别是路径的前缀中有和没有驱动器名。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_pathnames.py
== Default ==
Original: /a/b/c
URL : /a/b/c
Path : /d/e/f

== Windows, without drive letter ==
Original: \a\b\c
URL : /a/b/c
Path : \d\e\f

== Windows, with drive letter ==
Original: C:\\a\b\c
URL : ///C|/a/b/c
Path : \d\e\f
\end{Verbatim}


\section{带Cache简单检索：}

检索数据是常见的操作，urllib包括urlretrieve()函数，因此你不用自己写它。urlretrieve()带有URL中的参数, 一个用于存储数据的临时文件, 一个用于报告下载进度的函数, 和URL中要POST数据。如果没有给定文件名，urlretrieve()就建立一个临时文件。你自己能删除它，或者把它看作一个cache，可以用urlcleanup()移除它。

这个例子使用GET从web服务器中检索数据。

\begin{Verbatim}[commandchars=@\[\]]
import urllib
import os

def reporthook(blocks@_read, block@_size, total@_size):
    if not blocks@_read:
        print 'Connection opened'
        return
    if total@_size @textless[] 0:
        @# Unknown size 未知大小
        print 'Read @%d blocks' @% blocks@_read
    else:
        amount@_read = blocks@_read * block@_size
        print 'Read @%d blocks, or @%d/@%d' @% (blocks@_read, amount@_read, total@_size)
        return


 try:
     filename, msg = urllib.urlretrieve('http://blog.doughellmann.com/', reporthook=reporthook)
     print
     print 'File:', filename
     print 'Headers:'
     print msg
     print 'File exists before cleanup:', os.path.exists(filename)
 finally:
     urllib.urlcleanup()
     print 'File still exists:', os.path.exists(filename)
\end{Verbatim}

由于服务器没有返回header中的Content-length，urlretrieve()不知道数据应该有多大，所以将-1传给reporthook()中的参数total\_size。

\begin{Verbatim}[commandchars=@\[\]]
@$ python urllib@_urlretrieve.py
Connection opened
Read 1 blocks
Read 2 blocks
Read 3 blocks
Read 4 blocks
Read 5 blocks
Read 6 blocks
Read 7 blocks
Read 8 blocks
Read 9 blocks
Read 10 blocks
Read 11 blocks
Read 12 blocks
Read 13 blocks
Read 14 blocks
Read 15 blocks
Read 16 blocks
Read 17 blocks
Read 18 blocks
Read 19 blocks

File: /var/folders/9R/9R1t+tR02Raxzk+F71Q50U+++Uw/-Tmp-/tmp3HRpZP
Headers:
Content-Type: text/html; charset=UTF-8
Last-Modified: Tue, 25 Mar 2008 23:09:10 GMT
Cache-Control: max-age=0 private
ETag: "904b02e0-c7ff-47f6-9f35-cc6de5d2a2e5"
Server: GFE/1.3
Date: Sun, 30 Mar 2008 17:36:48 GMT
Connection: Close

File exists before cleanup: True
File still exists: False
\end{Verbatim}


\section{URLopener:}

urllib提供了一个URLopener基类，并且默认使用FancyURLopener处理支持的协议。如果你想要改变其行为，你可能需要查看Python2.1中新加的urllib2模块（PyMOTW将会阐述）。


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.faqs.org/rfcs/rfc2616.html}{RFC 2616 - HTTP Specification}

\item {} 
\href{http://docs.python.org/lib/module-cgi.html}{cgi - For decoding query arguments}

\item {} 
\href{http://blog.doughellmann.com/2007/12/pymotw-basehttpserver.html}{PyMOTW: BaseHTTPServer}

\item {} 
\href{http://docs.python.org/lib/module-urllib2.html}{urllib2 - For more complex URL access needs}

\item {} 
\href{http://www.doughellmann.com/projects/PyMOTW/}{Python Module of the Week Home}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: fnmatch}

使用fnmatch模块处理Unix风格的文件名的比较。
\begin{itemize}
\item {} 
模块： fnmatch

\item {} 
目的： 对文件名和Unix风格模式进行比较。

\item {} 
python版本：1.4+

\end{itemize}


\section{描述}

fnmatch模块用来全局模式上比较文件名(比如在Unix Shell中的模式)。


\section{简单匹配}

\code{fnmatch()} 比较一个简单的文件名和一个模式并且返回一个布尔类型，即匹配返回True，不匹配返回Fasle。如果操作系统使用了一个大小写不敏感的文件系统，那么这种比较也是大小写不敏感的，否则是大小写敏感的。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[fnmatch]
@PYGay[import] @PYGaV[os]

pattern @PYGbe[=] @PYGad[']@PYGad[fnmatch@_*.py]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Pattern :]@PYGad['], pattern
@PYGay[print]

files @PYGbe[=] os@PYGbe[.]listdir(@PYGad[']@PYGad[.]@PYGad['])
@PYGay[for] name @PYGan[in] files:
    @PYGay[print] @PYGad[']@PYGad[Filename: ]@PYGbf[@%-25s]@PYGad[ ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] (name, fnmatch@PYGbe[.]fnmatch(name, pattern))
\end{Verbatim}

这个例子中，模式匹配所有以fnmatch\_开头，以 \code{.py} 结尾的文件名。

\begin{Verbatim}[commandchars=@\[\]]
@$ python fnmatch@_fnmatch.py

Pattern : fnmatch@_*.py

Filename: .svn False
Filename: @_@_init@_@_.py False
Filename: fnmatch@_filter.py True
Filename: fnmatch@_fnmatch.py True
Filename: fnmatch@_fnmatchcase.py True
Filename: fnmatch@_translate.py True
\end{Verbatim}

为了在各个不同文件系统或操作系统设置也能强制匹配大小写，可以使用 \code{fnmatchcase()} 。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[fnmatch]
@PYGay[import] @PYGaV[os]

pattern @PYGbe[=] @PYGad[']@PYGad[FNMATCH@_*.PY]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Pattern :]@PYGad['], pattern
@PYGay[print]

files @PYGbe[=] os@PYGbe[.]listdir(@PYGad[']@PYGad[.]@PYGad['])

@PYGay[for] name @PYGan[in] files:
    @PYGay[print] @PYGad[']@PYGad[Filename: ]@PYGbf[@%-25s]@PYGad[ ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] (name, fnmatch@PYGbe[.]fnmatchcase(name, pattern))
\end{Verbatim}

由于我的笔记本使用大小写敏感的文件系统，所以修改后的模式不匹配任何一个文件。

\begin{Verbatim}[commandchars=@\[\]]
@$ python fnmatch@_fnmatchcase.py
Pattern : FNMATCH@_*.PY

Filename: .svn False
Filename: @_@_init@_@_.py False
Filename: fnmatch@_filter.py False
Filename: fnmatch@_fnmatch.py False
Filename: fnmatch@_fnmatchcase.py False
Filename: fnmatch@_translate.py False
\end{Verbatim}


\section{过滤}

你可以使用 \code{filter()} 来测试一系列的文件名。它返回匹配模式参数的名字列表。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[fnmatch]
@PYGay[import] @PYGaV[os]

pattern @PYGbe[=] @PYGad[']@PYGad[fnmatch@_*.py]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Pattern :]@PYGad['], pattern

files @PYGbe[=] os@PYGbe[.]listdir(@PYGad[']@PYGad[.]@PYGad['])
@PYGay[print] @PYGad[']@PYGad[Files :]@PYGad['], files

@PYGay[print] @PYGad[']@PYGad[Matches :]@PYGad['], fnmatch@PYGbe[.]filter(files, pattern)
\end{Verbatim}

在这个例子中， \code{filter()} 返回这篇文章中所有示例源文件的名字.\# 即他们都以fnmatch\_开头。

\begin{Verbatim}[commandchars=@\[\]]
@$ python fnmatch@_filter.py

Pattern : fnmatch@_*.py
Files : @PYGZlb[]'.svn', '@_@_init@_@_.py', 'fnmatch@_filter.py', 'fnmatch@_fnmatch.py', 'fnmatch@_fnmatchcase.py', 'fnmatch@_translate.py'@PYGZrb[]
Matches : @PYGZlb[]'fnmatch@_filter.py', 'fnmatch@_fnmatch.py', 'fnmatch@_fnmatchcase.py', 'fnmatch@_translate.py'@PYGZrb[]
\end{Verbatim}


\section{翻译模式}

在内部，fnmatch将这种全局模式转换成一个正则式，然后使用re模块来比较名字和模式。 \code{translate()} 函数是一个公共API用于将全局模式转换成正则式。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[fnmatch]

pattern @PYGbe[=] @PYGad[']@PYGad[fnmatch@_*.py]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Pattern :]@PYGad['], pattern
@PYGay[print] @PYGad[']@PYGad[Regex :]@PYGad['], fnmatch@PYGbe[.]translate(pattern)
\end{Verbatim}

\begin{notice}{note}{Note:}
为了得到一个有效的表达式，有些特殊字符被转义。
\end{notice}

\begin{Verbatim}[commandchars=@\[\]]
@$ python fnmatch@_translate.py
Pattern : fnmatch@_*.py
Regex : fnmatch\@_.*\.py@$
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/lib/module-glob.html}{glob module documentation}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: Cookie}
\begin{itemize}
\item {} 
模块： Cookie

\item {} 
目的： 处理来自服务器端的HTTP cookies

\item {} 
python版本： 2.1+

\end{itemize}


\section{描述}

很久以前，Cookies就已成为HTTP协议的一部分。现有的web开发框架提供了简单的访问cookies的接口。因此，程序员几乎不用担心怎样去格式化cookies数据或者确保头的正确发送。明白cookies是怎样工作以及有哪些工作模式是很让人受启发的事情。

Cookie模块实现了对cookies的解析，其大多是兼容RFC 2109的。它没有严重按照标准是因为MSIE 3.0x不支持整个标准。


\section{创建和设置Cookie}

Cookies可以用作状态管理, 通常被服务器存储并由客户端返回。最普通的创建cookies的用法可以如下的样子：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[Cookie]

c @PYGbe[=] Cookie@PYGbe[.]SimpleCookie()
c@lb[]@PYGad[']@PYGad[mycookie]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[cookie@_value]@PYGad[']
@PYGay[print] c
\end{Verbatim}

输出是一个有效的Set-Cookie头，之后会作为HTTP响应传递给客户端。

\begin{Verbatim}[commandchars=@\[\]]
@$ python Cookie@_setheaders.py
Set-Cookie: mycookie=cookie@_value
\end{Verbatim}


\section{Morsels}

控制cookie的其他方面也是有必要的，比如说期限、路径、域。事实上，RFC对应的所有的cookies属性可以通过代表cookie值的Morsel对象来操作。

\begin{Verbatim}[commandchars=@\[\]]
import Cookie
import datetime

def show@_cookie(c):
    print c
    for key, morsel in c.iteritems():
    print
    print 'key =', morsel.key
    print ' value =', morsel.value
    print ' coded@_value =', morsel.coded@_value
    for name in morsel.keys():
        if morsel@PYGZlb[]name@PYGZrb[]:
            print ' @%s = @%s' @% (name, morsel@PYGZlb[]name@PYGZrb[])

c = Cookie.SimpleCookie()

@# A cookie with a value that has to be encoded to fit into the header
c@PYGZlb[]'encoded@_value@_cookie'@PYGZrb[] = '"cookie@_value"'
c@PYGZlb[]'encoded@_value@_cookie'@PYGZrb[]@PYGZlb[]'comment'@PYGZrb[] = 'Notice that this cookie value has escaped quotes'

@# A cookie that only applies to part of a site
c@PYGZlb[]'restricted@_cookie'@PYGZrb[] = 'cookie@_value'
c@PYGZlb[]'restricted@_cookie'@PYGZrb[]@PYGZlb[]'path'@PYGZrb[] = '/sub/path'
c@PYGZlb[]'restricted@_cookie'@PYGZrb[]@PYGZlb[]'domain'@PYGZrb[] = 'PyMOTW'
c@PYGZlb[]'restricted@_cookie'@PYGZrb[]@PYGZlb[]'secure'@PYGZrb[] = True

@# A cookie that expires in 5 minutes
c@PYGZlb[]'with@_max@_age'@PYGZrb[] = 'expires in 5 minutes'
c@PYGZlb[]'with@_max@_age'@PYGZrb[]@PYGZlb[]'max-age'@PYGZrb[] = 300 @# seconds

@# A cookie that expires at a specific time
c@PYGZlb[]'expires@_at@_time'@PYGZrb[] = 'cookie@_value'
expires = datetime.datetime.now() + datetime.timedelta(hours=1)
c@PYGZlb[]'expires@_at@_time'@PYGZrb[]@PYGZlb[]'expires'@PYGZrb[] = expires.strftime('@%a, @%d @%b @%Y @%H:@%M:@%S')

show@_cookie(c)
\end{Verbatim}

以上的例子包括了两个不同的设置cookies期限的方法。你可以设置max-age为一些秒数，或者指定一个cookie失效的时间和日期。

\begin{Verbatim}[commandchars=@\[\]]
@$ python Cookie@_Morsel.py
Set-Cookie: encoded@_value@_cookie="\"cookie@_value\""; Comment=Notice that this cookie value has escaped quotes
Set-Cookie: expires@_at@_time=cookie@_value; expires=Sun, 01 Jun 2008 11:37:00
Set-Cookie: restricted@_cookie=cookie@_value; Domain=PyMOTW; Path=/sub/path; secure
Set-Cookie: with@_max@_age="expires in 5 minutes"; Max-Age=300

key = restricted@_cookie
value = cookie@_value
coded@_value = cookie@_value
domain = PyMOTW
secure = True
path = /sub/path

key = with@_max@_age
value = expires in 5 minutes
coded@_value = "expires in 5 minutes"
max-age = 300

key = encoded@_value@_cookie
value = "cookie@_value"
coded@_value = "\"cookie@_value\""
comment = Notice that this cookie value has escaped quotes

key = expires@_at@_time
value = cookie@_value
coded@_value = cookie@_value
expires = Sun, 01 Jun 2008 11:37:00
\end{Verbatim}

Cookie和Morsel对象都像是一个字典。Morsel对应以下固定的键值：
\begin{itemize}
\item {} 
expires 期限

\item {} 
path 路径

\item {} 
comment 注释

\item {} 
domain 域

\item {} 
max-age 最大时间

\item {} 
secure 安全性

\item {} 
version 版本

\end{itemize}

一个Cookie对象的键是一些独立的会被cookie存储的名字。来自于Morsel的键属性的信息也是可用的。


\section{编码后的值}

cookie头可能会需要编码后的值以便它们被正确的解析。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[Cookie]

c @PYGbe[=] Cookie@PYGbe[.]SimpleCookie()
c@lb[]@PYGad[']@PYGad[integer]@PYGad[']@rb[] @PYGbe[=] @PYGaw[5]
c@lb[]@PYGad[']@PYGad[string@_with@_quotes]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[He said, ]@PYGad["]@PYGad[Hello, World!]@PYGad["]@PYGad[']

@PYGay[for] name @PYGan[in] @lb[]@PYGad[']@PYGad[integer]@PYGad['], @PYGad[']@PYGad[string@_with@_quotes]@PYGad[']@rb[]:
    @PYGay[print] c@lb[]name@rb[]@PYGbe[.]key
    @PYGay[print] @PYGad[']@PYGad[ ]@PYGbf[@%s]@PYGad['] @PYGbe[@%] c@lb[]name@rb[]
    @PYGay[print] @PYGad[']@PYGad[ value=]@PYGbf[@%s]@PYGad['] @PYGbe[@%] c@lb[]name@rb[]@PYGbe[.]value, @PYGaX[type](c@lb[]name@rb[]@PYGbe[.]value)
    @PYGay[print] @PYGad[']@PYGad[ coded@_value=]@PYGbf[@%s]@PYGad['] @PYGbe[@%] c@lb[]name@rb[]@PYGbe[.]coded@_value
    @PYGay[print]
\end{Verbatim}

Morsel.value常常是cookie中已经被解码的值，而 \code{Morsel.coded\_value} 的值是以一种符合传递给客户端要求的形式来表示的。

\begin{Verbatim}[commandchars=@\[\]]
@$ python Cookie@_coded@_value.py
integer
  Set-Cookie: integer=5
  value=5 @textless[]type 'str'@textgreater[]
  coded@_value=5

string@_with@_quotes
  Set-Cookie: string@_with@_quotes="He said, \"Hello, World!\""
  value=He said, "Hello, World!" @textless[]type 'str'@textgreater[]
  coded@_value="He said, \"Hello, World!\""
\end{Verbatim}


\section{接收和解析Cookie头}

一旦客户端收到Set-Cookie头，它会将这些cookies在接下来的请求中作为新的Cookie头返回给服务器。那么传入的头看起来是：

\begin{Verbatim}[commandchars=@\[\]]
Cookie: integer=5; string@_with@_quotes="He said, \"Hello, World!\""
\end{Verbatim}

cookies既可以直接从HTTP响应头，或环境变量HTTP\_COOKIE，这依赖于你的web服务器/框架。实例化时，将经过解码的没有头前缀的字符串传递给SimpleCookie，或者使用 \code{load()} 。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[Cookie]

HTTP@_COOKIE @PYGbe[=] @PYGad[r']@PYGad[integer=5; string@_with@_quotes=]@PYGad["]@PYGad[He said, ]@PYGad[\]@PYGad["]@PYGad[Hello, World!]@PYGad[\]@PYGad["]@PYGad["]@PYGad[']

@PYGay[print] @PYGad[']@PYGad[From constructor:]@PYGad[']
c @PYGbe[=] Cookie@PYGbe[.]SimpleCookie(HTTP@_COOKIE)
@PYGay[print] c

@PYGay[print]
@PYGay[print] @PYGad[']@PYGad[From load():]@PYGad[']
c @PYGbe[=] Cookie@PYGbe[.]SimpleCookie()
c@PYGbe[.]load(HTTP@_COOKIE)
@PYGay[print] c
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python Cookie@_parse.py
From constructor:
Set-Cookie: integer=5
Set-Cookie: string@_with@_quotes="He said, \"Hello, World!\""

From load():
Set-Cookie: integer=5
Set-Cookie: string@_with@_quotes="He said, \"Hello, World!\""
\end{Verbatim}


\section{选择输出格式}

除了使用Set-Cookie头外，使用JavaScript给客户端增加cookies也是可以的。SimpleCookie和Morsel提供一种JavaScript输出格式，通过使用 \code{js\_output()} 方法：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[Cookie]

c @PYGbe[=] Cookie@PYGbe[.]SimpleCookie()
c@lb[]@PYGad[']@PYGad[mycookie]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[cookie@_value]@PYGad[']
c@lb[]@PYGad[']@PYGad[another@_cookie]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[second value]@PYGad[']
@PYGay[print] c@PYGbe[.]js@_output()
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python Cookie@_js@_output.py

 @textless[]script type="text/javascript"@textgreater[]
 @textless[]!-- begin hiding
 document.cookie = "another@_cookie="second value"";
 // end hiding --@textgreater[]
 @textless[]/script@textgreater[]

 @textless[]script type="text/javascript"@textgreater[]
 @textless[]!-- begin hiding
 document.cookie = "mycookie=cookie@_value";
 // end hiding --@textgreater[]
 @textless[]/script@textgreater[]
\end{Verbatim}


\section{不推荐使用的类}

上面所有的例子中都是使用的SimpleCookie类。Cookie模块也提供2个其他的类，SerialCookie和SmartCookie。SerialCookie可以处理任何可以被pickle的值。SmartCookie指明了一个值是否需要被unpickle或者是否是一个简单的值。由于他们两者都使用了pickle，他们是你应用中的潜在安全漏洞，所以你最好不要使用他们。在服务器上存贮cookie状态。然后传递给客户端一个会话key，这是更安全的。


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/lib/module-cookielib.html}{cookielib}

\item {} 
\href{http://www.ietf.org/rfc/rfc2109.txt}{RFC 2109, HTTP State Management Mechanism}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: base64}

base64模块提供一些函数l来把二进制数据转换为ASCII集，通常在明文协议的传输中使用。
\begin{itemize}
\item {} 
模块： base64

\item {} 
目的： 编码二进制数据转化为ASCII码

\item {} 
python版本： 1.4+

\end{itemize}


\section{描述}

base64、base32、base16可以分别编码转化8位字节为6位、5位、4位，允许非ASCII字节以编码为ASCII码的协议中传输，例如SMTP，“base”值对应是在每一个编码中字母表的长度。有一些原始编码的url类型会使用略有不同的结果。


\section{Base64 编码}

简单的文本编码示例如下：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[base64]

initial@_data @PYGbe[=] @PYGaX[open](@_@_file@_@_, @PYGad[']@PYGad[rt]@PYGad['])@PYGbe[.]read()

encoded@_data @PYGbe[=] base64@PYGbe[.]b64encode(initial@_data)

num@_initial @PYGbe[=] @PYGaX[len](initial@_data)
padding @PYGbe[=] { @PYGaw[0]:@PYGaw[0], @PYGaw[1]:@PYGaw[2], @PYGaw[2]:@PYGaw[1] }@lb[]num@_initial @PYGbe[@%] @PYGaw[3]@rb[]

@PYGay[print] @PYGad[']@PYGbf[@%d]@PYGad[ bytes before encoding]@PYGad['] @PYGbe[@%] num@_initial
@PYGay[print] @PYGad[']@PYGad[Expect ]@PYGbf[@%d]@PYGad[ padding bytes]@PYGad['] @PYGbe[@%] padding
@PYGay[print] @PYGad[']@PYGbf[@%d]@PYGad[ bytes after encoding]@PYGad['] @PYGbe[@%] @PYGaX[len](encoded@_data)
@PYGay[print]
@PYGay[print] encoded@_data
\end{Verbatim}

输出显示原来529字节的文本在编码之后被扩展到了708个字节，从编码过程来看，每一个24位序列（3个字节）作为输入，输出时候则增加了4个字节，最后2个字符“==”，则是简单的追加，因为原始字符串的位数不能被24整除。

在标准输出中时没有很多回车府，但是为了在文档中有好的可读性，在如下显示中稍作了变化。

\begin{Verbatim}[commandchars=@\[\]]
@$ python base64@_b64encode.py
529 bytes before encoding
    Expect 2 padding bytes
    708 bytes after encoding

IyEvdXNyL2Jpbi9lbnYgcHl0aG9uCiMgZW5jb2Rpbmc
6IHV0Zi04CiMKIyBDb3B5cmlnaHQgKGMpIDIwMDggRG
91ZyBIZWxsbWFubiBBbGwgcmlnaHRzIHJlc2VydmVkL
gojCiIiIgoiIiIKCl9fdmVyc2lvbl9fID0gIiRJZDog
cHltb3R3LnB5IDEyMzkgMjAwOC0wMS0xNiAxMDo1NTo
xOVogZGhlbGxtYW5uICQiCgppbXBvcnQgYmFzZTY0Cg
ppbml0aWFsX2RhdGEgPSBvcGVuKF9fZmlsZV9fLCAnc
nQnKS5yZWFkKCkKCmVuY29kZWRfZGF0YSA9IGJhc2U2
NC5iNjRlbmNvZGUoaW5pdGlhbF9kYXRhKQoKbnVtX2l
uaXRpYWwgPSBsZW4oaW5pdGlhbF9kYXRhKQpwYWRkaW
5nID0geyAwOjAsIDE6MiwgMjoxIH1bbnVtX2luaXRpY
WwgJSAzXQoKcHJpbnQgJyVkIGJ5dGVzIGJlZm9yZSBl
bmNvZGluZycgJSBudW1faW5pdGlhbApwcmludCAnRXh
wZWN0ICVkIHBhZGRpbmcgYnl0ZXMnICUgcGFkZGluZw
pwcmludCAnJWQgYnl0ZXMgYWZ0ZXIgZW5jb2RpbmcnI
CUgbGVuKGVuY29kZWRfZGF0YSkKcHJpbnQKcHJpbnQg
ZW5jb2RlZF9kYXRhCg==
\end{Verbatim}


\section{Base64 解码}

编码的字符串可以转换为原来的格式，利用反向查询，把4个字节转换为3个字节。b64decode()函数可以帮助你。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[base64]

original@_string @PYGbe[=] @PYGad[']@PYGad[This is the data, in the clear.]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Original:]@PYGad['], original@_string

encoded@_string @PYGbe[=] base64@PYGbe[.]b64encode(original@_string)
@PYGay[print] @PYGad[']@PYGad[Encoded :]@PYGad['], encoded@_string

decoded@_string @PYGbe[=] base64@PYGbe[.]b64decode(encoded@_string)
@PYGay[print] @PYGad[']@PYGad[Decoded :]@PYGad['], decoded@_string
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python base64@_b64decode.py
Original: This is the data, in the clear.
Encoded : VGhpcyBpcyB0aGUgZGF0YSwgaW4gdGhlIGNsZWFyLg==
Decoded : This is the data, in the clear.
\end{Verbatim}


\section{URL-Safe变化}

默认的base64字母表可能会使用+和/，而这些字符可能出现在url中，因此必须为这些字符指定可选择的编码情况，+由a-来代替，(\_)来代替/，其他字母表还是相同。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[base64]

@PYGay[for] original @PYGan[in] @lb[] @PYGad[']@PYGao[\xfb]@PYGao[\xef]@PYGad['], @PYGad[']@PYGao[\xff]@PYGao[\xff]@PYGad['] @rb[]:
    @PYGay[print] @PYGad[']@PYGad[Original         :]@PYGad['], @PYGaX[repr](original)
    @PYGay[print] @PYGad[']@PYGad[Standard encoding:]@PYGad['], base64@PYGbe[.]standard@_b64encode(original)
    @PYGay[print] @PYGad[']@PYGad[URL-safe encoding:]@PYGad['], base64@PYGbe[.]urlsafe@_b64encode(original)
    @PYGay[print]
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python base64@_urlsafe.py
Original         : '\xfb\xef'
Standard encoding: ++8=
URL-safe encoding: --8=

Original         : '\xff\xff'
Standard encoding: //8=
URL-safe encoding: @_@_8=
\end{Verbatim}


\section{其他编码}

除了base 64以外，还有base 32和base 16（16进制）提供函数用于编码数据。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[base64]

original@_string @PYGbe[=] @PYGad[']@PYGad[This is the data, in the clear.]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Original:]@PYGad['], original@_string

encoded@_string @PYGbe[=] base64@PYGbe[.]b32encode(original@_string)
@PYGay[print] @PYGad[']@PYGad[Encoded :]@PYGad['], encoded@_string

decoded@_string @PYGbe[=] base64@PYGbe[.]b32decode(encoded@_string)
@PYGay[print] @PYGad[']@PYGad[Decoded :]@PYGad['], decoded@_string
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python base64@_base32.py
Original: This is the data, in the clear.
Encoded : KRUGS4ZANFZSA5DIMUQGIYLUMEWCA2LOEB2GQZJAMNWGKYLSFY======
Decoded : This is the data, in the clear.
\end{Verbatim}

base 16中的函数是以16进制方式工作。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[base64]

original@_string @PYGbe[=] @PYGad[']@PYGad[This is the data, in the clear.]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Original:]@PYGad['], original@_string

encoded@_string @PYGbe[=] base64@PYGbe[.]b16encode(original@_string)
@PYGay[print] @PYGad[']@PYGad[Encoded :]@PYGad['], encoded@_string

decoded@_string @PYGbe[=] base64@PYGbe[.]b16decode(encoded@_string)
@PYGay[print] @PYGad[']@PYGad[Decoded :]@PYGad['], decoded@_string
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python base64@_base16.py
Original: This is the data, in the clear.
Encoded : 546869732069732074686520646174612C20696E2074686520636C6561722E
Decoded : This is the data, in the clear.
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.faqs.org/rfcs/rfc3548.html}{RFC 3548 - The Base16, Base32, and Base64 Data Encodings}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: webbrowser}

利用webbrowser模块可以向用户显示web页面。
\begin{itemize}
\item {} 
模块：webbrowser

\item {} 
目的：在浏览器中打开web页面

\item {} 
python版本：python2.1.3+

\end{itemize}


\section{描述}

在一个交互式的浏览程序中，webbrowser模块提供了一些用于打开URL链接的函数。在系统中安装的浏览器，通过模块的许多选项可以来获取利用他们。也可通过环境变量BROWSER来控制。


\section{简单示例}

在浏览器中打开一个页面，可以使用open()函数。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[webbrowser]

webbrowser@PYGbe[.]open(@PYGad[']@PYGad[http://docs.python.org/lib/module-webbrowser.html]@PYGad['])
\end{Verbatim}

这个url会在一个新窗口中打开，当然如果当前已经有一个浏览器窗口，那么会做为一个新标签打开。


\section{窗口 Vs 标签}

如果你只想在新窗口中打开页面，那么可以使用 \code{open\_new()} 。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[webbrowser]

webbrowser@PYGbe[.]open@_new(@PYGad[']@PYGad[http://docs.python.org/lib/module-webbrowser.html]@PYGad['])
\end{Verbatim}

如果你想在新的标签中打开，那么可以使用 \code{open\_new\_tab()} 。


\section{使用特定的浏览器}

因为某些原因，你的应用程序可能需要使用特定的浏览器，可以利用get()函数来取得浏览器访问对象，该对象提供了open()、open\_new()和open\_new\_tab()函数，下面示例演示了如何利用lynx浏览器。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[webbrowser]

b @PYGbe[=] webbrowser@PYGbe[.]get(@PYGad[']@PYGad[lynx]@PYGad['])
b@PYGbe[.]open(@PYGad[']@PYGad[http://docs.python.org/lib/module-webbrowser.html]@PYGad['])
\end{Verbatim}

可以参考模块文档来了解浏览器类型列表。


\section{BROWSER 变量}

用户可以在你的应用程序之外为BROWSER变量设置浏览器名字或者命令来控制webbrowser模块，值可以由一系列的浏览器名字组成，中间由系统分割符os.pathsep来分割。如果名字中包含\%s，那么将被解释成命令，并且在URL中\%s将被直接替换执行。否则，值将被传递给get()来获取控制对象。

举个例子，如下示例是打开一个lynx浏览器，假设它是可以获取的，不管是否还存在其它的浏览器。

\begin{Verbatim}[commandchars=@\[\]]
BROWSER=lynx python webbrowser@_open.py
\end{Verbatim}

如果BROWSER中的名字中没有一个可以正确工作，那么webbrowse会返回执行它的默认行为。


\section{命令行接口}

webbrowser模块的所有特性可以通过命令行获取，类似运行一个python程序。

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m webbrowser
Usage: /Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/webbrowser.py @PYGZlb[]-n | -t@PYGZrb[] url
   -n: open new window
   -t: open new tab
\end{Verbatim}

\resetcurrentobjects


\chapter{PyMOTW: anydbm}
\begin{itemize}
\item {} 
模块： anydbm

\item {} 
目的： anydbm提供了针对DBM-style、String-keyed数据库的字典接口。

\item {} 
python版本： 1.4+

\end{itemize}


\section{描述}

anydbm面向DBM数据库 ，利用简单的字符串值作为key来访问包含字符串的记录。它利用whichdb模块来识别dbhash、gdbm和dbm数据库，并使用appropriate模块来打开它们，常常在shelve 中作为后端使用，比如我们知道如何利用pickle来存储对象。她常被用作为shelve的后端，就像我们知道如何利用pickle来存储对象。


\section{创建一个新的数据库}

新数据库的存储格式是可以通过查询如下模块来选择：
\begin{itemize}
\item {} 
dbhash

\item {} 
gdbm

\item {} 
dbm

\item {} 
dumbdbm

\end{itemize}

open函数通过flags标志来控制如何处理数据库文件，当在必要时创建一个新的数据库时候，使用''c'',当经常要创建一个新数据库时，使用''n''。

c和n的区别 ：
也就是说用c，如果不存在则创建，如果存在就不创建新的了，用n的话，不管存不存在都是创建新的空数据库。

开始，我们加载一些有用的模块：

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[anydbm]

db @PYGbe[=] anydbm@PYGbe[.]open(@PYGad[']@PYGad[/tmp/example.db]@PYGad['], @PYGad[']@PYGad[n]@PYGad['])
db@lb[]@PYGad[']@PYGad[key]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[value]@PYGad[']
db@lb[]@PYGad[']@PYGad[today]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[Sunday]@PYGad[']
db@lb[]@PYGad[']@PYGad[author]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[Doug]@PYGad[']
db@PYGbe[.]close()
\end{Verbatim}

在这个例子中，这个文件会总是被重新初始化，如果想知道被创建的数据库类型，可以使用whichdb。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[whichdb]

@PYGay[print] whichdb@PYGbe[.]whichdb(@PYGad[']@PYGad[/tmp/example.db]@PYGad['])
\end{Verbatim}

你得到的结果可能会不同，它取决于你安装在系统中的模块。

\begin{Verbatim}[commandchars=@\[\]]
@$ python anydbm@_whichdb.py
dbhash
\end{Verbatim}


\section{打开一个存在的数据库}

要打开一个存在的数据库，使用标记''r''（只读）或者''w''（读写）。你不需要担心格式问题，因为数据库格式会自动由whichdb来识别，如果一个文件可以被识别，那么对应的模块会打开它。

\begin{Verbatim}[commandchars=@\[\]]
import anydbm

db = anydbm.open('/tmp/example.db', 'r')
try:
    print 'keys():', db.keys()
    for k, v in db.iteritems():
        print 'iterating:', k, v
    print 'db@PYGZlb[]"author"@PYGZrb[] =', db@PYGZlb[]'author'@PYGZrb[]
 finally:
    db.close()
\end{Verbatim}

一旦打开，db就是一个字典对象，支持一些常规方法：

\begin{Verbatim}[commandchars=@\[\]]
@$ python anydbm@_existing.py
keys(): @PYGZlb[]'key', 'today', 'author'@PYGZrb[]
iterating: key value
iterating: today Sunday
iterating: author Doug
db@PYGZlb[]"author"@PYGZrb[] = Doug
\end{Verbatim}


\section{错误案例}

数据库关键词必须是字符串。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[anydbm]

db @PYGbe[=] anydbm@PYGbe[.]open(@PYGad[']@PYGad[/tmp/example.db]@PYGad['], @PYGad[']@PYGad[w]@PYGad['])
@PYGay[try]:
    db@lb[]@PYGaw[1]@rb[] @PYGbe[=] @PYGad[']@PYGad[one]@PYGad[']
@PYGay[finally]:
    db@PYGbe[.]close()
\end{Verbatim}

传递其它类型结果将导致TypeError异常。

\begin{Verbatim}[commandchars=@\[\]]
@$ python anydbm@_intkeys.py
Traceback (most recent call last):
File "/Users/dhellmann/Documents/PyMOTW/in@_progress/anydbm/PyMOTW/anydbm/anydbm@_intkeys.py", line 16, in @textless[]module@textgreater[]
db@PYGZlb[]1@PYGZrb[] = 'one'
File "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/bsddb/@_@_init@_@_.py", line 230, in @_@_setitem@_@_
@_DeadlockWrap(wrapF) @# self.db@PYGZlb[]key@PYGZrb[] = value
File "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/bsddb/dbutils.py", line 62, in DeadlockWrap
return function(*@_args, **@_kwargs)
File "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/bsddb/@_@_init@_@_.py", line 229, in wrapF
self.db@PYGZlb[]key@PYGZrb[] = value
TypeError: Integer keys only allowed for Recno and Queue DB's
\end{Verbatim}

值必须是字符串或者是空。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[anydbm]

db @PYGbe[=] anydbm@PYGbe[.]open(@PYGad[']@PYGad[/tmp/example.db]@PYGad['], @PYGad[']@PYGad[w]@PYGad['])
@PYGay[try]:
    db@lb[]@PYGad[']@PYGad[one]@PYGad[']@rb[] @PYGbe[=] @PYGaw[1]
@PYGay[finally]:
    db@PYGbe[.]close()
\end{Verbatim}

如果值是非字符串，那么同样会抛出TypeError异常。

\begin{Verbatim}[commandchars=@\[\]]
@$ python anydbm@_intvalue.py
Traceback (most recent call last):
File "/Users/dhellmann/Documents/PyMOTW/in@_progress/anydbm/PyMOTW/anydbm/anydbm@_intvalue.py", line 16, in @textless[]module@textgreater[]
db@PYGZlb[]'one'@PYGZrb[] = 1
File "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/bsddb/@_@_init@_@_.py", line 230, in @_@_setitem@_@_
@_DeadlockWrap(wrapF) @# self.db@PYGZlb[]key@PYGZrb[] = value
File "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/bsddb/dbutils.py", line 62, in DeadlockWrap
return function(*@_args, **@_kwargs)
File "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/bsddb/@_@_init@_@_.py", line 229, in wrapF
self.db@PYGZlb[]key@PYGZrb[] = value
TypeError: Data values must be of type string or None.
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/lib/module-anydbm.html}{标准库文件：anydbm}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: smtplib}
\begin{itemize}
\item {} 
模块：smtplib

\item {} 
目的: 与smtp服务器交互，提供邮件发送

\item {} 
python版本：1.5.2+

\end{itemize}

smtplib包含了SMTP类，用于与邮件服务器进行邮件通信。

\begin{notice}{note}{Note:}
在以下示例中，邮件地址、主机名称、ip地址都是虚假的，但是举例说明的命令副本和响应的信息都是存在的。
\end{notice}


\section{发送一封邮件}

SMTP最常用的方法是连接服务器并发送一封邮件，在构造器中指定邮件服务器名和端口名，或者你可以使用connect()方法来指定。一旦建立连接，就可以调用sendmail()函数，并附带信封体参数和消息内容，消息文本应该与RFC2822兼容。smtplib不会自动修改消息内容和头信息，这就意味着你需要自己添加From和To等头信息。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[smtplib]
@PYGay[import] @PYGaV[email.utils]
@PYGay[from] @PYGaV[email.mime.text] @PYGay[import] MIMEText

@PYGaD[@# Create the message]
msg @PYGbe[=] MIMEText(@PYGad[']@PYGad[This is the body of the message.]@PYGad['])
msg@lb[]@PYGad[']@PYGad[To]@PYGad[']@rb[] @PYGbe[=] email@PYGbe[.]utils@PYGbe[.]formataddr((@PYGad[']@PYGad[Recipient]@PYGad['], @PYGad[']@PYGad[recipient@at[]example.com]@PYGad[']))
msg@lb[]@PYGad[']@PYGad[From]@PYGad[']@rb[] @PYGbe[=] email@PYGbe[.]utils@PYGbe[.]formataddr((@PYGad[']@PYGad[Author]@PYGad['], @PYGad[']@PYGad[author@at[]example.com]@PYGad[']))
msg@lb[]@PYGad[']@PYGad[Subject]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[Simple test message]@PYGad[']

server @PYGbe[=] smtplib@PYGbe[.]SMTP(@PYGad[']@PYGad[mail]@PYGad['])
server@PYGbe[.]set@_debuglevel(@PYGaA[True]) @PYGaD[@# show communication with the server显示与服务器的通信情况]
@PYGay[try]:
    server@PYGbe[.]sendmail(@PYGad[']@PYGad[author@at[]example.com]@PYGad['], @lb[]@PYGad[']@PYGad[recipient@at[]example.com]@PYGad[']@rb[], msg@PYGbe[.]as@_string())
@PYGay[finally]:
    server@PYGbe[.]quit()
\end{Verbatim}

在这个示例中，调试开关被打开了，这样可以显示客户端和服务端之间的通讯信息，否则，示例不会显示任何信息。

\begin{Verbatim}[commandchars=@\[\]]
@$ python smtplib@_sendmail.py
send: 'ehlo localhost.local\r\n'
reply: '250-mail.example.com Hello @PYGZlb[]192.168.1.17@PYGZrb[], pleased to meet you\r\n'
reply: '250-ENHANCEDSTATUSCODES\r\n'
reply: '250-PIPELINING\r\n'
reply: '250-8BITMIME\r\n'
reply: '250-SIZE\r\n'
reply: '250-DSN\r\n'
reply: '250-ETRN\r\n'
reply: '250-AUTH GSSAPI DIGEST-MD5 CRAM-MD5\r\n'
reply: '250-DELIVERBY\r\n'
reply: '250 HELP\r\n'
reply: retcode (250); Msg: mail.example.com Hello @PYGZlb[]192.168.1.17@PYGZrb[], pleased to meet you
ENHANCEDSTATUSCODES
PIPELINING
8BITMIME
SIZE
DSN
ETRN
AUTH GSSAPI DIGEST-MD5 CRAM-MD5
DELIVERBY
HELP
send: 'mail FROM:@textless[]author@PYGZat[]example.com@textgreater[] size=266\r\n'
reply: '250 2.1.0 @textless[]author@PYGZat[]example.com@textgreater[]... Sender ok\r\n'
reply: retcode (250); Msg: 2.1.0 @textless[]author@PYGZat[]example.com@textgreater[]... Sender ok
send: 'rcpt TO:@textless[]recipient@PYGZat[]example.com@textgreater[]\r\n'
reply: '250 2.1.5 @textless[]recipient@PYGZat[]example.com@textgreater[]... Recipient ok\r\n'
reply: retcode (250); Msg: 2.1.5 @textless[]recipient@PYGZat[]example.com@textgreater[]... Recipient ok
send: 'data\r\n'
reply: '354 Enter mail, end with "." on a line by itself\r\n'
reply: retcode (354); Msg: Enter mail, end with "." on a line by itself
data: (354, 'Enter mail, end with "." on a line by itself')
send: 'From nobody Sun Sep 28 10:02:48 2008\r\nContent-Type: text/plain; charset="us-ascii"\r\nMIME-Version: 1.0\r\nContent-Transfer-Encoding: 7bit\r\nTo: Recipient @textless[]recipient@PYGZat[]example.com@textgreater[]\r\nFrom: Author @textless[]author@PYGZat[]example.com@textgreater[]\r\nSubject: Simple test message\r\n\r\nThis is the body of the message.\r\n.\r\n'
reply: '250 2.0.0 m8SE2mpc015614 Message accepted for delivery\r\n'
reply: retcode (250); Msg: 2.0.0 m8SE2mpc015614 Message accepted for delivery
data: (250, '2.0.0 m8SE2mpc015614 Message accepted for delivery')
send: 'quit\r\n'
reply: '221 2.0.0 mail.example.com closing connection\r\n'
reply: retcode (221); Msg: 2.0.0 mail.example.com closing connection
\end{Verbatim}

注意sendmail的第二个参数，收件人信息需要是一个list结构，你可以在list写上很多的邮件地址，message会依次把消息发送给他们. 由于信封信息和和邮件头是分开的，所以你可以通过一些方法参数来指定密送一些人，但不可以在邮件头中设置。


\section{认证和加密}

SMTP同样可以处理认证和TLS(一种底层通讯的安全协议)加密。如果服务器支持它们，你可以自己来检测服务器是否支持TLS，可以直接调用ehlo()来鉴定并询问服务器支持何种类型扩展 。然后通过调用has\_extn()来检查结果。一旦启动TLS，你可以在认证之前再次调用ehlo()。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[smtplib]
@PYGay[import] @PYGaV[email.utils]
@PYGay[from] @PYGaV[email.mime.text] @PYGay[import] MIMEText
@PYGay[import] @PYGaV[getpass]

@PYGaD[@# Prompt the user for connection info]
to@_email @PYGbe[=] @PYGaX[raw@_input](@PYGad[']@PYGad[Recipient: ]@PYGad['])
servername @PYGbe[=] @PYGaX[raw@_input](@PYGad[']@PYGad[Mail server name: ]@PYGad['])
username @PYGbe[=] @PYGaX[raw@_input](@PYGad[']@PYGad[Mail user name: ]@PYGad['])
password @PYGbe[=] getpass@PYGbe[.]getpass(@PYGad["]@PYGbf[@%s]@PYGad[']@PYGad[s password: ]@PYGad["] @PYGbe[@%] username)

@PYGaD[@# Create the message]
msg @PYGbe[=] MIMEText(@PYGad[']@PYGad[Test message from PyMOTW.]@PYGad['])
msg@PYGbe[.]set@_unixfrom(@PYGad[']@PYGad[author]@PYGad['])
msg@lb[]@PYGad[']@PYGad[To]@PYGad[']@rb[] @PYGbe[=] email@PYGbe[.]utils@PYGbe[.]formataddr((@PYGad[']@PYGad[Recipient]@PYGad['], to@_email))
msg@lb[]@PYGad[']@PYGad[From]@PYGad[']@rb[] @PYGbe[=] email@PYGbe[.]utils@PYGbe[.]formataddr((@PYGad[']@PYGad[Author]@PYGad['], @PYGad[']@PYGad[author@at[]example.com]@PYGad[']))
msg@lb[]@PYGad[']@PYGad[Subject]@PYGad[']@rb[] @PYGbe[=] @PYGad[']@PYGad[Test from PyMOTW]@PYGad[']

server @PYGbe[=] smtplib@PYGbe[.]SMTP(servername)
@PYGay[try]:
    server@PYGbe[.]set@_debuglevel(@PYGaA[True])

    @PYGaD[@# identify ourselves, prompting server for supported features]
    server@PYGbe[.]ehlo()

    @PYGaD[@# If we can encrypt this session, do it]
    @PYGay[if] server@PYGbe[.]has@_extn(@PYGad[']@PYGad[STARTTLS]@PYGad[']):
         server@PYGbe[.]starttls()
         server@PYGbe[.]ehlo() @PYGaD[@# re-identify ourselves over TLS connection]

    server@PYGbe[.]login(username, password)
    server@PYGbe[.]sendmail(@PYGad[']@PYGad[author@at[]example.com]@PYGad['], @lb[]to@_email@rb[], msg@PYGbe[.]as@_string())
@PYGay[finally]:
    server@PYGbe[.]quit()
\end{Verbatim}

注意STARTTLS不会出现在扩展列表中，因为启动了TLS。

\begin{Verbatim}[commandchars=@\[\]]
@$ python smtplib@_authenticated.py
Recipient: recipient@PYGZat[]example.com
Mail server name: smtpauth.isp.net
Mail user name: user@PYGZat[]isp.net
user@PYGZat[]isp.net's password:
send: 'ehlo localhost.local\r\n'
reply: '250-elasmtp-isp.net Hello localhost.local @PYGZlb[]@textless[]your IP here@textgreater[]@PYGZrb[]\r\n'
reply: '250-SIZE 14680064\r\n'
reply: '250-PIPELINING\r\n'
reply: '250-AUTH PLAIN LOGIN CRAM-MD5\r\n'
reply: '250-STARTTLS\r\n'
reply: '250 HELP\r\n'
reply: retcode (250); Msg: elasmtp-isp.net Hello localhost.local @PYGZlb[]@textless[]your IP here@textgreater[]@PYGZrb[]
SIZE 14680064
PIPELINING
AUTH PLAIN LOGIN CRAM-MD5
STARTTLS
HELP
send: 'STARTTLS\r\n'
reply: '220 TLS go ahead\r\n'
reply: retcode (220); Msg: TLS go ahead
send: 'ehlo localhost.local\r\n'
reply: '250-elasmtp-isp.net Hello localhost.local @PYGZlb[]@textless[]your IP here@textgreater[]@PYGZrb[]\r\n'
reply: '250-SIZE 14680064\r\n'
reply: '250-PIPELINING\r\n'
reply: '250-AUTH PLAIN LOGIN CRAM-MD5\r\n'
reply: '250 HELP\r\n'
reply: retcode (250); Msg: elasmtp-isp.net Hello farnsworth.local @PYGZlb[]@textless[]your IP here@textgreater[]@PYGZrb[]
SIZE 14680064
PIPELINING
AUTH PLAIN LOGIN CRAM-MD5
HELP
send: 'AUTH CRAM-MD5\r\n'
reply: '334 PDExNjkyLjEyMjI2MTI1NzlAZWxhc210cC1tZWFseS5hdGwuc2EuZWFydGhsaW5rLm5ldD4=\r\n'
reply: retcode (334); Msg: PDExNjkyLjEyMjI2MTI1NzlAZWxhc210cC1tZWFseS5hdGwuc2EuZWFydGhsaW5rLm5ldD4=
send: 'ZGhlbGxtYW5uQGVhcnRobGluay5uZXQgN2Q1YjAyYTRmMGQ1YzZjM2NjOTNjZDc1MDQxN2ViYjg=\r\n'
reply: '235 Authentication succeeded\r\n'
reply: retcode (235); Msg: Authentication succeeded
send: 'mail FROM:@textless[]author@PYGZat[]example.com@textgreater[] size=221\r\n'
reply: '250 OK\r\n'
reply: retcode (250); Msg: OK
send: 'rcpt TO:@textless[]recipient@PYGZat[]example.com@textgreater[]\r\n'
reply: '250 Accepted\r\n'
reply: retcode (250); Msg: Accepted
send: 'data\r\n'
reply: '354 Enter message, ending with "." on a line by itself\r\n'
reply: retcode (354); Msg: Enter message, ending with "." on a line by itself
data: (354, 'Enter message, ending with "." on a line by itself')
send: 'Content-Type: text/plain; charset="us-ascii"\r\nMIME-Version: 1.0\r\nContent-Transfer-Encoding: 7bit\r\nTo: Recipient @textless[]recipient@PYGZat[]example.com@textgreater[]\r\nFrom: Author @textless[]author@PYGZat[]example.com@textgreater[]\r\nSubject: Test from PyMOTW\r\n\r\nTest message from PyMOTW.\r\n.\r\n'
reply: '250 OK id=1KjxNj-00032a-Ux\r\n'
reply: retcode (250); Msg: OK id=1KjxNj-00032a-Ux
data: (250, 'OK id=1KjxNj-00032a-Ux')
send: 'quit\r\n'
reply: '221 elasmtp-isp.net closing connection\r\n'
reply: retcode (221); Msg: elasmtp-isp.net closing connection
\end{Verbatim}


\section{验证一个邮件地址}

SMTP协议包含一个命令可以询问服务器一个邮件地址是否合法，通常VRFY是关闭的，以防止垃圾邮件发送者找到合法的邮件地址，但是，如果它打开，你可以向服务器询问这个邮件地址并接受一个状态码，如果是可用的，那么会返回一个可用的完整用户名。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[smtplib]

server @PYGbe[=] smtplib@PYGbe[.]SMTP(@PYGad[']@PYGad[mail]@PYGad['])
server@PYGbe[.]set@_debuglevel(@PYGaA[True]) @PYGaD[@# show communication with the server]
@PYGay[try]:
    dhellmann@_result @PYGbe[=] server@PYGbe[.]verify(@PYGad[']@PYGad[dhellmann]@PYGad['])
    notthere@_result @PYGbe[=] server@PYGbe[.]verify(@PYGad[']@PYGad[notthere]@PYGad['])
@PYGay[finally]:
    server@PYGbe[.]quit()

@PYGay[print] @PYGad[']@PYGad[dhellmann:]@PYGad['], dhellmann@_result
@PYGay[print] @PYGad[']@PYGad[notthere :]@PYGad['], notthere@_result
\end{Verbatim}

最后二行输出中表示，地址 dhellmann是合法的，notthere是非法的。

\begin{Verbatim}[commandchars=@\[\]]
@$ python smtplib@_verify.py
send: 'vrfy @textless[]dhellmann@textgreater[]\r\n'
reply: '250 2.1.5 Doug Hellmann @textless[]dhellmann@PYGZat[]mail.example.com@textgreater[]\r\n'
reply: retcode (250); Msg: 2.1.5 Doug Hellmann @textless[]dhellmann@PYGZat[]mail.example.com@textgreater[]
send: 'vrfy @textless[]notthere@textgreater[]\r\n'
reply: '550 5.1.1 @textless[]notthere@textgreater[]... User unknown\r\n'
reply: retcode (550); Msg: 5.1.1 @textless[]notthere@textgreater[]... User unknown
send: 'quit\r\n'
reply: '221 2.0.0 mail.example.com closing connection\r\n'
reply: retcode (221); Msg: 2.0.0 mail.example.com closing connection
dhellmann: (250, '2.1.5 Doug Hellmann @textless[]dhellmann@PYGZat[]mail.example.com@textgreater[]')
notthere : (550, '5.1.1 @textless[]notthere@textgreater[]... User unknown')
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://www.faqs.org/rfcs/rfc821.html}{RFC 821: Simple Mail Transfer Protocol}

\item {} 
\href{http://www.faqs.org/rfcs/rfc822.html}{RFC 822: Standard for the Format of ARPA Internet Text Messages}

\item {} 
\href{http://www.faqs.org/rfcs/rfc1869.html}{RFC 1869: SMTP Service Extensions}

\item {} 
\href{http://www.faqs.org/rfcs/rfc2822.html}{RFC 2822: Internet Message Format}

\item {} 
\href{http://docs.python.org/lib/module-smtplib.html}{标准库文档: smtplib}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: Trace}
\begin{itemize}
\item {} 
模块：Trace

\item {} 
目的: 监控程序语句和函数运行情况,并且产生报告信息.

\item {} 
python版本：2.3+

\end{itemize}

trace - 跟踪正在执行的Python语句

trace模块帮助你明白程序的运行过程.你可以跟踪执行的语句,产生报表,也能获取函数间的调用关系.


\section{命令行接口}

可以很简单的直接从命令行使用trace.给定以下的Python脚本:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[recurse] @PYGay[import] recurse

@PYGay[def] @PYGaK[main]():
     @PYGay[print] @PYGad[']@PYGad[This is the main program.]@PYGad[']
     recurse(@PYGaw[2])
     @PYGay[return]

@PYGay[if] @_@_name@_@_ @PYGbe[==] @PYGad[']@PYGad[@_@_main@_@_]@PYGad[']:
     main()

@PYGay[def] @PYGaK[recurse](level):
     @PYGay[print] @PYGad[']@PYGad[recurse(]@PYGbf[@%s]@PYGad[)]@PYGad['] @PYGbe[@%] level
     @PYGay[if] level:
         recurse(level@PYGbe[-]@PYGaw[1])
     @PYGay[return]

@PYGay[def] @PYGaK[not@_called]():
     @PYGay[print] @PYGad[']@PYGad[This function is never called.]@PYGad[']
\end{Verbatim}


\section{跟踪时的异常}

我们可以使用--trace选项来查看程序运行时哪条语句正在被执行.

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --trace trace@_example/main.py
--- modulename: threading, funcname: settrace
threading.py(70): @_trace@_hook = func
--- modulename: trace, funcname: @textless[]module@textgreater[]
@textless[]string@textgreater[](1): --- modulename: trace, funcname: @textless[]module@textgreater[]
main.py(7): """
main.py(12): from recurse import recurse
--- modulename: recurse, funcname: @textless[]module@textgreater[]
recurse.py(7): """
recurse.py(12): def recurse(level):
main.py(14): def main():
main.py(19): if @_@_name@_@_ == '@_@_main@_@_':
main.py(20): main()
--- modulename: trace, funcname: main
main.py(15): print 'This is the main program.'
This is the main program.
main.py(16): recurse(2)
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(2)
recurse.py(14): if level:
recurse.py(15): recurse(level-1)
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(1)
recurse.py(14): if level:
recurse.py(15): recurse(level-1)
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(0)
recurse.py(14): if level:
recurse.py(16): return
recurse.py(16): return
recurse.py(16): return
main.py(17): return
\end{Verbatim}

输出结构的第一部分表明了trace的一个安装操作.剩下来的输出显示了每个函数的入口信息,包括函数位于哪个模块,然后是原脚本文件中的语句行.你可以看到函数recurse()被进入了3次,正如你在main()中调用的那样.


\section{代码报告}

从命令行中运行trace并使用--count选项可以产生代码信息报告,因此可以看到哪些行是被执行的,哪些被跳过了.因为你的程序通常是多个文件组成,那就会为每个文件产生独立的报表.默认下,报表文件在和模块的同一目录下被创建,并以模块名命名,而且使用.cover后缀名替换.py.

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --count trace@_example/main.py
This is the main program.
recurse(2)
recurse(1)
recurse(0)
\end{Verbatim}

两个输出文件, trace\_example/main.cover:

\begin{Verbatim}[commandchars=@\[\]]
1: from recurse import recurse

1: def main():
1:     print 'This is the main program.'
1:     recurse(2)
1:     return

1: if @_@_name@_@_ == '@_@_main@_@_':
1:     main()
\end{Verbatim}

trace\_example/recurse.cover:

\begin{Verbatim}[commandchars=@\[\]]
1: def recurse(level):
3:     print 'recurse(@%s)' @% level
3:     if level:
2:         recurse(level-1)
3:     return
\end{Verbatim}

\begin{notice}{note}{Note:}
虽然代码行def recurse(level):有一个1数值, 这不意味着这个函数仅运行一次,而是意味着这个函数definition仅被执行一次.
使用不同的选项来多次运行程序是有可能的,并且保存报告数据,产生一个联合报告.
\end{notice}

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --coverdir coverdir1 --count --file coverdir1/coverage@_report.dat trace@_example/main.py
This is the main program.
recurse(2)
recurse(1)
recurse(0)
Skipping counts file 'coverdir1/coverage@_report.dat': @PYGZlb[]Errno 2@PYGZrb[] No such file or directory: 'coverdir1/coverage@_report.dat'
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --coverdir coverdir1 --count --file coverdir1/coverage@_report.dat trace@_example/main.py
This is the main program.
recurse(2)
recurse(1)
recurse(0)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --coverdir coverdir1 --count --file coverdir1/coverage@_report.dat trace@_example/main.py
This is the main program.
recurse(2)
recurse(1)
recurse(0)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ find coverdir1
coverdir1
coverdir1/coverage@_report.dat
\end{Verbatim}

一旦报告信息被记录到.cover文件中,你可以使用--report选项产生报告.

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --coverdir coverdir1 --report --summary --missing --file coverdir1/coverage@_report.dat trace@_example/main.py
lines cov@% module (path)
533 0@% threading (/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/threading.py)
8 100@% trace@_example.main (trace@_example/main.py)
8 87@% trace@_example.recurse (trace@_example/recurse.py)
@$ find coverdir1
coverdir1
coverdir1/coverage@_report.dat
coverdir1/threading.cover
coverdir1/trace@_example.main.cover
coverdir1/trace@_example.recurse.cover
\end{Verbatim}

程序一共运行了3次,因此在报告中显示的值要比第一份报告中的值高3倍.--summary选项在输出信息中增加了百分比信息.模块recurse只有 87\%被报告.从这个报告中还可看到not\_called()这个函数从未被运行,这个是由前缀\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}表示.

\begin{Verbatim}[commandchars=@\[\]]
3: def recurse(level):
9:     print 'recurse(@%s)' @% level
9:     if level:
6:         recurse(level-1)
9:     return

3: def not@_called():
@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[] print 'This function is never called.'
\end{Verbatim}


\section{调用关系}

除了以上覆盖信息,trace还可以收集函数间调用关系.使用--listfuncs可以在结果中输出简单的函数调用关系:

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --listfuncs trace@_example/main.py
This is the main program.
recurse(2)
recurse(1)
recurse(0)

functions called:
filename: /Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/threading.py, modulename: threading, funcname: settrace
filename: @textless[]string@textgreater[], modulename: @textless[]string@textgreater[], funcname: @textless[]module@textgreater[]
filename: trace@_example/main.py, modulename: main, funcname: @textless[]module@textgreater[]
filename: trace@_example/main.py, modulename: main, funcname: main
filename: trace@_example/recurse.py, modulename: recurse, funcname: @textless[]module@textgreater[]
filename: trace@_example/recurse.py, modulename: recurse, funcname: recurse
\end{Verbatim}

可以使用--trackcalls获得更多信息,比如说谁调用了函数.

\begin{Verbatim}[commandchars=@\[\]]
@$ python -m trace --listfuncs --trackcalls trace@_example/main.py
This is the main program.
recurse(2)
recurse(1)
recurse(0)

calling relationships:

*** /Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/trace.py ***
--@textgreater[] /Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/threading.py
trace.Trace.run -@textgreater[] threading.settrace
--@textgreater[] @textless[]string@textgreater[]
trace.Trace.run -@textgreater[] @textless[]string@textgreater[].@textless[]module@textgreater[]

*** @textless[]string@textgreater[] ***
--@textgreater[] trace@_example/main.py
@textless[]string@textgreater[].@textless[]module@textgreater[] -@textgreater[] main.@textless[]module@textgreater[]

*** trace@_example/main.py ***
main.@textless[]module@textgreater[] -@textgreater[] main.main
--@textgreater[] trace@_example/recurse.py
main.@textless[]module@textgreater[] -@textgreater[] recurse.@textless[]module@textgreater[]
main.main -@textgreater[] recurse.recurse

*** trace@_example/recurse.py ***
recurse.recurse -@textgreater[] recurse.recurse
\end{Verbatim}


\section{编程接口}

通过trace接口增加更多的控制,你可以在你的程序中使用Trace对象.Trace可以让你设置fixtures和其他依赖关系在运行单个函数前或执行一个用于跟踪的Python命令.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[trace]
@PYGay[from] @PYGaV[trace@_example.recurse] @PYGay[import] recurse

tracer @PYGbe[=] trace@PYGbe[.]Trace(count@PYGbe[=]@PYGaA[False], trace@PYGbe[=]@PYGaA[True])
tracer@PYGbe[.]run(@PYGad[']@PYGad[recurse(2)]@PYGad['])
\end{Verbatim}

由于例子只跟踪到recurse()函数, 所以结果中没有把main.py的信息包含进来.

\begin{Verbatim}[commandchars=@\[\]]
@$ python trace@_run.py
--- modulename: threading, funcname: settrace
threading.py(70): @_trace@_hook = func
--- modulename: trace@_run, funcname: @textless[]module@textgreater[]
@textless[]string@textgreater[](1): --- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(2)
recurse.py(14): if level:
recurse.py(15): recurse(level-1)
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(1)
recurse.py(14): if level:
recurse.py(15): recurse(level-1)
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(0)
recurse.py(14): if level:
recurse.py(16): return
recurse.py(16): return
recurse.py(16): return
\end{Verbatim}

使用runfunc()也可以得到上述同样的输出.runfunc()接收任意位置和关键字参数,他们在函数被tracer调用时都被传递给函数.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[trace]
@PYGay[from] @PYGaV[trace@_example.recurse] @PYGay[import] recurse

tracer @PYGbe[=] trace@PYGbe[.]Trace(count@PYGbe[=]@PYGaA[False], trace@PYGbe[=]@PYGaA[True])
tracer@PYGbe[.]runfunc(recurse, @PYGaw[2])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python trace@_runfunc.py
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(2)
recurse.py(14): if level:
recurse.py(15): recurse(level-1)
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(1)
recurse.py(14): if level:
recurse.py(15): recurse(level-1)
--- modulename: recurse, funcname: recurse
recurse.py(13): print 'recurse(@%s)' @% level
recurse(0)
recurse.py(14): if level:
recurse.py(16): return
recurse.py(16): return
recurse.py(16): return
\end{Verbatim}


\section{保存结果数据}

就像在命令行中使用一样, 计算和报告信息也可以被记录下来.使用Trace对象的CoverageResults可以将这些数据明确的保存下来.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[trace]
@PYGay[from] @PYGaV[trace@_example.recurse] @PYGay[import] recurse

tracer @PYGbe[=] trace@PYGbe[.]Trace(count@PYGbe[=]@PYGaA[True], trace@PYGbe[=]@PYGaA[False])
tracer@PYGbe[.]runfunc(recurse, @PYGaw[2])

results @PYGbe[=] tracer@PYGbe[.]results()
results@PYGbe[.]write@_results(coverdir@PYGbe[=]@PYGad[']@PYGad[coverdir2]@PYGad['])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python trace@_CoverageResults.py
recurse(2)
recurse(1)
recurse(0)

@$ find coverdir2
coverdir2/
coverdir2//trace@_example.recurse.cover

@$ cat coverdir2/trace@_example.recurse.cover
@#!/usr/bin/env python
@# encoding: utf-8
@#
@# Copyright (c) 2008 Doug Hellmann All rights reserved.
@#
"""
"""

@#@_@_version@_@_ = "@$Id: recurse.py 1732 2008-10-12 14:50:28Z dhellmann @$"
@#end@_pymotw@_header

@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[] def recurse(level):
3: print 'recurse(@%s)' @% level
3: if level:
2: recurse(level-1)
3: return

@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[] def not@_called():
@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[]@textgreater[] print 'This function is never called.'
\end{Verbatim}

为了在生成报告时也保存计算数据,可以使用参数infile和outfile.

\begin{Verbatim}[commandchars=@\[\]]
mport trace
from trace@_example.recurse import recurse

tracer = trace.Trace(count=True, trace=False, outfile='trace@_report.dat')
tracer.runfunc(recurse, 2)

report@_tracer = trace.Trace(count=False, trace=False, infile='trace@_report.dat')
results = tracer.results()
results.write@_results(summary=True, coverdir='/tmp')
\end{Verbatim}

传递给参数infile一个文件名来余弦读取存储的数据, 参数outfile指定在跟踪之后需要新建的一个结果文件名.如果infile和outfile是相同的,那么,就相当于在原有文件中增加新的数据.

\begin{Verbatim}[commandchars=@\[\]]
@$ python trace@_report.py
recurse(2)
recurse(1)
recurse(0)
lines cov@% module (path)
7 57@% trace@_example.recurse (trace@_example/recurse.py)
\end{Verbatim}


\section{Trace选项}

Trace构造器可以带多个可选参数以便更好的控制运行行为.
\begin{itemize}
\item {} 
count:        布尔型.打开行号计数.默认是True.

\item {} 
countfuncs:   布尔型.打开运行中函数调用列表.默认是False

\item {} 
countcallers: 布尔型.打开跟踪时的调用者和被调用者信息.默认是False.

\item {} 
ignoremods:   序列.在跟踪报告中需要忽略的模块或包列表.默认是一个空元祖.

\item {} 
ignoredirs:   序列.在跟踪报告中需要忽略的目录(其中包含模块或包)列表.默认是一个空元祖.

\item {} 
infile:       包含缓存信息的文件名,作为输入.默认是None.

\item {} 
outfile:      用于存储缓存信息的文件名,作为输入.默认是None,也就是数据不被存储.

\end{itemize}


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/library/trace.html}{标准库文档: trace}

\end{itemize}

\resetcurrentobjects


\chapter{PyMOTW: Struct}
\begin{itemize}
\item {} 
模块：Struct

\item {} 
目的: 实现字符串和二进制数据之间的相互转换

\item {} 
python版本：1.4 +

\end{itemize}

struct模块包含了实现字符串字节和Python本地数据类型(如数字和字符串)间的相互转换的函数.


\section{函数 vs Struct类}

这里有一系列用来处理结构化数值的模块级函数, 同样存在Struct类(Python 2.5中新加入的). 格式化描述即将字符串格式转化为可编译形式,类似于正则式的方式. 这种转换需要消耗一些资源,所以一旦创建Struct实例后并调用Struct实例的方法而不使用模块级的方法,这样是更有效的.下面举些使用Struct类的例子.


\section{封装和解封}

Structs支持将数据封装成字符串,也能够通过格式化描述(它是由一些代表特定数据类型的字符,可选的个数和字节序指示符组成的)从字符串中解封数据. 进一步的细节,可以参考 \href{http://docs.python.org/library/struct.html}{标准库文档}

在下面的这个例子中, 格式化描述调用了一个整型或者长整型数, 一个2个字符组成的字符串和一个浮点数. 为了清晰描述，在格式化描述中包含了空格，但格式被编译后将忽略这个空格.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[struct]
@PYGay[import] @PYGaV[binascii]

values @PYGbe[=] (@PYGaw[1], @PYGad[']@PYGad[ab]@PYGad['], @PYGaw[2.7])
s @PYGbe[=] struct@PYGbe[.]Struct(@PYGad[']@PYGad[I 2s f]@PYGad['])
packed@_data @PYGbe[=] s@PYGbe[.]pack(@PYGbe[*]values)

@PYGay[print] @PYGad[']@PYGad[Original values:]@PYGad['], values
@PYGay[print] @PYGad[']@PYGad[Format string  :]@PYGad['], s@PYGbe[.]format
@PYGay[print] @PYGad[']@PYGad[Uses           :]@PYGad['], s@PYGbe[.]size, @PYGad[']@PYGad[bytes]@PYGad[']
@PYGay[print] @PYGad[']@PYGad[Packed Value   :]@PYGad['], binascii@PYGbe[.]hexlify(packed@_data)
\end{Verbatim}

封装后的值被转换成16进制字节流输出,所以有些字符显示为空

\begin{Verbatim}[commandchars=@\[\]]
@$ python struct@_pack.py
Original values: (1, 'ab', 2.7000000000000002)
Format string  : I 2s f
Uses           : 12 bytes
Packed Value   : 0100000061620000cdcc2c40
\end{Verbatim}

如果我们将封装后的值传递给unpack(), 可以基本上得到原来的数值(注意其中浮点数的差异).

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[struct]
@PYGay[import] @PYGaV[binascii]

packed@_data @PYGbe[=] binascii@PYGbe[.]unhexlify(@PYGad[']@PYGad[0100000061620000cdcc2c40]@PYGad['])

s @PYGbe[=] struct@PYGbe[.]Struct(@PYGad[']@PYGad[I 2s f]@PYGad['])
unpacked@_data @PYGbe[=] s@PYGbe[.]unpack(packed@_data)
@PYGay[print] @PYGad[']@PYGad[Unpacked Values:]@PYGad['], unpacked@_data
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python struct@_unpack.py
Unpacked Values: (1, 'ab', 2.7000000476837158)
\end{Verbatim}


\section{字节序}

默认情况下,使用标准C库中''字节序''的概念将数值编码.通过在字符串格式中直接指定一个明确的字节序可以简单的覆盖这个选项.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[struct]
@PYGay[import] @PYGaV[binascii]

values @PYGbe[=] (@PYGaw[1], @PYGad[']@PYGad[ab]@PYGad['], @PYGaw[2.7])
@PYGay[print] @PYGad[']@PYGad[Original values:]@PYGad['], values

endianness @PYGbe[=] @lb[]
    (@PYGad[']@PYGad[@at[]]@PYGad['], @PYGad[']@PYGad[native, native]@PYGad[']),
    (@PYGad[']@PYGad[=]@PYGad['], @PYGad[']@PYGad[native, standard]@PYGad[']),
    (@PYGad[']@PYGad[@textless[]]@PYGad['], @PYGad[']@PYGad[little-endian]@PYGad[']),
    (@PYGad[']@PYGad[@textgreater[]]@PYGad['], @PYGad[']@PYGad[big-endian]@PYGad[']),
    (@PYGad[']@PYGad[!]@PYGad['], @PYGad[']@PYGad[network]@PYGad[']),
@rb[]


@PYGay[for] code, name @PYGan[in] endianness:
    s @PYGbe[=] struct@PYGbe[.]Struct(code @PYGbe[+] @PYGad[']@PYGad[ I 2s f]@PYGad['])
    packed@_data @PYGbe[=] s@PYGbe[.]pack(@PYGbe[*]values)
    @PYGay[print]
    @PYGay[print] @PYGad[']@PYGad[Format string  :]@PYGad['], s@PYGbe[.]format, @PYGad[']@PYGad[for]@PYGad['], name
    @PYGay[print] @PYGad[']@PYGad[Uses           :]@PYGad['], s@PYGbe[.]size, @PYGad[']@PYGad[bytes]@PYGad[']
    @PYGay[print] @PYGad[']@PYGad[Packed Value   :]@PYGad['], binascii@PYGbe[.]hexlify(packed@_data)
    @PYGay[print] @PYGad[']@PYGad[Unpacked Value :]@PYGad['], s@PYGbe[.]unpack(packed@_data)
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python struct@_endianness.py
Original values: (1, 'ab', 2.7000000000000002)

Format string  : @PYGZat[] I 2s f for native, native
Uses           : 12 bytes
Packed Value   : 0100000061620000cdcc2c40
Unpacked Value : (1, 'ab', 2.7000000476837158)

Format string  : = I 2s f for native, standard
Uses           : 10 bytes
Packed Value   : 010000006162cdcc2c40
Unpacked Value : (1, 'ab', 2.7000000476837158)

Format string  : @textless[] I 2s f for little-endian
Uses           : 10 bytes
Packed Value   : 010000006162cdcc2c40
Unpacked Value : (1, 'ab', 2.7000000476837158)

Format string  : @textgreater[] I 2s f for big-endian
Uses           : 10 bytes
Packed Value   : 000000016162402ccccd
Unpacked Value : (1, 'ab', 2.7000000476837158)

Format string  : ! I 2s f for network
Uses           : 10 bytes
Packed Value   : 000000016162402ccccd
Unpacked Value : (1, 'ab', 2.7000000476837158)
\end{Verbatim}


\section{缓冲}

在高性能的敏感情况或者通过通过第三方模块来传递数据经常会要求对二进制数据进行封装.一种优化的方式是避免为每一个封装结构分配新的缓冲区.函数pack\_into()和unpack\_from()支持直接写入到预分配的缓冲区中.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[struct]
@PYGay[import] @PYGaV[binascii]

s @PYGbe[=] struct@PYGbe[.]Struct(@PYGad[']@PYGad[I 2s f]@PYGad['])
values @PYGbe[=] (@PYGaw[1], @PYGad[']@PYGad[ab]@PYGad['], @PYGaw[2.7])
@PYGay[print] @PYGad[']@PYGad[Original:]@PYGad['], values

@PYGay[print]
@PYGay[print] @PYGad[']@PYGad[ctypes string buffer]@PYGad[']

@PYGay[import] @PYGaV[ctypes]
b @PYGbe[=] ctypes@PYGbe[.]create@_string@_buffer(s@PYGbe[.]size)
@PYGay[print] @PYGad[']@PYGad[Before  :]@PYGad['], binascii@PYGbe[.]hexlify(b@PYGbe[.]raw)
s@PYGbe[.]pack@_into(b, @PYGaw[0], @PYGbe[*]values)
@PYGay[print] @PYGad[']@PYGad[After   :]@PYGad['], binascii@PYGbe[.]hexlify(b@PYGbe[.]raw)
@PYGay[print] @PYGad[']@PYGad[Unpacked:]@PYGad['], s@PYGbe[.]unpack@_from(b, @PYGaw[0])

@PYGay[print]
@PYGay[print] @PYGad[']@PYGad[array]@PYGad[']

@PYGay[import] @PYGaV[array]
a @PYGbe[=] array@PYGbe[.]array(@PYGad[']@PYGad[c]@PYGad['], @PYGad[']@PYGao[\0]@PYGad['] @PYGbe[*]s@PYGbe[.]size)
@PYGay[print] @PYGad[']@PYGad[Before  :]@PYGad['], binascii@PYGbe[.]hexlify(a)
s@PYGbe[.]pack@_into(a, @PYGaw[0], @PYGbe[*]values)
@PYGay[print] @PYGad[']@PYGad[After   :]@PYGad['], binascii@PYGbe[.]hexlify(a)
@PYGay[print] @PYGad[']@PYGad[Unpacked:]@PYGad['], s@PYGbe[.]unpack@_from(a, @PYGaw[0])
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python struct@_buffers.py

Original: (1, 'ab', 2.7000000000000002)

ctypes string buffer
Before  : 000000000000000000000000
After   : 0100000061620000cdcc2c40
Unpacked: (1, 'ab', 2.7000000476837158)

array
Before  : 000000000000000000000000
After   : 0100000061620000cdcc2c40
Unpacked: (1, 'ab', 2.7000000476837158)
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/library/struct.html}{struct}

\item {} 
array：用于处理固定类型的序列.

\item {} 
binascii：用于产生二进制数据的ASCII表示.

\item {} 
\href{http://en.wikipedia.org/wiki/Endianness}{WikiPedia: Endianness}

\end{itemize}

字节序,其实是数据的二进制形式的排列顺序,在内存存贮顺序,或者是传输时的顺序,或者还有其他特殊的规定.

\resetcurrentobjects


\chapter{PyMOTW: array}

time模块提供了操作日期和时间的函数
\begin{itemize}
\item {} 
模块： array

\item {} 
目的： 有效管理固定数值序列。

\item {} 
python版本：1.4+

\end{itemize}

数组模块定义了一个序列型的数据结构，非常像一个列表，只是其中元素的类型是相同的。支持的数据类型在 \href{http://docs.python.org/library/array.html}{标准库文档} 中列出了。他们是所有数值型或其他固定大小的基本数据类型，如bytes。


\section{数组的初始化}

一个数组实例化时需要一个描述数据类型的参数，还可能需要一个初始化序列。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[array]
@PYGay[import] @PYGaV[binascii]

s @PYGbe[=] @PYGad[']@PYGad[This is the array.]@PYGad[']
a @PYGbe[=] array@PYGbe[.]array(@PYGad[']@PYGad[c]@PYGad['], s)

@PYGay[print] @PYGad[']@PYGad[As string:]@PYGad['], s
@PYGay[print] @PYGad[']@PYGad[As array :]@PYGad['], a
@PYGay[print] @PYGad[']@PYGad[As hex :]@PYGad['], binascii@PYGbe[.]hexlify(a)
\end{Verbatim}

在这个例子中，数组保存的是一字节序列并且用一个简单的字符串来初始化。

\begin{Verbatim}[commandchars=@\[\]]
@$ python array@_string.py
As string: This is the array.
As array : array('c', @PYGZlb[]84, 104, 105, 115, 32, 105, 115,
32, 116, 104, 101, 32, 97, 114, 114, 97, 121, 46@PYGZrb[])
As hex : 54686973206973207468652061727261792e
\end{Verbatim}


\section{处理数组}

一个数组可以被扩展，否则也可以与其他Python序列的相同的方式处理。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[array]

a @PYGbe[=] array@PYGbe[.]array(@PYGad[']@PYGad[i]@PYGad['], @PYGaX[xrange](@PYGaw[5]))
@PYGay[print] @PYGad[']@PYGad[Initial :]@PYGad['], a

a@PYGbe[.]extend(@PYGaX[xrange](@PYGaw[5]))
@PYGay[print] @PYGad[']@PYGad[Extended:]@PYGad['], a

@PYGay[print] @PYGad[']@PYGad[Slice :]@PYGad['], a@lb[]@PYGaw[3]:@PYGaw[6]@rb[]

@PYGay[print] @PYGad[']@PYGad[Iterator:]@PYGad['], @PYGaX[list](@PYGaX[enumerate](a))
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python array@_sequence.py
Initial : array('i', @PYGZlb[]0, 1, 2, 3, 4@PYGZrb[])
Extended: array('i', @PYGZlb[]0, 1, 2, 3, 4, 0, 1, 2, 3, 4@PYGZrb[])
Slice : array('i', @PYGZlb[]3, 4, 0@PYGZrb[])
Iterator: @PYGZlb[](0, 0), (1, 1), (2, 2), (3, 3), (4, 4),
(5, 0), (6, 1), (7, 2), (8, 3), (9, 4)@PYGZrb[]
\end{Verbatim}


\section{数组和文件}

使用一些编码高效的内置方法可以从文件中读入一个数组的内容，或者将数组内容写入文件中。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[array]
@PYGay[import] @PYGaV[binascii]
@PYGay[import] @PYGaV[tempfile]

a @PYGbe[=] array@PYGbe[.]array(@PYGad[']@PYGad[i]@PYGad['], @PYGaX[xrange](@PYGaw[5]))
@PYGay[print] @PYGad[']@PYGad[A1:]@PYGad['], a

@PYGaD[@# Write the array of numbers to the file]
output @PYGbe[=] tempfile@PYGbe[.]NamedTemporaryFile()
a@PYGbe[.]tofile(output@PYGbe[.]file) @PYGaD[@# must pass an *actual* file]
output@PYGbe[.]flush()

@PYGaD[@# Read the raw data]
@PYGaX[input] @PYGbe[=] @PYGaX[open](output@PYGbe[.]name, @PYGad[']@PYGad[rb]@PYGad['])
raw@_data @PYGbe[=] @PYGaX[input]@PYGbe[.]read()
@PYGay[print] @PYGad[']@PYGad[Raw Contents:]@PYGad['], binascii@PYGbe[.]hexlify(raw@_data)

@PYGaD[@# Read the data into an array]
@PYGaX[input]@PYGbe[.]seek(@PYGaw[0])
a2 @PYGbe[=] array@PYGbe[.]array(@PYGad[']@PYGad[i]@PYGad['])
a2@PYGbe[.]fromfile(@PYGaX[input], @PYGaX[len](a))
@PYGay[print] @PYGad[']@PYGad[A2:]@PYGad['], a2
\end{Verbatim}

这个例子中，直接从二进制文件中读取原数据，并将它读入一个新的数组并将其转换为合适的类型。

\begin{Verbatim}[commandchars=@\[\]]
@$ python array@_file.py
A1: array('i', @PYGZlb[]0, 1, 2, 3, 4@PYGZrb[])
Raw Contents: 0000000001000000020000000300000004000000 @#@# ?
A2: array('i', @PYGZlb[]0, 1, 2, 3, 4@PYGZrb[])
\end{Verbatim}


\section{交替字节排序}

如果数组中的数据不是按照本地字节序排列，或者在写入到文件之前需要进行交换来适合不同系统的不同字节序，很容易对整个数组进行这种转换。

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[array]

@PYGay[import] @PYGaV[binascii]

@PYGay[def] @PYGaK[to@_hex](a):
    chars@_per@_item @PYGbe[=] a@PYGbe[.]itemsize @PYGbe[*] @PYGaw[2] @PYGaD[@# 2 hex digits]
    hex@_version @PYGbe[=] binascii@PYGbe[.]hexlify(a)
    num@_chunks @PYGbe[=] @PYGaX[len](hex@_version) @PYGbe[/] chars@_per@_item
    @PYGay[for] i @PYGan[in] @PYGaX[xrange](num@_chunks):
        start @PYGbe[=] i@PYGbe[*]chars@_per@_item
        end @PYGbe[=] start @PYGbe[+] chars@_per@_item
        @PYGay[yield] hex@_version@lb[]start:end@rb[]

a1 @PYGbe[=] array@PYGbe[.]array(@PYGad[']@PYGad[i]@PYGad['], @PYGaX[xrange](@PYGaw[5]))
a2 @PYGbe[=] array@PYGbe[.]array(@PYGad[']@PYGad[i]@PYGad['], @PYGaX[xrange](@PYGaw[5]))
a2@PYGbe[.]byteswap()

fmt @PYGbe[=] @PYGad[']@PYGbf[@%10s]@PYGad[ ]@PYGbf[@%10s]@PYGad[ ]@PYGbf[@%10s]@PYGad[ ]@PYGbf[@%10s]@PYGad[']
@PYGay[print] fmt @PYGbe[@%] (@PYGad[']@PYGad[A1 hex]@PYGad['], @PYGad[']@PYGad[A1]@PYGad['], @PYGad[']@PYGad[A2 hex]@PYGad['], @PYGad[']@PYGad[A2]@PYGad['])
@PYGay[print] fmt @PYGbe[@%] ((@PYGad[']@PYGad[-]@PYGad['] @PYGbe[*] @PYGaw[10],) @PYGbe[*] @PYGaw[4])
@PYGay[for] values @PYGan[in] @PYGaX[zip](to@_hex(a1), a1, to@_hex(a2), a2):
    @PYGay[print] fmt @PYGbe[@%] values
\end{Verbatim}

\begin{Verbatim}[commandchars=@\[\]]
@$ python array@_byteswap.py
   A1 hex      A1        A2 hex       A2
 ---------- ---------- ---------- ----------
  00000000     0        00000000       0
  01000000     1        00000001    16777216
  02000000     2        00000002    33554432
  03000000     3        00000003    50331648
  04000000     4        00000004    67108864
\end{Verbatim}


\section{参考}
\begin{itemize}
\item {} 
\href{http://docs.python.org/library/array.html}{array}

\item {} 
\href{http://www.scipy.org/}{Numerical Python} NumPy是Python针对大数据集的有效处理模块。

\end{itemize}


\chapter{索引表}
\begin{itemize}
\item {} 
\emph{索引}

\item {} 
\emph{模块索引}

\item {} 
\emph{搜索页面}

\end{itemize}


\renewcommand{\indexname}{Module Index}
\printmodindex
\renewcommand{\indexname}{Index}
\printindex
\end{document}
